{
    "version": "https://jsonfeed.org/version/1",
    "title": "QWERTY • All posts by \"除錯\" tag",
    "description": "Programming | Computer Science | Thought",
    "home_page_url": "http://gitqwerty777.github.io",
    "items": [
        {
            "id": "http://gitqwerty777.github.io/gdb-introduction/",
            "url": "http://gitqwerty777.github.io/gdb-introduction/",
            "title": "gdb簡介",
            "date_published": "2014-09-19T01:35:58.000Z",
            "content_html": "<h2 id=\"簡介\"><a href=\"#簡介\" class=\"headerlink\" title=\"簡介\"></a>簡介</h2><p>只要使用GNU計畫出產的編譯器(如gcc)，就可以用gdb來進行除錯，包含 C/C++/Objective-C/Fortran/Java 等語言。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"基本知識\"><a href=\"#基本知識\" class=\"headerlink\" title=\"基本知識\"></a>基本知識</h2><p><strong>function stack → frame</strong></p>\n<ul>\n<li>C語言在進入一個函式前，會將原本所在的函式的資訊(變數值、函式名、指標)儲存至堆疊(stack)裡，等到回傳(return)後再從這些堆疊裡復原函式資訊</li>\n<li>目前正在執行的函式就是 frame 0，而呼叫frame 0的函式就是frame 1，以此類推</li>\n</ul>\n<h2 id=\"除錯程序\"><a href=\"#除錯程序\" class=\"headerlink\" title=\"除錯程序\"></a>除錯程序</h2><ol>\n<li>載入程式</li>\n<li>設中斷點</li>\n<li>執行程式，程式跑到中斷點會停下來</li>\n<li>在堆疊間跳躍，並檢查變數值</li>\n</ol>\n<h3 id=\"載入程式\"><a href=\"#載入程式\" class=\"headerlink\" title=\"載入程式\"></a>載入程式</h3><ul>\n<li>編譯時加入 <code>-g</code> 可加入除錯資訊。這些除錯訊息會影響程式大小和執行速度，所以一般在發佈應用程式時是不會以<code>-g</code>參數編譯的。<ul>\n<li>可以在事後利用 strip 指令清掉應用程式裡的除錯資訊。</li>\n</ul>\n</li>\n<li>編譯時最好不要開optimization(<code>-O</code>)，不然優化後的程式的執行順序會改變，較難debug。</li>\n</ul>\n<p>執行<code>gdb [program]</code>即可開始除錯</p>\n<table>\n<thead>\n<tr>\n<th>gdb程式參數</th>\n<th>簡寫</th>\n<th>說明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-symbols [file_name]</td>\n<td>-s</td>\n<td>讀取檔案中的除錯表</td>\n</tr>\n<tr>\n<td>-exec [file_name]</td>\n<td>-e</td>\n<td>除錯一個執行檔</td>\n</tr>\n<tr>\n<td>-core [file_name]</td>\n<td>-c</td>\n<td>讀入一個core dump檔案</td>\n</tr>\n<tr>\n<td>-pid [process_id]</td>\n<td>-p</td>\n<td>啟動attach模式，除錯一個執行中的程式</td>\n</tr>\n<tr>\n<td>-directory [directory_name]</td>\n<td>-d</td>\n<td>將資料夾加入原始碼的搜尋路徑</td>\n</tr>\n<tr>\n<td>-readnow</td>\n<td>-r</td>\n<td>一次讀取完所有的符號表，這會讓啟動gdb的時間變長，但在執行往後的除錯動作會較快速。</td>\n</tr>\n<tr>\n<td>-quiet/-silent</td>\n<td>-q</td>\n<td>安靜模式，啟動時gdb將不會顯示版權頁。</td>\n</tr>\n<tr>\n<td>-cd directory_name</td>\n<td></td>\n<td>改變程式執行的目錄</td>\n</tr>\n<tr>\n<td>–args</td>\n<td></td>\n<td>這個參數要當作命令列的最後一個參數，其後跟隨的參數都會被視為「傳給要除錯的程式的參數」</td>\n</tr>\n</tbody></table>\n<h3 id=\"設中斷點\"><a href=\"#設中斷點\" class=\"headerlink\" title=\"設中斷點\"></a>設中斷點</h3><p><code>[breakpoint]</code> 可以是 file+line number, function name, memory address</p>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>停止時機</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>break</td>\n<td>gdb執行下一個指令後停止</td>\n</tr>\n<tr>\n<td>break [breakpoint]</td>\n<td>在指定行數、函式開始前、或指定位址停止</td>\n</tr>\n<tr>\n<td>break [breakpoint] if [condition]</td>\n<td>只有在符合條件時停止</td>\n</tr>\n<tr>\n<td>break [offset]</td>\n<td>在目前程式停止位置的offset行<br>停止offset負數時，為前offset行，反之</td>\n</tr>\n<tr>\n<td>break [filename]:[linenum]</td>\n<td>指定檔案的指定行停止</td>\n</tr>\n<tr>\n<td>rbreak [RE]</td>\n<td>符合正規表示式的函式停止<br>如 <code>rbreak .</code>, 這樣每個函式開頭都有中斷點了</td>\n</tr>\n<tr>\n<td>tbreak</td>\n<td>只會生效一次，能放的參數與break相同</td>\n</tr>\n<tr>\n<td>disable [breakpoint number]</td>\n<td>暫時關閉指定中斷點，若無指定則全部關閉</td>\n</tr>\n<tr>\n<td>enable [breakpoint number]</td>\n<td>取消暫時關閉狀態</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>說明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>info break</td>\n<td>列出目前所有的中斷點</td>\n</tr>\n<tr>\n<td>condition [breakpoint number] [condition]</td>\n<td>設中斷點的條件，如果條件為true才中斷</td>\n</tr>\n<tr>\n<td>commands [breakpoint number] [command]</td>\n<td>設定遇到指定中斷點時要自動執行的指令</td>\n</tr>\n<tr>\n<td>clear [breakpoint]</td>\n<td>刪除指定中斷點</td>\n</tr>\n<tr>\n<td>delete [breakpoint number]</td>\n<td>刪除指定中斷點</td>\n</tr>\n</tbody></table>\n<h3 id=\"執行程式\"><a href=\"#執行程式\" class=\"headerlink\" title=\"執行程式\"></a>執行程式</h3><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>說明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>file [filename]</td>\n<td>開啟檔案 (等同於 gdb filename)</td>\n</tr>\n<tr>\n<td>run</td>\n<td>執行程式 (可加參數)</td>\n</tr>\n<tr>\n<td>kill</td>\n<td>終止程式</td>\n</tr>\n<tr>\n<td>set</td>\n<td>設定特定參數(或變數)<br>如：<code>set environment CFLAGS=-g</code></td>\n</tr>\n<tr>\n<td>unset</td>\n<td>取消特定參數<br>如：<code>unset environment</code></td>\n</tr>\n<tr>\n<td>show</td>\n<td>顯示特定參數<br>如：<code>show environment</code></td>\n</tr>\n<tr>\n<td>set/show args</td>\n<td>設定/顯示 命令列的參數</td>\n</tr>\n<tr>\n<td>attach [PID]</td>\n<td>載入正在執行的程式以進行除錯。PID 可由 ps 指令取得</td>\n</tr>\n<tr>\n<td>detach [PID]</td>\n<td>釋放已 attach 的程式</td>\n</tr>\n</tbody></table>\n<h3 id=\"在堆疊間跳躍\"><a href=\"#在堆疊間跳躍\" class=\"headerlink\" title=\"在堆疊間跳躍\"></a>在堆疊間跳躍</h3><table>\n<thead>\n<tr>\n<th>主要指令</th>\n<th>說明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>next</td>\n<td>執行<strong>當前函式</strong>的一個指令<br>若指令為呼叫函式，則直接跑完，不會進入frame中</td>\n</tr>\n<tr>\n<td>step</td>\n<td>執行函式中的一個指令<br>若指令為呼叫函式，會進入新的frame中</td>\n</tr>\n<tr>\n<td>until</td>\n<td>直接跑完迴圈(for, while…)</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>繼續執行，直到下一個中斷點或是程式停止</td>\n</tr>\n<tr>\n<td>return</td>\n<td>視同該 frame 已執行完畢<br>等同插入C語言指令<code>return;</code></td>\n</tr>\n</tbody></table>\n<p>※註：若該函式的除錯資訊沒有編進執行檔裡的話，那<code>step</code>也不會跳進這個函式裡，而是單純的將它看作一行程式碼(如同next的作用)，如標準函式庫(如<code>stdio.h</code>)提供的函式。</p>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>說明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>backtrace</td>\n<td>堆疊追蹤。會顯示出所有的 frame 的資訊<br> = <code>info frame</code></td>\n</tr>\n<tr>\n<td>frame</td>\n<td>顯示現在的行數、函式、及其所傳送的參數</td>\n</tr>\n<tr>\n<td>frame [frame number]</td>\n<td>切換到指定的frame(以印出區域變數)</td>\n</tr>\n<tr>\n<td>up</td>\n<td>回到上一層frame，也就是原本的frame被呼叫的地方，並顯示其 stack 資訊<br><code>up 3</code>: 回到上三層frame(0 → 3)</td>\n</tr>\n<tr>\n<td>down</td>\n<td>到下一層frame</td>\n</tr>\n<tr>\n<td>finish</td>\n<td>執行完目前的frame</td>\n</tr>\n<tr>\n<td>jump [location]</td>\n<td>直接跳到指定位置(行數，函式…)</td>\n</tr>\n</tbody></table>\n<h4 id=\"列出原始碼\"><a href=\"#列出原始碼\" class=\"headerlink\" title=\"列出原始碼\"></a>列出原始碼</h4><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>說明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>list(第一次)</td>\n<td>列出現在執行的位置上下5行</td>\n</tr>\n<tr>\n<td>list(第二次以後)</td>\n<td>繼續印出之後的程式碼(類似page down)</td>\n</tr>\n<tr>\n<td>list -</td>\n<td>印出上一次list的程式碼的前一段程式碼(類似page up)</td>\n</tr>\n<tr>\n<td>list a,b</td>\n<td>印出第 a ~ b 行</td>\n</tr>\n<tr>\n<td>list [filename]:[number]</td>\n<td>列出某檔案的第幾行，檔案名可省略</td>\n</tr>\n<tr>\n<td>list [function]</td>\n<td>列出某函數的程式碼</td>\n</tr>\n<tr>\n<td>show listsize</td>\n<td>顯示現在一次印出幾行</td>\n</tr>\n<tr>\n<td>set listsize [num]</td>\n<td>設定一次印出幾行</td>\n</tr>\n</tbody></table>\n<h3 id=\"檢查變數值\"><a href=\"#檢查變數值\" class=\"headerlink\" title=\"檢查變數值\"></a>檢查變數值</h3><p>可以顯示某些資訊以利於debug</p>\n<h4 id=\"print-display\"><a href=\"#print-display\" class=\"headerlink\" title=\"print, display\"></a>print, display</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">(gdb) <span class=\"built_in\">print</span> i</span><br><span class=\"line\"><span class=\"variable\">$1</span> = 6078</span><br></pre></td></tr></table></figure>\n\n<p>輸入 <code>print/格式字元 [variable]</code> 可以指定型態，與printf不同的以粗體表示  </p>\n<table>\n<thead>\n<tr>\n<th>x</th>\n<th>格式字元</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>d</td>\n<td>整數</td>\n</tr>\n<tr>\n<td>u</td>\n<td>無號整數(unsigned)</td>\n</tr>\n<tr>\n<td>o</td>\n<td>八進位</td>\n</tr>\n<tr>\n<td><strong>t</strong></td>\n<td>二進位</td>\n</tr>\n<tr>\n<td><strong>a</strong></td>\n<td>位址</td>\n</tr>\n<tr>\n<td>c</td>\n<td>字元</td>\n</tr>\n<tr>\n<td>f</td>\n<td>浮點數</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>說明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>whatis [variable]</td>\n<td>顯示指定變數的型態</td>\n</tr>\n<tr>\n<td>print arr[1]@5</td>\n<td>印出變數arr[1]和之後的變數，共印出5個(arr[1]~arr[5])</td>\n</tr>\n<tr>\n<td>print *arr@3</td>\n<td>印出陣列arr的前3個變數(arr[0]~arr[2])</td>\n</tr>\n<tr>\n<td>display [variable]</td>\n<td>每次中斷時會顯示指定變數值</td>\n</tr>\n</tbody></table>\n<h4 id=\"變數\"><a href=\"#變數\" class=\"headerlink\" title=\"變數\"></a>變數</h4><p>執行 print 指令後，gdb 產生臨時變數(如<code>$1</code>)來記錄<br>可以直接利用 <code>$1</code> 來取用這個變數</p>\n<p>用於 print 及 display 的參數名稱</p>\n<ul>\n<li><code>$7</code>: 第七個運算式</li>\n<li><code>$</code>: 前一個的運算式</li>\n<li><code>$$</code>: 前二個的運算式</li>\n<li><code>$$7</code>: 前七個的運算式</li>\n<li><code>$pc</code> program counter</li>\n<li><code>$sp</code> stack pointer</li>\n</ul>\n<h4 id=\"設定新變數\"><a href=\"#設定新變數\" class=\"headerlink\" title=\"設定新變數\"></a>設定新變數</h4><p>取代冗長路徑的變數，如在深層資料結構中的變數<br>(註: 此變數為 pass by reference, 修改新變數的值也會修改原本的變數)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">set $newv &#x3D; model-&gt;dataset-&gt;vector-&gt;data</span><br><span class=\"line\">p *($newv++)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"info-檢視詳細資訊\"><a href=\"#info-檢視詳細資訊\" class=\"headerlink\" title=\"info: 檢視詳細資訊\"></a>info: 檢視詳細資訊</h4><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>說明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>info break</td>\n<td>列出目前所有的中斷點</td>\n</tr>\n<tr>\n<td>info line</td>\n<td>查看程式目前運行的行數</td>\n</tr>\n<tr>\n<td>info frame</td>\n<td>詳細的frame資訊</td>\n</tr>\n<tr>\n<td>info args</td>\n<td>顯示傳給目前執行函式的參數值</td>\n</tr>\n<tr>\n<td>info locals</td>\n<td>顯示目前執行函式內所有區域變數的值</td>\n</tr>\n<tr>\n<td>info reg</td>\n<td>顯示暫存器(register)的值</td>\n</tr>\n<tr>\n<td>info all-reg</td>\n<td>顯示暫存器的值，包括數學運算暫存器</td>\n</tr>\n<tr>\n<td>info handle</td>\n<td>列出目前處理 signal 的設定</td>\n</tr>\n<tr>\n<td>info share</td>\n<td>顯示共享函式庫資訊</td>\n</tr>\n</tbody></table>\n<h2 id=\"其他指令\"><a href=\"#其他指令\" class=\"headerlink\" title=\"其他指令\"></a>其他指令</h2><ul>\n<li><code>quit</code> 結束 = <code>q</code></li>\n<li><code>shell [command]</code> 在shell上執行指令</li>\n<li>Enter鍵: 重複上一個命令</li>\n</ul>\n<h3 id=\"信號-signal-處理\"><a href=\"#信號-signal-處理\" class=\"headerlink\" title=\"信號(signal)處理\"></a>信號(signal)處理</h3><p><code>handle [signal] [operation]</code></p>\n<ul>\n<li>預設operation為 <code>stop</code>, <code>print</code>, <code>noignore</code>，也就是遇到 signal 時，GDB 會先攔截，並暫停程式</li>\n<li>必要時可以改為 <code>nostop</code>, <code>noprint</code>，讓程式本身去處理 signal</li>\n<li>若下達 <code>ignore</code> 則是讓程式忽略此 signal</li>\n</ul>\n<h3 id=\"thread處理\"><a href=\"#thread處理\" class=\"headerlink\" title=\"thread處理\"></a>thread處理</h3><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>說明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>thread</td>\n<td>查看目前在哪個 thread</td>\n</tr>\n<tr>\n<td>thread [num]</td>\n<td>切換至 第num個 thread</td>\n</tr>\n<tr>\n<td>thread apply all [command]</td>\n<td>對所有 thread 執行指令</td>\n</tr>\n</tbody></table>\n<h3 id=\"Python-整合\"><a href=\"#Python-整合\" class=\"headerlink\" title=\"Python 整合\"></a>Python 整合</h3><p>可於gdb中執行python，並執行操作，如存取breakpoint</p>\n<ul>\n<li><code>python print(gdb.breakpoints())</code></li>\n<li><code>python gdb.execute()</code></li>\n<li><code>python gdb.parse_and_eval()</code></li>\n</ul>\n<h3 id=\"反向執行\"><a href=\"#反向執行\" class=\"headerlink\" title=\"反向執行\"></a>反向執行</h3><p><span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ2hlcnlsTmF0c3UvYXJ0aWNsZS9kZXRhaWxzLzY0MzY1NzA=\">GDB 反向調試（Reverse Debugging）<i class=\"fa fa-external-link-alt\"></i></span></p>\n<ul>\n<li><code>reverse-continue</code> 反向執行程式</li>\n<li><code>reverse-step</code></li>\n<li><code>reverse-stepi</code> 反向執行程式到上一條機器指令</li>\n<li><code>reverse-next</code> 反向執行到上一次被執行的源代碼行，但是不進入函式</li>\n<li><code>reverse-nexti</code> 反向執行到上一條機器指令，除非這條指令用來返回一個函式調用、整個函式將會被反向執行</li>\n<li><code>reverse-finish</code> 反向執行程式回到調用目前函式的地方</li>\n<li><code>set exec-direction [forward | reverse]</code> 設置程序執行方向，即可用一般的step和continue來反向執行</li>\n</ul>\n<h2 id=\"指令簡寫\"><a href=\"#指令簡寫\" class=\"headerlink\" title=\"指令簡寫\"></a>指令簡寫</h2><ul>\n<li><code>break</code>: b</li>\n<li><code>delete</code>: d</li>\n<li><code>disable</code>: dis</li>\n<li><code>next</code>: n</li>\n<li><code>step</code>: s</li>\n<li><code>until</code>: u</li>\n<li><code>continue</code>: c</li>\n<li><code>jump</code>: j</li>\n<li><code>return</code>: ret</li>\n<li><code>list</code>: l</li>\n<li><code>backtrace</code>: bt</li>\n<li><code>info</code>: i</li>\n<li><code>print</code>: p</li>\n<li><code>display</code>: disp</li>\n<li><code>environment</code>: env</li>\n</ul>\n<p>可多次使用簡寫</p>\n<ul>\n<li><code>info break</code> = <code>i b</code></li>\n</ul>\n<h2 id=\"CppCon-2015-Greg-Law-“Give-me-15-minutes-amp-I’ll-change-your-view-of-GDB”\"><a href=\"#CppCon-2015-Greg-Law-“Give-me-15-minutes-amp-I’ll-change-your-view-of-GDB”\" class=\"headerlink\" title=\"CppCon 2015: Greg Law “Give me 15 minutes &amp; I’ll change your view of GDB”\"></a>CppCon 2015: Greg Law “Give me 15 minutes &amp; I’ll change your view of GDB”</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1Qb3JmTFNyM0RESQ==\">Youtube連結<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0NwcENvbi9DcHBDb24yMDE1L2Jsb2IvbWFzdGVyL0xpZ2h0bmluZyUyMFRhbGtzJTIwYW5kJTIwTHVuY2glMjBTZXNzaW9ucy9HaXZlJTIwTWUlMjAxNSUyME1pbnV0ZXMlMjBhbmQlMjBJJyB0YXJnZXQ9\">Github連結<i class=\"fa fa-external-link-alt\"></i></span></p>\n<ul>\n<li><code>Ctrl-x a</code>： text ui mode(tui)<ul>\n<li><code>Ctrl-p</code>： 得到前一個指令</li>\n</ul>\n</li>\n<li><code>Ctrl-x 2</code>： switch to assembly mode/register group mode </li>\n<li><code>tui reg float</code>： show float registers</li>\n<li><code>b _exit.c:32</code>： 在程式結束之前停止</li>\n<li><code>command [breakpoint number] [command]</code>： 遇到breakpoint時，所自動執行的指令 </li>\n<li><code>x [memory address]</code>： jump to memory location</li>\n</ul>\n<h2 id=\"使用感想\"><a href=\"#使用感想\" class=\"headerlink\" title=\"使用感想\"></a>使用感想</h2><ul>\n<li>遇到segmentation fault的時候，一定會使用<ul>\n<li>可知道出問題的位置</li>\n<li>通常再print看看就知道原因了</li>\n</ul>\n</li>\n<li>平常還是用<code>printf</code><ul>\n<li>殺雞焉用牛刀？</li>\n</ul>\n</li>\n<li>如果程式有完整的錯誤處理和記錄檔(log)，可減少用到gdb的頻率</li>\n</ul>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3VzZXIuZnJkbS5pbmZvL2NraHVuZy9iL2MvZ2RiLnBocA==\">除錯程式:gdb<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3RldHJhbGV0Lmx1bmEuY29tLnR3Lz9vcD1WaWV3QXJ0aWNsZSZhcnRpY2xlSWQ9MTg3JmJsb2dJZD0x\">Linux 除錯利器-GDB簡介<i class=\"fa fa-external-link-alt\"></i></span>  </li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cueXNsaW4udHcvMjAxMi8wOC9nZGIuaHRtbA==\">工欲善其事，必先利其器:GDB基本教學<i class=\"fa fa-external-link-alt\"></i></span>  </li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zdHVkeS1hcmVhLm9yZy9jeXJpbC9vcGVudG9vbHMvb3BlbnRvb2xzL2RlYnVnLmh0bWw=\">用Open Source工具開發軟體: 新軟體開發關念<i class=\"fa fa-external-link-alt\"></i></span>  </li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2dkYi9kb2N1bWVudGF0aW9uLw==\">GDB官方文件<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n",
            "tags": [
                "gdb",
                "c語言",
                "cpp",
                "除錯"
            ]
        }
    ]
}