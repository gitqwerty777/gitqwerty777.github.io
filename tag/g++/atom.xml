<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://gitqwerty777.github.io</id>
    <title>QWERTY • Posts by &#34;g++&#34; tag</title>
    <link href="http://gitqwerty777.github.io" />
    <updated>2017-05-23T12:44:30.000Z</updated>
    <category term="C#" />
    <category term="CodingStyle" />
    <category term="Emacs" />
    <category term="編輯器" />
    <category term="CFR" />
    <category term="電腦對局理論" />
    <category term="指令" />
    <category term="機器學習" />
    <category term="perceptron" />
    <category term="readme" />
    <category term="文件" />
    <category term="github" />
    <category term="artificial intelligence" />
    <category term="search" />
    <category term="First-Order Logic" />
    <category term="大數" />
    <category term="程式" />
    <category term="C++" />
    <category term="Hexo" />
    <category term="網誌" />
    <category term="Markdown" />
    <category term="CleanCode" />
    <category term="重構" />
    <category term="TDD" />
    <category term="設計模式" />
    <category term="CMake" />
    <category term="Makefile" />
    <category term="Linux" />
    <category term="Todo" />
    <category term="註解" />
    <category term="經濟學" />
    <category term="策略" />
    <category term="競爭" />
    <category term="博弈論" />
    <category term="計算機結構" />
    <category term="人工智慧" />
    <category term="圍棋" />
    <category term="象棋" />
    <category term="蒙地卡羅" />
    <category term="Alpha-Beta搜尋" />
    <category term="強化學習" />
    <category term="計算機網路" />
    <category term="boost" />
    <category term="函式庫" />
    <category term="編譯" />
    <category term="gcc" />
    <category term="g++" />
    <category term="clang" />
    <category term="最佳化" />
    <category term="推薦系統" />
    <category term="FM" />
    <category term="FFM" />
    <category term="SVM" />
    <category term="Embedding" />
    <category term="自然語言處理" />
    <category term="外國用語" />
    <category term="萌典" />
    <category term="opencc" />
    <category term="PTT" />
    <category term="vuejs" />
    <category term="linux" />
    <category term="c" />
    <category term="compile" />
    <category term="gdb" />
    <category term="c語言" />
    <category term="cpp" />
    <category term="除錯" />
    <category term="git" />
    <category term="VMWare" />
    <category term="虛擬機" />
    <category term="IFTTT" />
    <category term="自動化" />
    <category term="備份" />
    <category term="webhook" />
    <category term="簡報" />
    <category term="軟體" />
    <category term="PowerPoint" />
    <category term="Latex" />
    <category term="JavaScript" />
    <category term="CSS" />
    <category term="Unity" />
    <category term="fcitx" />
    <category term="嘸蝦米" />
    <category term="輸入法" />
    <category term="硬碟" />
    <category term="記憶體" />
    <category term="效能" />
    <category term="錯誤" />
    <category term="makefile" />
    <category term="備忘錄" />
    <category term="存檔" />
    <category term="統計" />
    <category term="byobu" />
    <category term="screen" />
    <category term="tmux" />
    <category term="reactjs" />
    <category term="javascript" />
    <category term="WideAndDeep" />
    <category term="Google" />
    <category term="觀察者" />
    <category term="訂閱" />
    <category term="委託" />
    <category term="正規表示式(RegExp)" />
    <category term="上下文無關文法(CFG)" />
    <category term="hexo" />
    <category term="blog" />
    <category term="theme" />
    <category term="feature" />
    <category term="revealJS" />
    <category term="markdown" />
    <category term="rss" />
    <category term="facebook" />
    <category term="youtube" />
    <category term="ptt" />
    <category term="bilibili" />
    <category term="pixiv" />
    <category term="crawler" />
    <category term="SEO" />
    <category term="google" />
    <category term="html" />
    <category term="amazon" />
    <category term="webhost" />
    <category term="ssl" />
    <category term="漢字" />
    <category term="中文" />
    <category term="異體字" />
    <category term="unicode" />
    <category term="unity" />
    <category term="演算法" />
    <category term="隨機排序" />
    <category term="洗牌" />
    <category term="Fisher-Yates" />
    <category term="證明" />
    <category term="python" />
    <entry>
        <id>http://gitqwerty777.github.io/cpp-compile-speed/</id>
        <title>加快C++編譯速度的方法</title>
        <link rel="alternate" href="http://gitqwerty777.github.io/cpp-compile-speed/"/>
        <content type="html">&lt;h2 id=&#34;編譯速度慢的原因&#34;&gt;&lt;a href=&#34;#編譯速度慢的原因&#34; class=&#34;headerlink&#34; title=&#34;編譯速度慢的原因&#34;&gt;&lt;/a&gt;編譯速度慢的原因&lt;/h2&gt;&lt;p&gt;因為C++ &lt;code&gt;.h&lt;/code&gt; + &lt;code&gt;.cpp&lt;/code&gt; 的編譯模型&lt;br&gt;每個cpp檔可能會包含上百甚至上千個&lt;code&gt;.h&lt;/code&gt;檔，這些&lt;code&gt;.h&lt;/code&gt;檔都會被讀進來一遍，然後被解析一遍。&lt;br&gt;每個編譯單元都會產生一個&lt;code&gt;.obj&lt;/code&gt;文件，然後所以這些&lt;code&gt;.obj&lt;/code&gt;文件會被link到一起，並且這個過程很難平行。重複load與解析，以及密集的IO，使編譯速度很慢。&lt;/p&gt;
&lt;a id=&#34;more&#34;&gt;&lt;/a&gt;

&lt;h2 id=&#34;代碼角度&#34;&gt;&lt;a href=&#34;#代碼角度&#34; class=&#34;headerlink&#34; title=&#34;代碼角度&#34;&gt;&lt;/a&gt;代碼角度&lt;/h2&gt;&lt;h3 id=&#34;前置聲明&#34;&gt;&lt;a href=&#34;#前置聲明&#34; class=&#34;headerlink&#34; title=&#34;前置聲明&#34;&gt;&lt;/a&gt;前置聲明&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;.h&lt;/code&gt;檔中使用前置聲明(forward declaration)，而不是直接包含&lt;code&gt;.h&lt;/code&gt;檔。&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;A&lt;/span&gt;;&lt;/span&gt; &lt;span class=&#34;comment&#34;&gt;//forward declaration, instead #include &#34;a.h&#34;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;B&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    A* a;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;useA&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(A&amp;amp; a)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;meta-keyword&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;meta-string&#34;&gt;&#34;a.h&#34;&lt;/span&gt; &lt;span class=&#34;comment&#34;&gt;//cannot use forward declaration because compiler needs to know what A really is&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;B&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    A a;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;要盡一切可能使&lt;code&gt;.h&lt;/code&gt;檔精簡&lt;/strong&gt;。&lt;br&gt;很多時候前置聲明某個namespace中的class會比較痛苦，而直接include會方便很多，千萬要抵制住這種誘惑；class的成員，函數參數等也儘量用reference或pointer。&lt;/p&gt;
&lt;h3 id=&#34;使用Pimpl模式&#34;&gt;&lt;a href=&#34;#使用Pimpl模式&#34; class=&#34;headerlink&#34; title=&#34;使用Pimpl模式&#34;&gt;&lt;/a&gt;使用Pimpl模式&lt;/h3&gt;&lt;p&gt;Pimpl為Private Implementation&lt;br&gt;傳統的C++的class的接口與實現是混淆在一起的，而Pimpl這種做法使得class的接口與實現得以完全分離。&lt;br&gt;如此，只要class的公共接口保持不變，對class實現的修改始終只需編譯該cpp；同時，該class提供給外界的.h檔也會精簡許多。&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;class&#34;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    A();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    ~A();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;doSomething&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;Impl&lt;/span&gt;;&lt;/span&gt;&lt;span class=&#34;comment&#34;&gt;//real implementation in this class&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;built_in&#34;&gt;std&lt;/span&gt;::&lt;span class=&#34;built_in&#34;&gt;auto_ptr&lt;/span&gt;&amp;lt;impl&amp;gt; m_impl;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;高度模塊化&#34;&gt;&lt;a href=&#34;#高度模塊化&#34; class=&#34;headerlink&#34; title=&#34;高度模塊化&#34;&gt;&lt;/a&gt;高度模塊化&lt;/h3&gt;&lt;p&gt;模塊化就是低耦合，就是儘可能的減少相互依賴。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件與文件之間，一個&lt;code&gt;.h&lt;/code&gt;檔的變化，儘量不要引起其他文件的重新編譯。&lt;/li&gt;
&lt;li&gt;工程與工程之間，對一個工程的修改，儘量不要引起太多其他工程的編譯。這就要求&lt;code&gt;.h&lt;/code&gt;檔，或者工程的內容一定要單一，不要什麼東西都往裡面塞，從而引起不必要的依賴。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不要把兩個不相關的class，或者沒什麼聯繫的macro定義放到一個&lt;code&gt;.h&lt;/code&gt;檔裡；內容要儘量單一。&lt;/p&gt;
&lt;p&gt;把代碼中最常用到的那些&lt;code&gt;.h&lt;/code&gt;檔找出來，然後分成多個獨立的小文件，效果相當可觀。&lt;/p&gt;
&lt;h3 id=&#34;刪除冗餘的header檔&#34;&gt;&lt;a href=&#34;#刪除冗餘的header檔&#34; class=&#34;headerlink&#34; title=&#34;刪除冗餘的header檔&#34;&gt;&lt;/a&gt;刪除冗餘的header檔&lt;/h3&gt;&lt;p&gt;一些代碼經過上十年的開發與維護，經手的人無數，很有可能出現包含了沒用的&lt;code&gt;.h&lt;/code&gt;檔，或重複包含的現象，去掉這些冗餘的include是相當必要的。&lt;br&gt;當然，這主要是針對&lt;code&gt;.cpp&lt;/code&gt;的，因為對於一個&lt;code&gt;.h&lt;/code&gt;檔，其中的某個include是否冗餘很難界定，得看是否在最終的編譯單元中用到了，而這樣又可能出現在一個編譯單元用到了，而在另外一個編譯單元中沒用到的情況。&lt;/p&gt;
&lt;h3 id=&#34;特別注意inline和template&#34;&gt;&lt;a href=&#34;#特別注意inline和template&#34; class=&#34;headerlink&#34; title=&#34;特別注意inline和template&#34;&gt;&lt;/a&gt;特別注意inline和template&lt;/h3&gt;&lt;p&gt;它們強制在&lt;code&gt;.h&lt;/code&gt;檔中包含實作，這會增加&lt;code&gt;.h&lt;/code&gt;檔的內容，從而減慢許多編譯速度，需權衡使用。&lt;/p&gt;
&lt;h3 id=&#34;預編譯-h檔&#34;&gt;&lt;a href=&#34;#預編譯-h檔&#34; class=&#34;headerlink&#34; title=&#34;預編譯.h檔&#34;&gt;&lt;/a&gt;預編譯&lt;code&gt;.h&lt;/code&gt;檔&lt;/h3&gt;&lt;p&gt;把一些常用但不常改動的&lt;code&gt;.h&lt;/code&gt;檔放在預編譯&lt;code&gt;.h&lt;/code&gt;檔中。這樣，至少在單個工程中你不需要在每個編譯單元裡一遍又一遍的load與解析同一個&lt;code&gt;.h&lt;/code&gt;檔了。&lt;/p&gt;
&lt;p&gt;首次編譯source.cpp時，編譯器生成header.pch的預編譯header。以後再編譯該程式時，編譯器會比較該表頭檔的時間戳，如果表頭檔沒有改變，編譯器直接使用預編譯header。&lt;/p&gt;
&lt;figure class=&#34;highlight makefile&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;CORE_PCH_FILENAME=Core.h&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;CORE_PCH=&lt;span class=&#34;variable&#34;&gt;$(CORE_PCH_FILENAME)&lt;/span&gt;.gch&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;variable&#34;&gt;$(CORE_PCH)&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;variable&#34;&gt;$(CXX)&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;$(CXX_CFLAGS)&lt;/span&gt; -x c++-header &lt;span class=&#34;variable&#34;&gt;$(CORE_PCH_FILENAME)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&#34;Guard-Conditions&#34;&gt;&lt;a href=&#34;#Guard-Conditions&#34; class=&#34;headerlink&#34; title=&#34;Guard Conditions&#34;&gt;&lt;/a&gt;Guard Conditions&lt;/h3&gt;&lt;p&gt;保證每個 header file 在每個編譯單元只被 include 一次&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;meta-keyword&#34;&gt;pragma&lt;/span&gt; once&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;meta-keyword&#34;&gt;ifndef&lt;/span&gt; filename_h&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;meta-keyword&#34;&gt;define&lt;/span&gt; filename_h&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;meta&#34;&gt;#&lt;span class=&#34;meta-keyword&#34;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同時使用兩種方法以確保compiler的相容性&lt;/p&gt;
&lt;h2 id=&#34;Unity-Build&#34;&gt;&lt;a href=&#34;#Unity-Build&#34; class=&#34;headerlink&#34; title=&#34;Unity Build&#34;&gt;&lt;/a&gt;Unity Build&lt;/h2&gt;&lt;p&gt;把所有的檔案包含到一個cpp中(如&lt;code&gt;all.cpp&lt;/code&gt;)，然後只編譯all.cpp。這樣就只有一個編譯單元，這意味著不需要重複load與解析同一個&lt;code&gt;.h&lt;/code&gt;檔了，同時因為只產生一個obj文件，在link的時候也不需要那麼密集的IO&lt;/p&gt;
&lt;h2 id=&#34;Compiler-Cache&#34;&gt;&lt;a href=&#34;#Compiler-Cache&#34; class=&#34;headerlink&#34; title=&#34;Compiler Cache&#34;&gt;&lt;/a&gt;Compiler Cache&lt;/h2&gt;&lt;p&gt;藉由快取上一次編譯的結果，使rebuild在保持結果相同的情況下，極大的提高速度。&lt;/p&gt;
&lt;h2 id=&#34;不要有太多的Include-Directories&#34;&gt;&lt;a href=&#34;#不要有太多的Include-Directories&#34; class=&#34;headerlink&#34; title=&#34;不要有太多的Include Directories&#34;&gt;&lt;/a&gt;不要有太多的Include Directories&lt;/h2&gt;&lt;p&gt;編譯器定位你include的&lt;code&gt;.h&lt;/code&gt;檔，是根據你提供的include directories進行搜索的。&lt;/p&gt;
&lt;p&gt;用 &lt;code&gt;cpp -v&lt;/code&gt; 查看 &lt;code&gt;#include &amp;quot;...&amp;quot; search starts here:&lt;/code&gt; 中的目錄&lt;br&gt;和 GNU Make 的 &lt;code&gt;-I&lt;/code&gt; 選項&lt;/p&gt;
&lt;h2 id=&#34;平行化及分佈式編譯&#34;&gt;&lt;a href=&#34;#平行化及分佈式編譯&#34; class=&#34;headerlink&#34; title=&#34;平行化及分佈式編譯&#34;&gt;&lt;/a&gt;平行化及分佈式編譯&lt;/h2&gt;&lt;p&gt;GNU Make 的 &lt;code&gt;-j [N]&lt;/code&gt; 可以用N個核心編譯&lt;br&gt;Visual Studio 有 &lt;code&gt;/MP&lt;/code&gt; 選項可做到檔案等級的平行&lt;br&gt;或是用空閒的機器來編譯&lt;/p&gt;
&lt;h2 id=&#34;買更好的磁碟&#34;&gt;&lt;a href=&#34;#買更好的磁碟&#34; class=&#34;headerlink&#34; title=&#34;買更好的磁碟&#34;&gt;&lt;/a&gt;買更好的磁碟&lt;/h2&gt;&lt;p&gt;編譯速度慢很大一部分原因是磁碟操作，那麼除了儘可能的減少磁碟操作，我們還可以做的就是加快磁碟速度。&lt;/p&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;&lt;a href=&#34;#參考資料&#34; class=&#34;headerlink&#34; title=&#34;參考資料&#34;&gt;&lt;/a&gt;參考資料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzczMTQyL3doYXQtdGVjaG5pcXVlcy1jYW4tYmUtdXNlZC10by1zcGVlZC11cC1jLWNvbXBpbGF0aW9uLXRpbWVz&#34;&gt;What techniques can be used to speed up C++ compilation times?&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9iYWl5YW5odWFuZy9hcmNoaXZlLzIwMTAvMDEvMTcvMTczMDcxNy5odG1s&#34;&gt;如何加快C++代碼的編譯速度&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1xWU42ZWR1VTA2cw==&#34;&gt;(Unity Build) CppCon 2014: Nicolas Fleury “C++ in Huge AAA Games”&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2dhbWVkZXYvY29tbWVudHMvMms0bDJ6L2lzX3ViaXNvZnRzX3VuaXR5X2J1aWxkX2Zvcl9jX3dvcnRoLw==&#34;&gt;(Unity Build) Is Ubisoft’s unity build for C++ worth?&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2dvb2RzcGVlZGxlZS5ibG9nc3BvdC50dy8yMDE2LzAxL2MtcGltcGwuaHRtbA==&#34;&gt;(pimpl) C++: 善用 PIMPL 技巧&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2JhaXlhbmh1YW5nL2JhY2t1cC9ibG9iLzlmMTFkMDE0OWNiMzY1OWRhYzQ3OTY3ZjFiMTBmM2I3ZWVjODg4ZDMvdG9vbHMvUGVybC9SZW1vdmVSZWR1bmRhbnRJbmNsdWRlcy5wbA==&#34;&gt;(去除重複) Perl腳本，用來自動去除這些冗餘的.h檔&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2R1Y2tyb29tLmJsb2dzcG90LnR3LzIwMTAvMDIvcHJlY29tcGlsZWQtaGVhZGVyLmh0bWw=&#34;&gt;(預編譯.h檔) 終於搞懂了，預編譯header 檔(precompiled header)&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9Yb3JlYXglMjBJbmNyZWRpQnVpbGQ=&#34;&gt;(分佈式編譯) Xoreax IncrediBuild&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODkyMDY0MC9ob3ctZG8taS1rbm93LXRoZS1kZWZhdWx0LWluY2x1ZGUtZGlyZWN0b3JpZXMtZGVmYXVsdC1saW5rLWRpcmVjdG9yaWVzLWFuZA==&#34;&gt;How do I know the default include directories&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9jY2FjaGUuc2FtYmEub3JnLw==&#34;&gt;(Compiler Cache) ccache&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2l0c2NvbXBpbGluZy5ldS8yMDE3LzAxLzEyL3ByZWNvbXBpbGVkLWhlYWRlcnMtY3BwLWNvbXBpbGF0aW9uLw==&#34;&gt;(預編譯.h檔) Speed up C++ compilation, part 1: precompiled headers&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzczNjU3NzA=&#34;&gt;(預編譯.h檔) makefile 範例&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="C++" />
        <category term="編譯" />
        <category term="gcc" />
        <category term="g++" />
        <category term="clang" />
        <category term="最佳化" />
        <updated>2017-05-23T12:44:30.000Z</updated>
    </entry>
</feed>
