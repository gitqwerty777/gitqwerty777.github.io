{
    "version": "https://jsonfeed.org/version/1",
    "title": "QWERTY • All posts by \"makefile\" tag",
    "description": "Programming | Computer Science | Thought",
    "home_page_url": "http://gitqwerty777.github.io",
    "items": [
        {
            "id": "http://gitqwerty777.github.io/cmake/",
            "url": "http://gitqwerty777.github.io/cmake/",
            "title": "Makefile 和 CMake 之間的轉換和實作",
            "date_published": "2017-01-17T10:12:50.000Z",
            "content_html": "<!-- RENEW: -->\n\n<p><span class=\"exturl\" data-url=\"aHR0cDovL21xamluZy5ibG9nc3BvdC50dy8yMDA5LzA5L2NtYWtlLWhvdy10by11c2UtY21ha2UuaHRtbA==\">http://mqjing.blogspot.tw/2009/09/cmake-how-to-use-cmake.html<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pdGsub3JnL1dpa2kvQ01ha2VfVXNlZnVsX1ZhcmlhYmxlcw==\">CMake 常用變數<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"簡介\"><a href=\"#簡介\" class=\"headerlink\" title=\"簡介\"></a>簡介</h2><p>CMake用來產生跨平台的專案建置文件，在windows下它會生成visual studio的專案檔(.sln) codeblock eclipse，在linux下它會生成Makefile。類似工具有autotools和qmake，不過autotools太複雜，qmake只限於qt使用。</p>\n<p>CMake用更抽象的語法來組織項目。例如用math表示數學庫，而不需要再具體指定到底是math.dll還是libmath.so。</p>\n<a id=\"more\"></a>\n\n<p>類似功能的工具</p>\n<ul>\n<li><p><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zY29ucy5vcmc=\">SCons<i class=\"fa fa-external-link-alt\"></i></span></p>\n<ul>\n<li>by python</li>\n</ul>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cDovL2FudC5hcGFjaGUub3JnLw==\">Apache ant<i class=\"fa fa-external-link-alt\"></i></span></p>\n<ul>\n<li>by java</li>\n</ul>\n</li>\n<li><p>優點</p>\n<ul>\n<li>stable</li>\n<li>fast</li>\n<li>支援Code::Blocks, Xcode等</li>\n</ul>\n</li>\n<li><p>缺點</p>\n<ul>\n<li>需學習語法</li>\n</ul>\n</li>\n</ul>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iaXRidWNrZXQub3JnL3Njb25zL3Njb25zL3dpa2kvU2NvbnNWc090aGVyQnVpbGRUb29scw==\">專案建置工具比較<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"GUI\"><a href=\"#GUI\" class=\"headerlink\" title=\"GUI\"></a>GUI</h3><ul>\n<li>command line: <code>cmake</code></li>\n<li>curse-based TUI: <code>ccmake</code></li>\n<li>QT-based GUI: <code>cmake-gui</code></li>\n</ul>\n<h3 id=\"Out-Of-Source-Build\"><a href=\"#Out-Of-Source-Build\" class=\"headerlink\" title=\"Out-Of-Source Build\"></a>Out-Of-Source Build</h3><p>將build資料和原始碼分離</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 修改 CMakeLists.txt</span></span><br><span class=\"line\">mkdir build # will generate build files in this folder</span><br><span class=\"line\">cd build</span><br><span class=\"line\">cmake .. # the place that put CMakelists.txt</span><br><span class=\"line\"></span><br><span class=\"line\">cmake -G \"Unix Makefiles\" [CMakeList.txt path] # 指定生成平台</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>執行結束後，build資料夾會出現各項中間檔、makefile 以及執行檔</li>\n</ul>\n<p>優點</p>\n<ol>\n<li>可保持working directory的乾淨</li>\n<li>只要用新的資料夾，就可以產生多個不同的build，也可以隨時刪除</li>\n</ol>\n<h2 id=\"語法\"><a href=\"#語法\" class=\"headerlink\" title=\"語法\"></a>語法</h2><ul>\n<li>設定變數 <code>set(var hello)</code></li>\n<li>印出訊息 <code>message(${var})</code></li>\n</ul>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">cmake_minimum_required</span> (VERSION <span class=\"number\">2.6</span>) <span class=\"comment\"># minimum executable version of cmake</span></span><br><span class=\"line\"><span class=\"keyword\">project</span>(ex1) <span class=\"comment\"># project name</span></span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(ex1 main.c) <span class=\"comment\"># build program ex1 from main.c</span></span><br></pre></td></tr></table></figure>\n\n<p>在不同的資料夾下建立執行檔</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> relative destination</span></span><br><span class=\"line\">cmake --help-variable CMAKE_INSTALL_PREFIX</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> At Install-time use DESTDIR mechanism (Unix Makefiles)</span></span><br><span class=\"line\">make DESTDIR=/tmp/testinstall install</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CMake語法\"><a href=\"#CMake語法\" class=\"headerlink\" title=\"CMake語法\"></a>CMake語法</h3><p>general purpose constructs: <code>set</code>, <code>unset</code>, <code>if</code>, <code>elseif</code>, <code>else</code>, <code>endif</code>, <code>foreach</code>, <code>while</code>, <code>break</code></p>\n<h3 id=\"CMake-變數\"><a href=\"#CMake-變數\" class=\"headerlink\" title=\"CMake 變數\"></a>CMake 變數</h3><p>變數不分大小寫，但我習慣性用大寫</p>\n<ul>\n<li><p>變數指定</p>\n<ul>\n<li>CMake 有許多預設變數，以改變基本的運作，用<code>cmake --help-variables-list</code>可以瀏覽</li>\n<li>在檔案內指定<ul>\n<li><code>set(CMAKE_INSTALL_PREFIX /home/eric/testinstall)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>平台相關變數</p>\n<ul>\n<li>作業系統<ul>\n<li><code>WIN32</code> True on windows systems, including win64.</li>\n<li><code>UNIX</code> True for UNIX and UNIX like operating systems.</li>\n<li><code>APPLE</code> True if running on Mac OSX.</li>\n<li><code>CYGWIN</code> True for cygwin.</li>\n</ul>\n</li>\n<li>編譯器<ul>\n<li><code>MSVC</code> True when using Microsoft Visual C</li>\n<li><code>GNU&lt;LANG&gt;</code> True if the compiler of this language is GNU</li>\n<li><code>MINGW</code> True if the compiler is MinGW</li>\n</ul>\n</li>\n<li>example<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">NOT</span> WIN32)</span><br><span class=\"line\"><span class=\"keyword\">option</span> (WITH GUESS NAME <span class=\"string\">\"Guess acronym name\"</span> <span class=\"keyword\">ON</span>)</span><br><span class=\"line\"><span class=\"keyword\">endif</span> (<span class=\"keyword\">NOT</span> WIN32)</span><br></pre></td></tr></table></figure></li>\n<li>找需要的package<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\">find package ( LibXml2 )</span><br><span class=\"line\"><span class=\"keyword\">if</span> (LIBXML2 FOUND)</span><br><span class=\"line\">add definitions (−DHAVE XML <span class=\"variable\">$&#123;LIBXML2 DEFINITIONS &#125;</span>)</span><br><span class=\"line\">includedirectories( <span class=\"variable\">$&#123;LIBXML2 INCLUDE DIR &#125;</span>)</span><br></pre></td></tr></table></figure></li>\n<li><code>XXXFOUND</code><pre><code>- Set to false, or undefined, if we haven’t found, or don’t want to use XXX</code></pre><ul>\n<li><code>XXX_INCLUDE_DIRS</code><ul>\n<li>The final set of include directories listed in one variable for use by client code</li>\n</ul>\n</li>\n<li><code>XXX_LIBRARIES</code><ul>\n<li>The libraries to link against to use XXX. These should include full paths</li>\n</ul>\n</li>\n<li><code>XXX_DEFINITIONS</code><ul>\n<li>Definitions to use when compiling code that uses XXX</li>\n</ul>\n</li>\n<li><code>XXX_EXECUTABLE</code><ul>\n<li>Where to find the XXX tool</li>\n</ul>\n</li>\n<li><code>XXX_LIBRARY_DIRS</code><ul>\n<li>Optionally, the final set of library directories listed in one variable for use by client code</li>\n</ul>\n</li>\n<li>to find an executable program<ul>\n<li><code>find_program</code></li>\n</ul>\n</li>\n<li>to find a library<ul>\n<li><code>find_library</code></li>\n</ul>\n</li>\n<li>to find any kind of file<ul>\n<li><code>find_file</code></li>\n</ul>\n</li>\n<li>to find a path where a file reside<ul>\n<li><code>find_path</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>file manipulation with file</p>\n<ul>\n<li><code>READ</code>, <code>WRITE</code>, <code>APPEND</code>, <code>RENAME</code>, <code>REMOVE</code>, <code>MAKE DIRECTORY</code></li>\n</ul>\n</li>\n<li><p>advanced files operations</p>\n<ul>\n<li><code>GLOB</code>, <code>GLOB RECURSE [file name in a path]</code>, <code>DOWNLOAD</code>, <code>UPLOAD</code></li>\n</ul>\n</li>\n<li><p>working with path</p>\n<ul>\n<li><code>file (TO CMAKE PATH /TO NATIVE PATH ...)</code>, get filename component</li>\n</ul>\n</li>\n<li><p>execute an external process (with stdout, stderr and return code retrieval): execute process</p>\n</li>\n<li><p>builtin list manipulation command</p>\n<ul>\n<li><code>LENGTH</code>, <code>GET</code>, <code>APPEND</code>, <code>FIND</code>, <code>APPEND</code>, <code>INSERT</code>, <code>REMOVE ITEM</code>, <code>REMOVE AT</code>, <code>REMOVE DUPLICATES REVERSE</code>, <code>SORT</code></li>\n</ul>\n</li>\n<li><p>string manipulation</p>\n<ul>\n<li>upper/lower case conversion, length, comparison, substring, regular expression match</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CMake-Application\"><a href=\"#CMake-Application\" class=\"headerlink\" title=\"CMake Application\"></a>CMake Application</h3><ul>\n<li><p>CPack</p>\n<ul>\n<li>CMake friend application</li>\n<li>used to easily package your software</li>\n<li>Package the resulting binaries with CPack</li>\n</ul>\n</li>\n<li><p>CTest</p>\n<ul>\n<li>make test</li>\n<li>runs systematic test with CTest and publish them with CDash</li>\n</ul>\n</li>\n<li><p>Wizard mode</p>\n<ul>\n<li>cmake -i, interactive equivalent of the Normal mode</li>\n</ul>\n</li>\n<li><p>Command mode</p>\n<ul>\n<li>cmake -E <command>, command line mode which offers basic command in a portable way</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"專案說明\"><a href=\"#專案說明\" class=\"headerlink\" title=\"專案說明\"></a>專案說明</h2><p>一個簡單的圍棋程式</p>\n<p>file tree</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── <span class=\"selector-tag\">CMakeLists</span><span class=\"selector-class\">.txt</span></span><br><span class=\"line\">├── *<span class=\"selector-class\">.h</span></span><br><span class=\"line\">├── *<span class=\"selector-class\">.cpp</span></span><br><span class=\"line\">├── <span class=\"selector-tag\">previous_version</span></span><br><span class=\"line\">│   ├── <span class=\"selector-tag\">CMakeLists</span><span class=\"selector-class\">.txt</span></span><br><span class=\"line\">│   ├── *<span class=\"selector-class\">.cpp</span></span><br><span class=\"line\">│   └── *<span class=\"selector-class\">.h</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\">P?=binary</span><br><span class=\"line\">EXEC=execs/<span class=\"variable\">$(P)</span></span><br><span class=\"line\">OBJECTS=<span class=\"variable\">$(P)</span>.o *.o</span><br><span class=\"line\">CXXFLAGS=-pipe -std=c++11 -Wall -Wextra -Wpedantic -Wno-unknown-pragmas -g -O3 -march=native -fopenmp</span><br><span class=\"line\">LDFLAGS=-lpthread</span><br><span class=\"line\">CXX=g++</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">all: main</span></span><br><span class=\"line\"><span class=\"section\">parallel: main</span></span><br><span class=\"line\"><span class=\"section\">parallel: CXXFLAGS+=-fopenmp -DPARALLEL # add additional flags</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">previous:</span></span><br><span class=\"line\">    cd previous_version; make</span><br><span class=\"line\"><span class=\"section\">binary: <span class=\"variable\">$(OBJECTS)</span></span></span><br><span class=\"line\">\tg++ <span class=\"variable\">$(CXXFLAGS)</span> <span class=\"variable\">$(OBJECTS)</span> -flto -o <span class=\"variable\">$(EXEC)</span> <span class=\"variable\">$(LDFLAGS)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$(P)</span>.o: *.h</span><br><span class=\"line\">\t<span class=\"variable\">$(CXX)</span> <span class=\"variable\">$(CXXFLAGS)</span> main.cpp -c -o <span class=\"variable\">$(P)</span>.o <span class=\"variable\">$(LDFLAGS)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># object files and it's dependency</span></span><br><span class=\"line\"><span class=\"section\">board.o: mc_node.h liberty.h board.h board_constants.h ladder.h database.h strategy.h gameSetting.h</span></span><br><span class=\"line\"><span class=\"comment\"># ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">\trm -rf *.o</span><br><span class=\"line\"><span class=\"section\">previous_clean:</span></span><br><span class=\"line\">\tcd previous_version; make clean</span><br></pre></td></tr></table></figure>\n\n<p>CMakeLists.txt in root directly</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">cmake_minimum_required</span>(VERSION <span class=\"number\">2.6</span>)</span><br><span class=\"line\"><span class=\"keyword\">project</span>(MCTS_Go9x9)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># set default output file name</span></span><br><span class=\"line\"><span class=\"keyword\">SET</span>(BINARYNAME <span class=\"string\">\"binary\"</span> CACHE <span class=\"keyword\">STRING</span> <span class=\"string\">\"default binary file's name = binary\"</span> FORCE)</span><br><span class=\"line\"><span class=\"comment\"># set output directory</span></span><br><span class=\"line\"><span class=\"keyword\">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class=\"variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/execs</span><br><span class=\"line\"><span class=\"comment\"># compile parameters</span></span><br><span class=\"line\"><span class=\"keyword\">set</span>(CMAKE_CXX_COMPILER g++)</span><br><span class=\"line\"><span class=\"keyword\">message</span>(<span class=\"string\">\"compiler: $&#123;CMAKE_CXX_COMPILER&#125;\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">set</span>(CMAKE_CXX_FLAGS <span class=\"string\">\"-pipe -std=c++11 -Wall -Wextra -Wpedantic -Wno-unknown-pragmas -g -O3 -march=native -fopenmp\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">message</span>(<span class=\"string\">\"cxxflags: $&#123;CMAKE_CXX_FLAGS&#125;\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">set</span>(CMAKE_EXE_LINKER_FLAGS <span class=\"string\">\"-flto\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span>(THREADS_PREFER_PTHREAD_FLAG <span class=\"keyword\">ON</span>) <span class=\"comment\"># pthread</span></span><br><span class=\"line\"><span class=\"keyword\">find_package</span>(Threads REQUIRED) <span class=\"comment\"># pthread</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span>(SRC_FILES *.cpp)</span><br><span class=\"line\"><span class=\"keyword\">message</span>(<span class=\"string\">\"source files: $&#123;SRC_FILES&#125;\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># each executable is a target in GNU makefile</span></span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(<span class=\"variable\">$&#123;BINARYNAME&#125;</span> <span class=\"variable\">$&#123;SRC_FILES&#125;</span>)</span><br><span class=\"line\"><span class=\"keyword\">target_link_libraries</span>(<span class=\"variable\">$&#123;BINARYNAME&#125;</span> Threads::Threads) <span class=\"comment\"># pthread</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># parallel</span></span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(parallel <span class=\"variable\">$&#123;SRC_FILES&#125;</span>)</span><br><span class=\"line\"><span class=\"keyword\">target_compile_options</span>(parallel PUBLIC -fopenmp -DPARALLEL) <span class=\"comment\"># add additional compile parameters</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># we have another CMakeLists.txt in this directory, still follow the same method to generate</span></span><br><span class=\"line\"><span class=\"keyword\">add_subdirectory</span>(previous_version)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Makefile-和-CMake-的語法比較\"><a href=\"#Makefile-和-CMake-的語法比較\" class=\"headerlink\" title=\"Makefile 和 CMake 的語法比較\"></a>Makefile 和 CMake 的語法比較</h2><table>\n<thead>\n<tr>\n<th>makefile</th>\n<th>cmake</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>COMPILE_FLAGS = -c -m32 -O3 -fPIC -w -DSOMETHING -Wall -I src/sdk/core</code></td>\n<td><code>SET( COMPILE_FLAGS &quot;-c -m32 -O3 -fPIC -w DSOMETHING -Wall&quot; ) INCLUDE_DIRECTORIES( src/sdk/core )</code></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Makefile</span></span><br><span class=\"line\"><span class=\"keyword\">ifdef</span> STATIC</span><br><span class=\"line\">  <span class=\"comment\"># Do something</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  <span class=\"comment\"># Do something elseendif</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># CMake</span></span><br><span class=\"line\"><span class=\"keyword\">OPTION</span>(STATIC <span class=\"string\">\"Brief description\"</span> <span class=\"keyword\">ON</span>)</span><br><span class=\"line\"><span class=\"keyword\">IF</span>( STATIC )</span><br><span class=\"line\">  <span class=\"comment\"># Do something</span></span><br><span class=\"line\"><span class=\"keyword\">ELSE</span>()</span><br><span class=\"line\">  <span class=\"comment\"># Do something else</span></span><br><span class=\"line\"><span class=\"keyword\">ENDIF</span>()</span><br></pre></td></tr></table></figure>\n\n<p>using libraries<br>call find_package with the name of your library, which will invoke a library search script from your cmake module path. This script (which is also written in CMake) will attempt to detect the location of the library’s header and lib files and store them in a couple of CMake variables that can then be passed to the according CMake commands like include_directories and target_link_libraries.</p>\n<p>There are two problems with this approach: First, you need a search script. Fortunately, CMake ships with search scripts for Pthreads, Boost and a couple of others, but if you are using a more exotic library, you might have to write the search script yourself, which is kind of an arcane experience at first…</p>\n<p> 並不會刪除自身產出的快取和中間檔</p>\n<p>The following Makefile builds an executable named prog from the sources prog1.c, prog2.c, prog3.c and main.c. prog is linked against libmystatlib.a and libmydynlib.so which are both also built from source. Additionally, prog uses the library libstuff.a in stuff/lib and its header in stuff/include. The Makefile by default builds a release target, but offers also a debug target:</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#Makefile</span></span><br><span class=\"line\">CC = gcc</span><br><span class=\"line\">CPP = g++</span><br><span class=\"line\">RANLIB = ar rcs</span><br><span class=\"line\">RELEASE = -c -O3</span><br><span class=\"line\">DEBUG = -c -g -D_DEBUG</span><br><span class=\"line\">INCDIR = -I./stuff/<span class=\"keyword\">include</span></span><br><span class=\"line\">LIBDIR = -L./stuff/lib -L.</span><br><span class=\"line\">LIBS = -lstuff -lmystatlib -lmydynlib</span><br><span class=\"line\">CFLAGS = <span class=\"variable\">$(RELEASE)</span></span><br><span class=\"line\"></span><br><span class=\"line\">PROGOBJS = prog1.o prog2.o prog3.o</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">prog: main.o <span class=\"variable\">$(PROGOBJS)</span> mystatlib mydynlib</span></span><br><span class=\"line\">    <span class=\"variable\">$(CC)</span> main.o <span class=\"variable\">$(PROGOBJS)</span> <span class=\"variable\">$(LIBDIR)</span> <span class=\"variable\">$(LIBS)</span> -o prog</span><br><span class=\"line\"><span class=\"section\">debug: CFLAGS=<span class=\"variable\">$(DEBUG)</span></span></span><br><span class=\"line\"><span class=\"section\">debug: prog</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">mystatlib: mystatlib.o</span></span><br><span class=\"line\">    <span class=\"variable\">$(RANLIB)</span> libmystatlib.a mystatlib.o</span><br><span class=\"line\"><span class=\"section\">mydynlib: mydynlib.o</span></span><br><span class=\"line\">    <span class=\"variable\">$(CPP)</span> -shared mydynlib.o -o libmydynlib.so</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">%.o: %.c</span></span><br><span class=\"line\">    <span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> <span class=\"variable\">$(INCDIR)</span> <span class=\"variable\">$&lt;</span> -o <span class=\"variable\">$@</span></span><br><span class=\"line\"><span class=\"section\">%.o: %.cpp</span></span><br><span class=\"line\">    <span class=\"variable\">$(CPP)</span> <span class=\"variable\">$(CFLAGS)</span> <span class=\"variable\">$(INCDIR)</span> -fPIC  <span class=\"variable\">$&lt;</span> -o <span class=\"variable\">$@</span></span><br><span class=\"line\">Here is a CMakeLists.txtthat does (almost) exactly the same, with some comments to underline the similarities to the Makefile:</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#CMakeLists.txt</span></span><br><span class=\"line\"><span class=\"keyword\">cmake_minimum_required</span>(VERSION <span class=\"number\">2.8</span>)                    <span class=\"comment\"># stuff not directly</span></span><br><span class=\"line\"><span class=\"keyword\">project</span>(example)                                       <span class=\"comment\"># related to building</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">include_directories</span>(<span class=\"variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/stuff/<span class=\"keyword\">include</span>) <span class=\"comment\"># -I flags for compiler</span></span><br><span class=\"line\"><span class=\"keyword\">link_directories</span>(<span class=\"variable\">$&#123;CMAKE_SOURCE_DIR&#125;</span>/stuff/lib)        <span class=\"comment\"># -L flags for linker</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span>(PROGSRC prog1.c prog2.c prog3.c)                   <span class=\"comment\"># define variable</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(prog main.c <span class=\"variable\">$&#123;PROGSRC&#125;</span>)                 <span class=\"comment\"># define executable target prog, specify sources</span></span><br><span class=\"line\"><span class=\"keyword\">target_link_libraries</span>(prog mystatlib mydynlib stuff)   <span class=\"comment\"># -l flags for linking prog target</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">add_library</span>(mystatlib STATIC mystatlib.c)              <span class=\"comment\"># define static library target mystatlib, specify sources</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">add_library</span>(mydynlib SHARED mydynlib.cpp)              <span class=\"comment\"># define shared library target mydynlib, specify sources</span></span><br><span class=\"line\"><span class=\"comment\">#extra flags for linking mydynlib</span></span><br><span class=\"line\"><span class=\"keyword\">set_target_properties</span>(mydynlib PROPERTIES POSITION_INDEPENDENT_CODE <span class=\"keyword\">TRUE</span>)</span><br><span class=\"line\"><span class=\"comment\">#alternatively:</span></span><br><span class=\"line\"><span class=\"comment\">#set_target_properties(mydynlib PROPERTIES COMPILE_FLAGS \"-fPIC\")</span></span><br></pre></td></tr></table></figure>\n<p>In this simple example, the most important differences are:</p>\n<p>CMake recognizes which compilers to use for which kind of source. Also, it invokes the right sequence of commands for each type of target. Therefore, there is no explicit specification of commands like $(CC)…, $(RANLIB)… and so on.<br>All usual compiler/linker flags dealing with inclusion of header files, libraries, etc. are replaced by platform independent / build system independent commands.<br>Debugging flags are included by either setting the variable CMAKE_BUILD_TYPE to “Debug”, or by passing it to CMake when invoking the program: cmake -DCMAKE_BUILD_TYPE:STRING=Debug.<br>CMake offers also the platform independent inclusion of the ‘-fPIC’ flag (via the POSITION_INDEPENDENT_CODE property) and many others. Still, more obscure settings can be implemented by hand in CMake just as well as in a Makefile (by using COMPILE_FLAGS and similar properties). Of course CMake really starts to shine when third party libraries (like OpenGL) are included in a portable manner.<br>The build process has one step if you use a Makefile, namely typing<br>make at the command line. For CMake, there are two steps: First, you need to setup your build environment (either by typing cmake <source_dir> in your build directory or by running some GUI client). This creates a Makefile or something equivalent, depending on the build system of your choice (e.g. make on Unixes or VC++ or MinGW + Msys on Windows). The build system can be passed to CMake as a parameter; however, CMake makes reasonable default choices depending on your system configuration. Second, you perform the actual build in the selected build system.<br>Sources and build instructions are available at <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Job2VsemVsL21ha2VfY21ha2U=\">https://github.com/rhoelzel/make_cmake<i class=\"fa fa-external-link-alt\"></i></span>.</p>\n<h1 id=\"設定變數範例\"><a href=\"#設定變數範例\" class=\"headerlink\" title=\"設定變數範例\"></a>設定變數範例</h1><pre><code>set(MYLIBPATH &quot;C:\\\\Documents and\n        Settings\\\\Jing\\\\Desktop\\\\opencv_bin\\\\lib\\\\release\\\\&quot;)</code></pre><h1 id=\"使用變數範例\"><a href=\"#使用變數範例\" class=\"headerlink\" title=\"使用變數範例\"></a>使用變數範例</h1><pre><code>target_link_libraries(${name} ${MYLIBPATH}cv200.lib)</code></pre><h1 id=\"建立-macro-範例\"><a href=\"#建立-macro-範例\" class=\"headerlink\" title=\"建立 macro 範例\"></a>建立 macro 範例</h1><pre><code>MACRO(MY_DEFINE_EXAMPLE name srcs)\n      add_executable(${name} ${srcs})\nENDMACRO(MY_DEFINE_EXAMPLE)</code></pre><h1 id=\"使用-macro-範例\"><a href=\"#使用-macro-範例\" class=\"headerlink\" title=\"使用 macro 範例\"></a>使用 macro 範例</h1><pre><code>MY_DEFINE_EXAMPLE(demo     demo.cpp)</code></pre><h1 id=\"存取環境變數的範例\"><a href=\"#存取環境變數的範例\" class=\"headerlink\" title=\"存取環境變數的範例\"></a>存取環境變數的範例</h1><pre><code>MESSAGE(&quot;$ENV{PATH}&quot;)</code></pre><h1 id=\"加入-Post-Build-的範例\"><a href=\"#加入-Post-Build-的範例\" class=\"headerlink\" title=\"加入 Post Build 的範例\"></a>加入 Post Build 的範例</h1><pre><code>add_custom_command(\n        TARGET ${MyPluginTarget}\n        POST_BUILD\n        COMMAND copy\n                       ${CMAKE_CFG_INTDIR}\\\\${MyPluginTarget}.dll\n                       &quot;C:\\\\Program Files\\\\Mozilla Firefox\\\\\n                         plugins\\\\${MyPluginTarget}.dll&quot;\n    )</code></pre><p>若你的執行檔是 Windows 程式, 請加入 Win32<br><code>add_executable(demo WIN32 ${SOURCE})</code></p>\n<h2 id=\"MFC-設定\"><a href=\"#MFC-設定\" class=\"headerlink\" title=\"MFC 設定\"></a>MFC 設定</h2><figure class=\"highlight sqf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span>(CMAKE_MFC_FLAG <span class=\"number\">2</span>)</span><br><span class=\"line\">set_target_properties(MyApp      PROPERTIES</span><br><span class=\"line\">COMPILE_DEFINITIONS</span><br><span class=\"line\"><span class=\"variable\">_AFXDLL</span>, <span class=\"variable\">_UNICODE</span>, UNICODE,</span><br><span class=\"line\"><span class=\"variable\">_BIND_TO_CURRENT_CRT_VERSION</span>,</span><br><span class=\"line\"><span class=\"variable\">_BIND_TO_CURRENT_MFC_VERSION</span></span><br><span class=\"line\">LINK_FLAGS</span><br><span class=\"line\"><span class=\"string\">\" /ENTRY:\\\"</span>wWinMainCRTStartup\\<span class=\"string\">\"    \"</span>)</span><br></pre></td></tr></table></figure>\n\n<p>add_executable(demo WIN32 ${SOURCE})</p>\n<h1 id=\"設定-source-code-群組範例\"><a href=\"#設定-source-code-群組範例\" class=\"headerlink\" title=\"設定 source code 群組範例\"></a>設定 source code 群組範例</h1><figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ex1:</span></span><br><span class=\"line\"><span class=\"keyword\">file</span>(GLOB_RECURSE myRESOURCE_FILE 「*.def」 「*.rc」)</span><br><span class=\"line\"><span class=\"keyword\">source_group</span>(Resource FILES <span class=\"variable\">$&#123;myRESOURCE_FILE &#125;</span>)</span><br><span class=\"line\"><span class=\"comment\"># ex2:</span></span><br><span class=\"line\"><span class=\"keyword\">source_group</span>(abc_group REGULAR_EXPRESSION <span class=\"string\">\"abc.*\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">source_group</span>(<span class=\"number\">123</span>_group REGULAR_EXPRESSION <span class=\"string\">\"123.*\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">set</span>(SOURCE abc.cpp abc.h <span class=\"number\">123</span>.cpp <span class=\"number\">123</span>.h abc.rc main.cpp main.h</span><br><span class=\"line\">resource.h stdafx.cpp  stdafx.h</span><br><span class=\"line\">./res/<span class=\"number\">123</span>.ico ./res/<span class=\"number\">123</span>.rc2)</span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(demo WIN32 <span class=\"variable\">$&#123;SOURCE&#125;</span>)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"建立-dll-範例\"><a href=\"#建立-dll-範例\" class=\"headerlink\" title=\"建立 dll 範例\"></a>建立 dll 範例</h1><figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">add_library</span>( <span class=\"keyword\">target</span> SHARED a.c b.c);</span><br></pre></td></tr></table></figure>\n<p>#console 與 windows (/SUBSYSTEM:CONSOLE or /SUBSYSTEM:WINDOWS)<br>a. 如果你的程式是 Windows.<br>=&gt; 則 add_executable(demo WIN32 ${SOURCE})<br>b. 如果是 console, 則<br>=&gt; 則 add_executable(demo ${SOURCE})</p>\n<p>好用的變數 (more)<br><code>PROJECT_SOURCE_DIR</code>:  包含 project 命令的 CMakeFile.txt 完整路徑. (ex: c:\\abc)</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span>(PROJECT_HOME <span class=\"variable\">$&#123;PROJECT_SOURCE_DIR&#125;</span>\\\\..\\\\)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI3NDU1OTYzL2Fuc3dlci8zNjcyMjk5Mg==\">make makefile cmake qmake都是什麼，有什麼區別？-玟清的回答-知乎<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLnNpbXBseXBhdHJpY2suY29tL3Bvc3RzLzIwMTUvMDYtMTktY21ha2Utbm90ZXMv\">CMake筆記<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1RoZUVyay9DTWFrZS10dXRvcmlhbA==\">Eric Noulard - CMake tutorial<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpYm9va3Mub3JnL3dpa2kvQ01ha2VfJUU1JTg1JUE1JUU5JTk2JTgw\">CMake 入門 - 維基教科書，自由的教學讀本<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDg4MjAzMC9jbWFrZS12cy1tYWtlLXNhbXBsZS1jb2Rlcw==\">stackoverflow - Cmake vs make sample codes?<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDA4NTk0NS9jbWFrZS1jZmxhZ3MtY3h4ZmxhZ3MtbW9kaWZpY2F0aW9u\">stackoverflow - cmake CFLAGS CXXFLAGS modification<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY2NTA4MjUvY29udmVydGluZy1vbGQtbWFrZWZpbGUtdG8tY21ha2U=\">stackoverflow - Converting old makefile to CMake<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTk4NTgzOS9jcmVhdGluZy1jbWFrZWxpc3RzLWZpbGUtZnJvbS1leGlzdGluZy1tYWtlZmlsZQ==\">stackoverflow - Creating CMakeLists file from existing Makefile<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n",
            "tags": [
                "CMake",
                "Makefile",
                "Linux"
            ]
        },
        {
            "id": "http://gitqwerty777.github.io/makefile/",
            "url": "http://gitqwerty777.github.io/makefile/",
            "title": "建立Makefile",
            "date_published": "2015-02-22T15:31:44.000Z",
            "content_html": "<p>此篇文章十分清楚易懂，可作為初學之用</p>\n<a id=\"more\"></a>\n\n<h3 id=\"使用make好處\"><a href=\"#使用make好處\" class=\"headerlink\" title=\"使用make好處\"></a>使用make好處</h3><ul>\n<li>方便專案管理</li>\n<li>會透過檔案比對，依照相依性來編譯，不會全都編浪費時間</li>\n<li>可以同時編譯函式庫或是檔案</li>\n</ul>\n<h3 id=\"make常用指令\"><a href=\"#make常用指令\" class=\"headerlink\" title=\"make常用指令\"></a>make常用指令</h3><ul>\n<li><code>make -k</code>: 會讓make在遇到錯誤的時候仍然運行，而不會在第一個問題中斷</li>\n<li><code>make -n</code>: 只印出將會進行的工作，而不會真的執行</li>\n<li><code>make -f makefile_name</code>: make預設執行名為makefile的檔案，此命令可指定makefile檔案名稱和位置</li>\n<li><code>#</code>: 註解  </li>\n</ul>\n<h3 id=\"make指令格式\"><a href=\"#make指令格式\" class=\"headerlink\" title=\"make指令格式\"></a>make指令格式</h3><p>預設的target是”all”, 若makefile中沒有all, 則是第一個target</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">make [option] [target]</span><br><span class=\"line\">make -n all clean <span class=\"comment\"># 多個target</span></span><br><span class=\"line\">make -f makefile2 install</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"撰寫makefile檔案\"><a href=\"#撰寫makefile檔案\" class=\"headerlink\" title=\"撰寫makefile檔案\"></a>撰寫makefile檔案</h3><p>makefile是由一堆「目標」和其「相依性檔案」還有「法則」所組成的    </p>\n<ul>\n<li>[target] 目標 - 產生出來的東西    <ul>\n<li>用了 <code>.PHONY</code> 來指定 clean 為 fake 項目，所以 make 不會去檢查目錄中是否存在了一個名為 clean 的檔案。如此也可以提昇 make 的執行效率<ul>\n<li>常用的偽target<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">.PHONY: all clean install</span><br><span class=\"line\">all: ...</span><br><span class=\"line\">\t...</span><br><span class=\"line\">install: myapp app.doc   <span class=\"comment\">#安裝套件</span></span><br><span class=\"line\">     cp myapp app.doc /usr/<span class=\"built_in\">local</span>/myapp/</span><br><span class=\"line\">clean: <span class=\"comment\">#刪除產生出來的目的檔</span></span><br><span class=\"line\">\trm -rf *.o</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>[dependency] 相依性項目 - 若 dependency 的檔案有改動過，則重新產生 target</li>\n<li>[rule] 法則 - 如何產生目標<ul>\n<li>使用Tab作為開頭</li>\n<li>使用 Shell Script 語法</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[target]: [dependency] [dependency]</span></span><br><span class=\"line\">     [rule]</span><br><span class=\"line\">     [rule]</span><br><span class=\"line\"><span class=\"section\">[target]: [dependency]</span></span><br><span class=\"line\">     [rule]</span><br></pre></td></tr></table></figure>\n\n<p>註1: makefile的命令和shell不同的地方: 每行命令在<strong>分開的shell中獨立執行</strong></p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">wrongClean:</span></span><br><span class=\"line\">\tcd junkdir</span><br><span class=\"line\">\trm -f * <span class=\"comment\"># don't do that! </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">correctClean1:</span></span><br><span class=\"line\">\tcd junkdir &amp;&amp; rm -f *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">correctClean2:</span></span><br><span class=\"line\">\trm -f junkdir/*</span><br></pre></td></tr></table></figure>\n\n<p><del>如果寫錯的話，至少錯誤的makefile被刪除了</del></p>\n<p>註2: 在命令行首加上<code>@</code>，代表執行程式但不顯示在螢幕上。在命令行首加上<code>-</code>，代表執行命令時回傳非零值仍然繼續執行()</p>\n<p>例：要產生all的話，需要兩個檔案myapp和app.doc(主程式和說明檔)，make開始會去找尋如何產生myapp和 app.doc的方法，所以myapp會成為下一個要產生出來的目標。用gcc main.o a.o b.o -o myapp來產生myapp……，以此類推</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">all: myapp app.doc</span></span><br><span class=\"line\"><span class=\"section\">myapp: main.o a.o b.o</span></span><br><span class=\"line\">     gcc main.o a.o b.o -o myapp</span><br><span class=\"line\"><span class=\"section\">main.o: main.c a.h</span></span><br><span class=\"line\">     gcc -c main.c</span><br><span class=\"line\"><span class=\"section\">a.o: a.c a.h</span></span><br><span class=\"line\">     gcc -c a.c</span><br><span class=\"line\"><span class=\"section\">b.o: b.c b.h</span></span><br><span class=\"line\">     gcc -c b.c</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在makefile中, 相依性順序是很重要的</p>\n</blockquote>\n<h2 id=\"Makefile的變數和巨集-macro\"><a href=\"#Makefile的變數和巨集-macro\" class=\"headerlink\" title=\"Makefile的變數和巨集(macro)\"></a>Makefile的變數和巨集(macro)</h2><p>設定變數的方法  </p>\n<ul>\n<li>將export命令放在shell啟動script <code>.bashrc</code>或<code>.zshrc</code>…<ul>\n<li>永遠都有效</li>\n</ul>\n</li>\n<li>在shell中設定變數 <code>export CC=gcc</code><ul>\n<li>終端機開啟期間有效</li>\n</ul>\n</li>\n<li>在執行命令前設定 <code>CC=gcc | make</code><ul>\n<li>針對特定命令的變數</li>\n<li>設定變數需要在實際命令之前</li>\n</ul>\n</li>\n<li><code>make</code>可以直接設定變數<ul>\n<li><code>make CFLAGS=&quot;-g -Wall&quot;</code></li>\n<li><code>CFLAGS=&quot;-g -Wall&quot; make</code></li>\n</ul>\n</li>\n<li>在makefile中設定<ul>\n<li><code>?=</code>：若變數未定義，則替它指定新的值。否則，採用原有的值。  <ul>\n<li><code>FOO ?= bar</code>： 若 FOO 未定義，則 FOO = bar；若 FOO 已定義，則 FOO 的值維持不變。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>指定時，等號兩側不可有空格</p>\n<p>改變副檔名  </p>\n<ul>\n<li>SRC=a.c b.c</li>\n<li>OBJ=$(SRC:.c=.o) # equals to a.o b.o</li>\n</ul>\n<p>有幾個特別的內部巨集，讓makeifle更加簡明  </p>\n<ul>\n<li><code>$?</code> 代表需要重建的相依性項目(檔案有被更新過)，也就是 dependencies 中，比 targets 的修改日期還新檔案。</li>\n<li><code>$@</code> 目前的target</li>\n<li><code>$*</code> 不含副檔名的target</li>\n<li><code>$&lt;</code> 第一個 dependency</li>\n</ul>\n<p>還有兩個有用的特別字元，可以加在要執行的命令之前  </p>\n<ul>\n<li><code>-</code> 即使該行指令出錯，也不會中斷執行</li>\n<li><code>@</code> 不會在terminal顯示該行命令</li>\n</ul>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\">CC = gcc</span><br><span class=\"line\">CFLAGS = -Wall -ansi -g</span><br><span class=\"line\">OBJS = main.o a.o b.o</span><br><span class=\"line\">INSTALL_PATH = /usr/local/myapp/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">all: myapp app.doc</span></span><br><span class=\"line\"><span class=\"section\">myapp: <span class=\"variable\">$(OBJS)</span></span></span><br><span class=\"line\">     <span class=\"variable\">$(CC)</span> <span class=\"variable\">$(OBJS)</span> -o <span class=\"variable\">$@</span></span><br><span class=\"line\"><span class=\"section\">main.o: main.c a.h</span></span><br><span class=\"line\">     <span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -c -o <span class=\"variable\">$@</span> <span class=\"variable\">$&lt;</span></span><br><span class=\"line\"><span class=\"section\">a.o: a.c a.h</span></span><br><span class=\"line\">     <span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -c -o <span class=\"variable\">$@</span> <span class=\"variable\">$&lt;</span></span><br><span class=\"line\"><span class=\"section\">b.o: b.c b.h</span></span><br><span class=\"line\">     <span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -c -o <span class=\"variable\">$@</span> <span class=\"variable\">$&lt;</span></span><br><span class=\"line\"><span class=\"section\">install: myapp app.doc</span></span><br><span class=\"line\">     cp myapp app.doc <span class=\"variable\">$(INSTALL_PATH)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Makefile-隱性法則-implicit-rule\"><a href=\"#Makefile-隱性法則-implicit-rule\" class=\"headerlink\" title=\"Makefile 隱性法則(implicit rule)\"></a>Makefile 隱性法則(implicit rule)</h2><figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\">CC = gcc</span><br><span class=\"line\">CFLAGS = -Wall -ansi -g</span><br><span class=\"line\">OBJS = main.o a.o b.o</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">all: myapp app.doc</span></span><br><span class=\"line\"><span class=\"section\">myapp: <span class=\"variable\">$(OBJS)</span></span></span><br><span class=\"line\">     <span class=\"variable\">$(CC)</span> <span class=\"variable\">$(OBJS)</span> -o <span class=\"variable\">$@</span></span><br><span class=\"line\"><span class=\"section\">main.o: main.c a.h</span></span><br><span class=\"line\"><span class=\"section\">a.o: a.c a.h</span></span><br><span class=\"line\"><span class=\"section\">b.o: b.c b.h</span></span><br></pre></td></tr></table></figure>\n\n<p>makefile會在main.o自動產生規則 <code>gcc -Wall -ansi -g -c -o main.o main.c</code>  </p>\n<ul>\n<li>若dependency為c：<code>$(CC) $(CFLAGS) $(LDFLAGS) [dependencies]</code></li>\n<li>若dependency為c++：<code>$(CXX) $(CXXFLAGS) $(LDFLAGS) [dependencies]</code></li>\n<li>若dependency為object(建立執行檔)：<code>$(CC) $(LDFLAGS) [dependencies] $(LDLIBS)</code>  </li>\n</ul>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9tYWtlL21hbnVhbC9odG1sX25vZGUvQ2F0YWxvZ3VlLW9mLVJ1bGVzLmh0bWwjQ2F0YWxvZ3VlLW9mLVJ1bGVz\">隱性法則列表<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"Makefile-檔尾法則\"><a href=\"#Makefile-檔尾法則\" class=\"headerlink\" title=\"Makefile 檔尾法則\"></a>Makefile 檔尾法則</h2><p>使用檔尾的延伸檔名作為法則，格式 <code>.[old_suffix].[new_suffix]</code>  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">.c.o:</span></span><br><span class=\"line\">     <span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -c -o <span class=\"variable\">$@</span> <span class=\"variable\">$&lt;</span></span><br><span class=\"line\"><span class=\"section\">.cpp.o:</span></span><br><span class=\"line\">     g++ -c <span class=\"variable\">$&lt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">INCLUDE_PATH = <span class=\"keyword\">include</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">all: myapp.exe app.doc</span></span><br><span class=\"line\"><span class=\"section\">myapp.exe: <span class=\"variable\">$(OBJS)</span></span></span><br><span class=\"line\">     <span class=\"variable\">$(CC)</span> <span class=\"variable\">$(OBJS)</span> -o <span class=\"variable\">$@</span></span><br><span class=\"line\"><span class=\"section\">.c.o:</span></span><br><span class=\"line\">     <span class=\"variable\">$(CC)</span> -I<span class=\"variable\">$(INCLUDE_PATH)</span> <span class=\"variable\">$(CFLAGS)</span> -c -o <span class=\"variable\">$@</span> <span class=\"variable\">$&lt;</span></span><br></pre></td></tr></table></figure>\n\n<p>檔尾法則只可以用在本目錄</p>\n<p>這目錄下面所有的.c檔變成.o檔，而法則就是去編譯它，而如果你想更懶一點的話還可以完全不寫，直接使用內建的法則，這樣也可以直接把目錄下面的所有檔都編好，為什麼呢？因為你要編出myapp的時候需要使用到$(OBJS)所以，就算你不寫.c.o或是任何的法則，make預設都會自己產生.o檔讓你可以連結出主程式。  </p>\n<p>makefile也有支援萬用字元  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">%.o: %.c</span></span><br><span class=\"line\">     <span class=\"variable\">$(CC)</span> -I<span class=\"variable\">$(INCLUDE_PATH)</span> <span class=\"variable\">$(CFLAGS)</span> -c -o <span class=\"variable\">$@</span> <span class=\"variable\">$&lt;</span></span><br></pre></td></tr></table></figure>\n\n<p>萬用字元法則比較適合用於編譯一個大型的函式庫，而檔尾法則適合編譯一個目錄下面所有的檔案。</p>\n<h2 id=\"專案討論\"><a href=\"#專案討論\" class=\"headerlink\" title=\"專案討論\"></a>專案討論</h2><h3 id=\"Make-Makefile-with-Release-and-Debug-build\"><a href=\"#Make-Makefile-with-Release-and-Debug-build\" class=\"headerlink\" title=\"Make Makefile with Release and Debug build\"></a>Make Makefile with Release and Debug build</h3><p><span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83OTIyMTcvc2ltcGxlLW1ha2VmaWxlLXdpdGgtcmVsZWFzZS1hbmQtZGVidWctYnVpbGRzLWJlc3QtcHJhY3RpY2Vz\">simple-makefile-with-release-and-debug-builds-best-practices<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDc5ODMyL2hvdy1jYW4taS1jb25maWd1cmUtbXktbWFrZWZpbGUtZm9yLWRlYnVnLWFuZC1yZWxlYXNlLWJ1aWxkcw==\">how-can-i-configure-my-makefile-for-debug-and-release-builds<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2hzaWFuLXN0dWRpby5ibG9nc3BvdC50dy8yMDA4LzA5L21ha2VmaWxlXzA4Lmh0bWw=\">撰寫Makefile教學<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3RldHJhbGV0Lmx1bmEuY29tLnR3Lz9vcD1WaWV3QXJ0aWNsZSZhcnRpY2xlSWQ9MTg1\">Makefile 語法簡介<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n",
            "tags": [
                "linux",
                "makefile"
            ]
        }
    ]
}