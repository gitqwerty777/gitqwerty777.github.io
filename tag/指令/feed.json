{
    "version": "https://jsonfeed.org/version/1",
    "title": "QWERTY • All posts by \"指令\" tag",
    "description": "Programming | Computer Science | Thought",
    "home_page_url": "http://gitqwerty777.github.io",
    "items": [
        {
            "id": "http://gitqwerty777.github.io/Emacs-tips/",
            "url": "http://gitqwerty777.github.io/Emacs-tips/",
            "title": "Emacs常用指令表",
            "date_published": "2015-05-02T09:49:50.000Z",
            "content_html": "<blockquote>\n<p>Emacs快捷鍵是可以修改的，所以不一定要全部記住，只需要熟悉基本功能和知道有其他方便的擴充功能即可</p>\n</blockquote>\n<h2 id=\"Emacs基本\"><a href=\"#Emacs基本\" class=\"headerlink\" title=\"Emacs基本\"></a>Emacs基本</h2><ul>\n<li>C → Ctrl</li>\n<li>M → Alt 或 esc</li>\n<li>S → Shift</li>\n<li>Ret → return(enter)</li>\n<li>範例<ul>\n<li><code>C-c</code> → Ctrl + c</li>\n<li><code>C-c C-f</code> → Ctrl + c, 放開c, 按下f，也可以分開來按，但較慢</li>\n</ul>\n</li>\n<li><code>hello.c</code>的自動儲存檔案的檔名就是<code>#hello.c#</code><ul>\n<li>儲存檔案後，自動儲存檔就會被刪除</li>\n</ul>\n</li>\n<li>Ctrl 通常是對一個字操作， Alt 通常是對一個詞，或一個句子操作</li>\n<li>每一個Emacs的指令都有名稱，可以用<code>M-x [command]</code>來執行指令</li>\n</ul>\n<h3 id=\"Emacs移動\"><a href=\"#Emacs移動\" class=\"headerlink\" title=\"Emacs移動\"></a>Emacs移動</h3><p><img data-src=\"/img/Other/emacs-move.png\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>介紹</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>M-v, C-v</td>\n<td>上翻/下翻一頁</td>\n</tr>\n<tr>\n<td>M-b, M-f</td>\n<td>往前/往後 移動一個詞</td>\n</tr>\n<tr>\n<td>M-a, M-e</td>\n<td>移動到一句的開始/結尾(程式碼的一個段落)</td>\n</tr>\n<tr>\n<td>C-l</td>\n<td>移動視窗(遊標所在的行移動至最上方、最下方、中間)</td>\n</tr>\n<tr>\n<td>M-g M-g</td>\n<td>跳至指定行(= M-g g)</td>\n</tr>\n<tr>\n<td>M-m</td>\n<td>將游標移到該行第一個字元(大多數情況下，等同C-a)</td>\n</tr>\n</tbody></table>\n<h3 id=\"Emacs編輯\"><a href=\"#Emacs編輯\" class=\"headerlink\" title=\"Emacs編輯\"></a>Emacs編輯</h3><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>介紹</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>C-j</td>\n<td>換行並自動縮排(<code>newline-and-indent</code>)</td>\n</tr>\n<tr>\n<td>C-SPACE</td>\n<td>開始選取文字(再按一次結束選取)</td>\n</tr>\n<tr>\n<td>C-x C-x</td>\n<td>改變選取的方向</td>\n</tr>\n<tr>\n<td>C-x h</td>\n<td>全選</td>\n</tr>\n<tr>\n<td>M-h</td>\n<td>選擇遊標所在的段落</td>\n</tr>\n<tr>\n<td>C-w/M-w</td>\n<td>剪下/複製 選取文字</td>\n</tr>\n<tr>\n<td>C-y</td>\n<td>貼上選取文字</td>\n</tr>\n<tr>\n<td>M-y</td>\n<td>改變貼上的文字(從之前剪下/複製過的文字中，由新到舊出現)</td>\n</tr>\n<tr>\n<td>C-d</td>\n<td>同<code>delete</code>鍵(刪除後一個字)</td>\n</tr>\n<tr>\n<td>M-d</td>\n<td>刪除後一個詞</td>\n</tr>\n<tr>\n<td>M-del</td>\n<td>刪除前一個詞</td>\n</tr>\n<tr>\n<td>C-g</td>\n<td>取消尚未完成的指令(如選擇遊標)</td>\n</tr>\n<tr>\n<td>C-x C-;</td>\n<td>註釋/取消註釋</td>\n</tr>\n</tbody></table>\n<p><code>C-k</code>: 刪除從游標到「行尾」間的字元</p>\n<ul>\n<li>單獨的 C-k 會把一行的內容殺掉</li>\n<li>而第二個 C-k 則會殺掉那一行本身(‘\\n’)。使所有其他的行向上移動</li>\n</ul>\n<p><code>C-x u</code>: 還原</p>\n<ul>\n<li>不會還原沒有改變文字的指令（移動游標和視窗等）</li>\n<li>自行鍵入的字元 一次最多還原20個</li>\n</ul>\n<h3 id=\"重複\"><a href=\"#重複\" class=\"headerlink\" title=\"重複\"></a>重複</h3><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>介紹</th>\n<th>示範</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>C-u [數字] [指令or字元]</td>\n<td>重複執行</td>\n<td>C-u 8 a → aaaaaaaa</td>\n</tr>\n<tr>\n<td>M-[數字] [指令or字元]</td>\n<td>重複執行</td>\n<td>M-8 a → aaaaaaaa</td>\n</tr>\n</tbody></table>\n<h3 id=\"Emacs搜尋\"><a href=\"#Emacs搜尋\" class=\"headerlink\" title=\"Emacs搜尋\"></a>Emacs搜尋</h3><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>介紹</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>C-s</td>\n<td>往後搜尋(再按一次：找下一個)</td>\n</tr>\n<tr>\n<td>C-r</td>\n<td>往前搜尋</td>\n</tr>\n<tr>\n<td>M-C-s</td>\n<td>正規表示式搜尋</td>\n</tr>\n<tr>\n<td>M-%</td>\n<td>取代</td>\n</tr>\n</tbody></table>\n<p>取代模式的操作</p>\n<ul>\n<li><code>y</code>或space：置換目前游標所在的字串，並且移到下一個可被置換的字串</li>\n<li><code>n</code>：跳過目前游標所在的字串。移到下一個可被置換的字串</li>\n<li><code>ESC</code>：結束置換模式</li>\n<li><code>.</code>：置換目前的字串，並離開置換模式</li>\n<li><code>!</code>：將整個檔案一次置換完畢，不進行任何詢問</li>\n<li><code>^</code>：回到前一個符合置換的地方</li>\n<li><code>C-r</code>: 進入recursive-edit模式<ul>\n<li><code>M-C-c</code>: 結束recursive-edit模式</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Emacs分割-window\"><a href=\"#Emacs分割-window\" class=\"headerlink\" title=\"Emacs分割(window)\"></a>Emacs分割(window)</h3><p>在螢幕上同時顯示的多個編輯區，稱為分割</p>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>介紹</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>C-x 0</td>\n<td>關閉目前分割</td>\n</tr>\n<tr>\n<td>C-x 1</td>\n<td>關閉其他分割(只留下目前的分割)</td>\n</tr>\n<tr>\n<td>C-x 2</td>\n<td>新增水平分割</td>\n</tr>\n<tr>\n<td>C-x 3</td>\n<td>新增垂直分割</td>\n</tr>\n<tr>\n<td>C-x o</td>\n<td>跳到別的分割(在現有的分割循環)</td>\n</tr>\n<tr>\n<td>M-C-v</td>\n<td>捲動另一個分割</td>\n</tr>\n<tr>\n<td>C-x 5 2</td>\n<td>開新視窗(frame)</td>\n</tr>\n</tbody></table>\n<h3 id=\"Emacs檔案\"><a href=\"#Emacs檔案\" class=\"headerlink\" title=\"Emacs檔案\"></a>Emacs檔案</h3><h4 id=\"Emacs檔案切換\"><a href=\"#Emacs檔案切換\" class=\"headerlink\" title=\"Emacs檔案切換\"></a>Emacs檔案切換</h4><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>介紹</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>C-x C-b</td>\n<td>列出開啟的檔案清單(<code>Buffer List</code>)</td>\n</tr>\n<tr>\n<td>C-x b</td>\n<td>切換至其他開啟的檔案</td>\n</tr>\n<tr>\n<td>C-x k</td>\n<td>關閉目前編輯的檔案</td>\n</tr>\n</tbody></table>\n<h4 id=\"Emacs檔案指令\"><a href=\"#Emacs檔案指令\" class=\"headerlink\" title=\"Emacs檔案指令\"></a>Emacs檔案指令</h4><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>介紹</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>C-x C-f</td>\n<td>開新檔案/開啟舊檔</td>\n</tr>\n<tr>\n<td>C-x 4 f</td>\n<td>在新分割開啟檔案</td>\n</tr>\n<tr>\n<td>C-x C-s</td>\n<td>儲存檔案</td>\n</tr>\n<tr>\n<td>C-x s</td>\n<td>全部檔案儲存</td>\n</tr>\n<tr>\n<td>C-x C-w</td>\n<td>另存新檔</td>\n</tr>\n<tr>\n<td>C-x d</td>\n<td>開啟資料夾模式(Dired Mode)</td>\n</tr>\n<tr>\n<td>C-x C-v</td>\n<td>開啟檔案取代目前的工作區(<code>find-alternate-file</code>, 開錯檔案的時候用)</td>\n</tr>\n</tbody></table>\n<h3 id=\"Emacs系統\"><a href=\"#Emacs系統\" class=\"headerlink\" title=\"Emacs系統\"></a>Emacs系統</h3><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>介紹</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>C-x C-c</td>\n<td>結束 Emacs</td>\n</tr>\n<tr>\n<td>C-z</td>\n<td>暫時離開Emacs(Suspend)</td>\n</tr>\n</tbody></table>\n<p>用<code>fg</code>或<code>%emacs</code>恢復 Emacs</p>\n<h3 id=\"Emacs函式\"><a href=\"#Emacs函式\" class=\"headerlink\" title=\"Emacs函式\"></a>Emacs函式</h3><table>\n<thead>\n<tr>\n<th>指令</th>\n<th>介紹</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>M-x [function]</td>\n<td>執行名為[function]的指令</td>\n</tr>\n<tr>\n<td>M-x compile</td>\n<td>編譯(會開啟<code>*compilation*</code>分割)</td>\n</tr>\n<tr>\n<td>M-x recompile</td>\n<td>重覆執行上次執行過的compile指令</td>\n</tr>\n<tr>\n<td>C-x `</td>\n<td>跳到下一個有編譯錯誤的地方</td>\n</tr>\n<tr>\n<td>M-x gdb</td>\n<td>用gdb除錯</td>\n</tr>\n<tr>\n<td>M-x shell</td>\n<td>開啟<code>shell</code>分割</td>\n</tr>\n</tbody></table>\n<p>在Shell分割中，需要在Shell指令前加上 <code>C-c</code><br>如 <code>C-c C-c</code> 為中止程式; <code>C-c C-z</code> 為暫停程式等</p>\n<h3 id=\"Emacs幫助\"><a href=\"#Emacs幫助\" class=\"headerlink\" title=\"Emacs幫助\"></a>Emacs幫助</h3><!-- TODO: -->\n\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>介紹</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>C-h ?</td>\n<td>開啟 <code>*Help*</code> 分割</td>\n</tr>\n<tr>\n<td>C-h c [指令]</td>\n<td>在命令列顯示簡短解釋</td>\n</tr>\n<tr>\n<td>C-h k [指令]</td>\n<td>在新分割顯示詳細解釋</td>\n</tr>\n<tr>\n<td>C-h f [函數]</td>\n<td>在新分割顯示函數說明</td>\n</tr>\n<tr>\n<td>C-h w [函數]</td>\n<td>查詢此函數的快捷鍵</td>\n</tr>\n<tr>\n<td>C-h m</td>\n<td>瀏覽現在模式的文件(C, C++, text…)</td>\n</tr>\n<tr>\n<td>C-h a</td>\n<td>列出所有「含有此關鍵字」的全部函數(Command Apropos)</td>\n</tr>\n<tr>\n<td>C-h i</td>\n<td>開啟 <code>*info*</code> 分割</td>\n</tr>\n</tbody></table>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><!-- TODO: -->\n\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>介紹</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>M-C-\\</td>\n<td>選擇區塊自動縮排(<code>indent-region</code>)</td>\n</tr>\n<tr>\n<td>M-;</td>\n<td>在句尾加入註解</td>\n</tr>\n<tr>\n<td>M-^</td>\n<td>將此行併入上一行</td>\n</tr>\n<tr>\n<td>C-t</td>\n<td>對調兩字元</td>\n</tr>\n<tr>\n<td>M-t</td>\n<td>對調兩單字</td>\n</tr>\n<tr>\n<td>C-x C-t</td>\n<td>對調兩行</td>\n</tr>\n<tr>\n<td>M-c</td>\n<td>將字的第一個字母改為大寫(Capitalize)</td>\n</tr>\n<tr>\n<td>M-u</td>\n<td>將單字改為大寫(Upper)</td>\n</tr>\n<tr>\n<td>M-l</td>\n<td>將單字改為小寫(Lower)</td>\n</tr>\n<tr>\n<td>C-x i</td>\n<td>插入其他檔案的內容(insert-file)</td>\n</tr>\n</tbody></table>\n<h2 id=\"Emacs技巧\"><a href=\"#Emacs技巧\" class=\"headerlink\" title=\"Emacs技巧\"></a>Emacs技巧</h2><h3 id=\"自動完成\"><a href=\"#自動完成\" class=\"headerlink\" title=\"自動完成\"></a>自動完成</h3><p><code>M-/</code> 可重複輸入以改變建議字串</p>\n<h3 id=\"移動至定義-goto-declaration\"><a href=\"#移動至定義-goto-declaration\" class=\"headerlink\" title=\"移動至定義(goto declaration)\"></a>移動至定義(goto declaration)</h3><ol>\n<li>建立tag檔<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># for c, c++ file</span></span><br><span class=\"line\">find . | grep <span class=\"string\">&quot;.*\\.\\(c\\|h\\|cpp\\)&quot;</span> | xargs etags -f tags <span class=\"comment\"># output filename &quot;tags&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># for python file</span></span><br><span class=\"line\">find . -<span class=\"built_in\">type</span> f -name <span class=\"string\">&#x27;*.py&#x27;</span> | xargs etags -f tags</span><br></pre></td></tr></table></figure></li>\n<li>在Emacs中用<code>M-.</code>進行搜尋</li>\n<li><code>C-x 4 .</code>: 在另一個分割開啟定義</li>\n</ol>\n<p><code>M-*</code> 回到前一個定義的位置  </p>\n<p>使用<code>autocomplete</code>套件 </p>\n<!-- TODO: -->\n\n<h3 id=\"回到之前的遊標位置\"><a href=\"#回到之前的遊標位置\" class=\"headerlink\" title=\"回到之前的遊標位置\"></a>回到之前的遊標位置</h3><p>在搜尋或尋找定義之後很好用<br><code>C-u C-space</code></p>\n<h3 id=\"Emacs作為IDE使用\"><a href=\"#Emacs作為IDE使用\" class=\"headerlink\" title=\"Emacs作為IDE使用\"></a>Emacs作為IDE使用</h3><p><a href=\"http://stackoverflow.com/questions/11043004/emacs-compile-buffer-auto-close\">編譯成功後自動關閉<em>compilnation</em>分割</a><br><span class=\"exturl\" data-url=\"aHR0cDovL2xpZmVnb28ucGx1c2tpZC5vcmcvd2lraS9FbWFjc1NtYXJ0Q29tcGlsZS5odG1s\">智慧編譯：自動偵測檔名或makefile並編譯<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"Emacs巨集-Macro\"><a href=\"#Emacs巨集-Macro\" class=\"headerlink\" title=\"Emacs巨集(Macro)\"></a>Emacs巨集(Macro)</h3><!-- TODO: -->\n\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>介紹</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>C-x (</td>\n<td>開始定義巨集</td>\n</tr>\n<tr>\n<td>C-x )</td>\n<td>結束巨集定義</td>\n</tr>\n<tr>\n<td>C-x e</td>\n<td>執行上一個定義的巨集</td>\n</tr>\n<tr>\n<td>M-[Num] C-x e</td>\n<td>將上一個定義的巨集執行 Num 次</td>\n</tr>\n<tr>\n<td>C-u C-x (</td>\n<td>執行上一個定義的巨集，然後可以加上按鍵以重新定義巨集</td>\n</tr>\n<tr>\n<td>C-x q</td>\n<td>將巨集定義中插入查詢</td>\n</tr>\n<tr>\n<td>C-u C-x q</td>\n<td>將巨集定義中插入遞迴編輯</td>\n</tr>\n<tr>\n<td>M-C-c</td>\n<td>跳出遞迴編輯</td>\n</tr>\n</tbody></table>\n<p><code>name-last-kbd-macro</code>: 將上一個定義的巨集存檔之前予以命名<br><code>load-file</code>: 載入儲存的lisp程式碼巨集<br><code>macroname</code>: 執行儲存過的”macroname”巨集<br><code>insert-kbd-macro</code>: 將命名過的巨集以lisp程式碼印出</p>\n<p>應用：在<code>EmacsMacro.el</code>中儲存巨集程式碼，並在<code>.emacs</code>中寫入</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;;load my macro file</span></span><br><span class=\"line\">(<span class=\"name\">load</span> <span class=\"string\">&quot;~/EmacsMacro&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<!--\nTODO:\n### hippie\n\n### 书签\n\n### 快速切換到 shell 並 cd 到當前文件所在的目錄\n-->\n\n<h3 id=\"Emacs-Latex\"><a href=\"#Emacs-Latex\" class=\"headerlink\" title=\"Emacs + Latex\"></a>Emacs + Latex</h3><p><span class=\"exturl\" data-url=\"aHR0cDovL2JiczMubnN5c3UuZWR1LnR3L3R4dFZlcnNpb24vdHJlYXN1cmUvSVVUL00uMTAwNjg2ODM1Mi5BL00uMTAwNjk1MjY3OC5HLmh0bWw=\">參考資料<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>安裝: <code>sudo apt-get install texlive-full</code></p>\n<p>M-x validate-tex-region：檢查每一段文稿是否有不平衡的大括號或錢字號。<br>C-c {：插入 <code>&#123;&#125;&#39; 並將游標移至左右大括號之間\nC-c &#125;：將游標移至下一個右大括號的右端\nC-c C-o：插入 LaTeX 區段標記</code>\\begin’ 及\\end’ 並將游標移至<br>二者間的空行<br>C-c C-e：為前一個不平衡的 `\\begin’ 加上\\end’</p>\n<p>編譯</p>\n<ul>\n<li><p>C-c C-f：對目前所在的檔案執行 TeX/LaTeX 的編譯</p>\n</li>\n<li><p>C-c C-r：對一段區域 (region) 執行 TeX/LaTeX 的編譯</p>\n<ul>\n<li>不論是 TeX 或 LaTeX都包含了一段有關全文的訊息在整篇文稿的開端，若是僅僅編譯所指定的區域而忽略了這段訊息的話，將會產生錯誤的結果。為了解決這個問題，必需在文稿中標明header 的位置，然後在 用  C-c C-r 命令時  emacs 會自動將header中的訊息讀入處理。在 TeX 中標明 header 的方法是在 header段落前後插入 <code>%start of header&#39; 和</code> %end of header}’</li>\n</ul>\n</li>\n<li><p>C-c C-b：對整個目前所在的緩衝區 (buffer) 執行 TeX/LaTeX 的編譯</p>\n</li>\n<li><p>C-c C-r 和  C-c C-b 並不會產生如  *.aux等的附屬檔，因此無法執行cross-reference等工作。如果需要產生附屬檔則必需使用 C-c C-f</p>\n</li>\n<li><p>C-c TAB：對目前所在的檔案執行 BibTeX 的編譯</p>\n</li>\n<li><p>C-c C-v：預覽 C-c C-r, C-c C-b 或  C-c C-f 編譯的結果</p>\n</li>\n<li><p>C-c C-k：終結 (kill) 目前進行中的 TeX/LaTeX 程序(process)</p>\n</li>\n<li><p>C-c C-p：列印 C-c C-r、C-c C-b 或 C-cC-f 編譯的結果</p>\n</li>\n<li><p>C-c C-q：顯示目前的 printer queue</p>\n</li>\n</ul>\n<h3 id=\"Emacs-Git\"><a href=\"#Emacs-Git\" class=\"headerlink\" title=\"Emacs + Git\"></a>Emacs + Git</h3><p><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9ob2xicm9vay9hcmNoaXZlLzIwMTIvMDQvMjYvMjQ3MDkyMy5odG1s\">使用git-emacs套件<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"畫簡單的ASCII圖\"><a href=\"#畫簡單的ASCII圖\" class=\"headerlink\" title=\"畫簡單的ASCII圖\"></a>畫簡單的ASCII圖</h3><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2VtYWNzZXIuY29tL2FydGlzdC1tb2RlLmh0bQ==\">Artist Mode<i class=\"fa fa-external-link-alt\"></i></span>    </li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2VtYWNzZXIuY29tL2VtYWNzLWRpdGFhLmh0bWw=\">輸出成圖片檔<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n<h3 id=\"Emacs-Markdown\"><a href=\"#Emacs-Markdown\" class=\"headerlink\" title=\"Emacs + Markdown\"></a>Emacs + Markdown</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW51eHRveS5vcmcvYXJjaGl2ZXMvZW1hY3MtbWFya2Rvd24tbW9kZS5odG1s\">Emacs Markdown模式<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>有些指令直接輸入比較快…</p>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>介紹</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>C-c C-t [N]</td>\n<td>插入第N級的標題</td>\n</tr>\n<tr>\n<td>C-c C-a l</td>\n<td>插入鏈接，格式為 <code>[text](url)</code></td>\n</tr>\n<tr>\n<td>C-c C-i i</td>\n<td>插入圖像，格式為 <code>![text](url)</code></td>\n</tr>\n<tr>\n<td>C-c -</td>\n<td>插入水平線</td>\n</tr>\n<tr>\n<td>S-Tab</td>\n<td>在大綱視圖、目錄視圖、及正常視圖間切換</td>\n</tr>\n<tr>\n<td>C-c C-c m</td>\n<td>預覽HTML</td>\n</tr>\n<tr>\n<td>C-c C-c p</td>\n<td>在瀏覽器中預覽</td>\n</tr>\n</tbody></table>\n<h3 id=\"Emacs-Screen\"><a href=\"#Emacs-Screen\" class=\"headerlink\" title=\"Emacs + Screen\"></a>Emacs + Screen</h3><p><span class=\"exturl\" data-url=\"aHR0cDovL2xhZ3VuYXdhbmcucGl4bmV0Lm5ldC9ibG9nL3Bvc3QvMjgzNjgyNS1saW51eC1zY3JlZW4lRTYlOEMlODclRTQlQkIlQTQ=\">Screen 指令表<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>因為Emacs的快捷鍵和Screen重複，要自己在<code>.screenrc</code>設定檔修改</p>\n<ul>\n<li>在 <code>.screenrc</code> 中新增 <code>escape ^tt</code><br>即可將 所有 C-a 改為 C-t</li>\n<li>在 <code>.screenrc</code> 中新增 <code>escape ^l^l</code><br>即可將 所有 <code>C-a</code> 改為 <code>C-l</code>，且在輸入 <code>C-l C-l</code> 時可以跳脫screen指令(等同在terminal輸入<code>C-l</code>)</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2xpZmVnb28ucGx1c2tpZC5vcmcvd2lraS9TY3JlZW4uaHRtbA==\">修改教學<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n<p>在使用Emacs時，適合bind到screen的key:<br><code>C-v</code>(scroll-up-command), <code>C-space</code>(set-mark-command), <code>C-t</code>(transpose-chars), <code>C-d</code>(delete char), C-l(recenter-top-bottom)<br>其他都太常用或是不能bind(<code>C-z</code>, <code>C-q</code>, <code>C-m</code>, <code>C-i</code>)，不然就要用 C-S 系列</p>\n<!-- ### Dired Mode\n\nTODO:\n\n### 套件安裝\n\nTODO: -->\n\n<h3 id=\"其他功能\"><a href=\"#其他功能\" class=\"headerlink\" title=\"其他功能\"></a>其他功能</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9lbWFjcy9tYW51YWwvaHRtbF9ub2RlL2VmYXEvUmVwbGFjaW5nLXRleHQtYWNyb3NzLW11bHRpcGxlLWZpbGVzLmh0bWw=\">多檔案取代字串<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"字體大小\"><a href=\"#字體大小\" class=\"headerlink\" title=\"字體大小\"></a>字體大小</h3><ul>\n<li>放大字體: C-x C-+ 或 C-x C-=</li>\n<li>縮小字體: C-x C-–</li>\n<li>重置字體: C-x C-0</li>\n</ul>\n<h3 id=\"Emacs-Server\"><a href=\"#Emacs-Server\" class=\"headerlink\" title=\"Emacs Server\"></a>Emacs Server</h3><p>若Emacs設定檔太大，開啟時會需要花很長時間，所以可以持續開啟server，需要的時候再使用client連接至server，即可省下讀取設定的時間。</p>\n<!-- TODO: 測試 -->\n<ul>\n<li>開啟server: <code>emacs --daemon</code></li>\n<li>連線至server: <code>emacsclient</code></li>\n</ul>\n<h3 id=\"解決Windows上C-Space被中文輸入法佔用的問題\"><a href=\"#解決Windows上C-Space被中文輸入法佔用的問題\" class=\"headerlink\" title=\"解決Windows上C-Space被中文輸入法佔用的問題\"></a>解決Windows上C-Space被中文輸入法佔用的問題</h3><ol>\n<li>上策：移除輸入法的<code>C-space</code>綁定(失敗)<ol>\n<li>語言列選項 → 輸入語言快捷鍵 → 將<code>C-Space</code>取消或改成別的</li>\n</ol>\n</li>\n<li>中策：比輸入法更優先綁定<code>C-space</code>(成功)<ol>\n<li>使用AutoHotKey<ol>\n<li><code>^Space::^+2</code>: 將 <code>C-Space</code> 映射至 <code>C-S-2</code></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>下策：換別的快捷鍵<ol>\n<li><code>C-S-2</code>(Emacs內建，不過很難按)</li>\n<li><code>M-space</code>(在VSCode不適用)</li>\n<li><code>C-t</code></li>\n<li><code>C-m</code></li>\n<li><code>C-h</code></li>\n</ol>\n</li>\n</ol>\n<h2 id=\"Emacs知識\"><a href=\"#Emacs知識\" class=\"headerlink\" title=\"Emacs知識\"></a>Emacs知識</h2><p><span class=\"exturl\" data-url=\"aHR0cDovL2xpZmVnb28ucGx1c2tpZC5vcmcvd2lraS9FbWFjcy5odG1s\">參考資料<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"名稱\"><a href=\"#名稱\" class=\"headerlink\" title=\"名稱\"></a>名稱</h3><p>Emacs 是 「編輯巨集」[Editing MACroS]的簡稱</p>\n<h3 id=\"前綴\"><a href=\"#前綴\" class=\"headerlink\" title=\"前綴\"></a>前綴</h3><ul>\n<li>一些不是特別常用的函數綁定到前綴 C-x 上。例如 C-x C-c 退出 Emacs， C-x 2 水平分割當前 window</li>\n<li>與某個 mode 相關的的函數被綁定到前綴 C-c 上</li>\n<li>最不常用的函數根本沒有鍵綁定，而是使用 M-x 然後輸入函數名來調用他們</li>\n<li>前綴 C-x 4 被保留作操作另外一個 window 用的函數，例如 C-x 4 C-f 在另 外一個 window 裡面打開文件</li>\n<li>前綴 C-x 5 被綁定到操縱其他frame 的 函數上面</li>\n</ul>\n<h3 id=\"殺掉-kill\"><a href=\"#殺掉-kill\" class=\"headerlink\" title=\"殺掉(kill)\"></a>殺掉(kill)</h3><!-- - TODO: kill-ring -->\n<ul>\n<li>被殺掉的可以拉回，而被刪除的則不能<ul>\n<li><code>delete</code>, <code>backspace</code>都是刪除</li>\n<li><code>C-k</code>, <code>C-w</code>, <code>M-w</code> 等指令都是殺掉<ul>\n<li>如果連續地做了數次 C-k，所有被殺掉的文字都會被儲存在一起，因此做一次C-y 就會把所有這些行都拉回來</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>將被殺掉的文字回復的動作稱為「拉回（ yanking ）」<ul>\n<li>即為貼上的意思<ul>\n<li><code>C-y</code> 會把最近殺掉的拉回來，前幾次殺掉的文字可以用 <code>M-y</code> 來回復</li>\n<li>可以給 <code>M-y</code> 正的或是負的參數來回到之前殺掉的東西</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"搜尋\"><a href=\"#搜尋\" class=\"headerlink\" title=\"搜尋\"></a>搜尋</h3><ul>\n<li>Emacs 搜尋指令是「漸進的（ incremental ）」，搜尋發生在遊標後<ul>\n<li>如果鍵入『u』，游標會移動到「cu」的第一次出現位置。將「u」從s搜尋字串中消除，游標會移回到「c」的第一次出現位置</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"設定檔位置\"><a href=\"#設定檔位置\" class=\"headerlink\" title=\"設定檔位置\"></a>設定檔位置</h3><p>家目錄的<code>.emacs</code>檔案和<code>.emacs.d</code>資料夾，可修改Emacs設定</p>\n<h3 id=\"Shell\"><a href=\"#Shell\" class=\"headerlink\" title=\"Shell\"></a>Shell</h3><ul>\n<li>Bash上預設的控制模式是Emacs，也就是說可以使用 C-a, C-f, C-b 等移動鍵，C-r搜尋歷史指令，C-n, C-p 切換歷史指令，C-k 殺掉文字，C-y貼上文字，C-j 執行指令等等。</li>\n<li>和Emacs不一樣的地方有 <code>C-h</code>往前刪除一字元, <code>C-w</code>清除游標以前的一個單字, <code>C-u</code>清除游標以前所有的字元。</li>\n</ul>\n<h3 id=\"其他-1\"><a href=\"#其他-1\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>Emacs即為Lisp語言直譯器，所以理論上可以做到任何Lisp能做到的事，所以也被稱為「神之編輯器」。</p>\n<!-- (https://www.facebook.com/pangfeng.liu/posts/696258720389410?match=ZW1hY3M%3D) -->\n<blockquote>\n<p>我完全同意 emacs 和管風琴一樣。配合 Cherry 機械鍵盤寫論文寫程式有如彈琴。Ctrl 鍵有如和弦，空白鍵宛如音符之間的暫停，而最後重重敲下 Return 鍵時，右手宛如指揮家劃下最後一個節拍的爽快。<br>– 劉邦鋒</p>\n</blockquote>\n<h3 id=\"軼事\"><a href=\"#軼事\" class=\"headerlink\" title=\"軼事\"></a>軼事</h3><p>Tim O’relly 原本使用 Emacs，直到他弄丟 <code>.emacs</code> 檔案</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMDkxMDAzMDExMjAwL2h0dHA6Ly93d3cub3JlaWxseW5ldC5jb20vcHViL2Evb3JlaWxseS9hc2tfdGltLzE5OTkvdW5peF9lZGl0b3IuaHRtbA==\">原文<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"快速設定\"><a href=\"#快速設定\" class=\"headerlink\" title=\"快速設定\"></a>快速設定</h2><p>使用現成的設定檔</p>\n<ul>\n<li><p>優點</p>\n<ul>\n<li>不用寫lisp</li>\n<li>經過優化</li>\n<li>較完整</li>\n</ul>\n</li>\n<li><p>缺點</p>\n<ul>\n<li>不夠客製化</li>\n<li>功能太多，搞不清</li>\n<li>難以修改</li>\n</ul>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2JiYXRzb3YvcHJlbHVkZQ==\">Prelude<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3B1cmNlbGwvZW1hY3MuZA==\">Purcell<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n<li><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3N5bDIwYm5yL3NwYWNlbWFjcw==\">Spacemacs<i class=\"fa fa-external-link-alt\"></i></span></p>\n</li>\n</ul>\n<h2 id=\"CheatSheet\"><a href=\"#CheatSheet\" class=\"headerlink\" title=\"CheatSheet\"></a>CheatSheet</h2><p><img data-src=\"/img/emacs/cheatsheet.png\" alt=\"\"></p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3N0ZXZlbmNoYW4udXMvZW1hY3MtdmlzdWFsLWNoZWF0LXNoZWV0\">Cheat Sheet<i class=\"fa fa-external-link-alt\"></i></span></p>\n<!--\n## Mode Line\n\n TODO: -->\n\n<!-- ## Org Mode\n\nhttps://github.com/pbesedm/Oh-My-Editors/blob/master/doc/emacs%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB.org -->\n\n\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2NsaXB0aGF0LmJsb2dzcG90LnR3LzIwMTAvMDEvZW1hY3MuaHRtbA==\">指令大全<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5lbWFjcy51bml5YXIuYWMucnUvZG9jL2VtMjRoLw==\">Sams Teach Yourself Emacs in 24 Hours<i class=\"fa fa-external-link-alt\"></i></span> <!-- 未讀--></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcmVkZ3VhcmR0b28vYXJ0aWNsZS9kZXRhaWxzLzcyMjI1MDE=\">一年成為Emacs高手<i class=\"fa fa-external-link-alt\"></i></span><ul>\n<li>有常用套件推薦</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "Emacs",
                "指令"
            ]
        },
        {
            "id": "http://gitqwerty777.github.io/git-commands/",
            "url": "http://gitqwerty777.github.io/git-commands/",
            "title": "Git常用指令",
            "date_published": "2014-09-16T09:14:44.000Z",
            "content_html": "<p>主要參考此書：<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ib29rcy5jb20udHcvcHJvZHVjdHMvMDAxMDU3NDA5MA==\">版本控制：使用Git<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>建議初學者先看<a href=\"/git-introduction\">git觀念</a>及此篇的第一段</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Git基本觀念\"><a href=\"#Git基本觀念\" class=\"headerlink\" title=\"Git基本觀念\"></a>Git基本觀念</h2><table>\n<thead>\n<tr>\n<th>檔案階段</th>\n<th>檔案所在位置</th>\n<th>說明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>已修改</td>\n<td>Working Directory(工作目錄)</td>\n<td>經過修改的檔案</td>\n</tr>\n<tr>\n<td>已暫存</td>\n<td>Staging area(暫存區)</td>\n<td>要提交的變動清單</td>\n</tr>\n<tr>\n<td>已提交</td>\n<td>Repository(容器)</td>\n<td>已提交的檔案及變動記錄</td>\n</tr>\n</tbody></table>\n<p><img data-src=\"https://image.slidesharecdn.com/git-getreadytouseit-140228043813-phpapp02/95/git-get-ready-to-use-it-5-638.jpg?cb=1393562489\" alt=\"\"></p>\n<p>其他檔案階段</p>\n<ul>\n<li>被忽略：在名為<code>.gitignore</code>的檔案中修改想忽略的檔案，如暫存檔、log、或編譯後的object file、筆記<ul>\n<li>每個目錄都可以有自己的<code>.gitignore</code>檔，以較接近檔案的目錄為準</li>\n<li>可以用<code>git add -f</code>強制將被忽略的檔案加入暫存區</li>\n</ul>\n</li>\n</ul>\n<p>觀看檔案的狀態: <code>git status</code></p>\n<ul>\n<li>已修改: <code>Changes not staged for commit</code></li>\n<li>已暫存: <code>Changes to be committed</code></li>\n<li>已提交: 不顯示</li>\n</ul>\n<p>基本流程: 修改檔案 → 將修改的檔案加入 Staging area (<code>git add</code>) → 提交變更 (<code>git commit</code>) → 繼續修改檔案(循環)</p>\n<p>若要和他人共用，要在線上容器和本機容器間進行同步(<code>git push</code>, <code>git pull</code>)</p>\n<p>提交(commit，也稱送交)</p>\n<ul>\n<li>版本和容器變動的最小單位<ul>\n<li><strong>一個commit = 一個版本</strong></li>\n<li>git 中的 <code>HEAD</code> 等於目前所在的版本</li>\n</ul>\n</li>\n<li>不一定所有檔案都要提交<ul>\n<li>只有加入Staging area的檔案會被提交</li>\n</ul>\n</li>\n<li>提交時機<ul>\n<li>程式處於穩定狀態<ul>\n<li>可以正確執行</li>\n<li>測試完成</li>\n</ul>\n</li>\n<li>以時間為單位<ul>\n<li>結束一天的工作前</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>辨識碼</p>\n<ul>\n<li>所有物件都有一個獨特的辨識碼<ul>\n<li>包含commit, tag, 文件…都有辨識碼<ul>\n<li>其值為物件的SHA1 hash</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>下述指令的<code>[commit]</code>即為識別碼<ul>\n<li>在沒有重覆的情況下，可取前幾碼代表該物件</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"設定\"><a href=\"#設定\" class=\"headerlink\" title=\"設定\"></a>設定</h3><p>先設定自己的名字與信箱，因為git用名字與信箱來分辨作者</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 若不加 --global 則設定只會在該容器生效</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 設定使用者名稱(加上引號)</span></span><br><span class=\"line\">git config --global user.name <span class=\"string\">\"First Last\"</span></span><br><span class=\"line\"><span class=\"comment\"># 設定使用者電子郵件(加上引號)</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">\"user@example.com\"</span></span><br><span class=\"line\"><span class=\"comment\"># 開啟顏色，使git內容不會只有單一白色</span></span><br><span class=\"line\">git config --global color.ui <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 設定預設編輯器(提交時會用到)</span></span><br><span class=\"line\">git config --global core.editor <span class=\"string\">\"emacs\"</span></span><br><span class=\"line\"><span class=\"comment\"># 設定指令的縮寫(將git st設為git status的簡寫)</span></span><br><span class=\"line\">git config --global alias.st status</span><br><span class=\"line\"><span class=\"comment\"># 列出所有設定值</span></span><br><span class=\"line\">git config -l</span><br></pre></td></tr></table></figure>\n\n<p>設定預設提交格式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 方法1. 直接設定</span></span><br><span class=\"line\">git config --global commit.template <span class=\"variable\">$HOME</span>/.git-template</span><br><span class=\"line\"><span class=\"comment\"># 方法2. 在 .gitconfig 中設定</span></span><br><span class=\"line\">[commit]</span><br><span class=\"line\">template = /home/frank/.git-template</span><br></pre></td></tr></table></figure>\n<h3 id=\"實作範例\"><a href=\"#實作範例\" class=\"headerlink\" title=\"實作範例\"></a>實作範例</h3><p>初始化一個專案</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git init <span class=\"comment\"># 初始化，使當前目錄成為git的容器</span></span><br><span class=\"line\">touch README.md <span class=\"comment\"># 加上專案的說明文件(非必要)</span></span><br><span class=\"line\">git add README.md <span class=\"comment\"># 將說明文件加入暫存區</span></span><br><span class=\"line\">git commit -m <span class=\"string\">\"initial commit\"</span> <span class=\"comment\"># 提交變更</span></span><br></pre></td></tr></table></figure>\n\n<p>將本地的容器上傳到遠端(如github)的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git remote add origin &lt;URL&gt; <span class=\"comment\"># 將遠端容器命名為origin</span></span><br><span class=\"line\">git push -u origin master <span class=\"comment\"># 從本地端的master branch上傳到origin的master branch</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"本篇：Git常用指令\"><a href=\"#本篇：Git常用指令\" class=\"headerlink\" title=\"本篇：Git常用指令\"></a>本篇：Git常用指令</h2><h3 id=\"Git檔案操作\"><a href=\"#Git檔案操作\" class=\"headerlink\" title=\"Git檔案操作\"></a>Git檔案操作</h3><h4 id=\"加入暫存區-add\"><a href=\"#加入暫存區-add\" class=\"headerlink\" title=\"加入暫存區: add\"></a>加入暫存區: add</h4><p><code>git add</code>：將檔案加入暫存區(staging area)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git add -i <span class=\"comment\"># 進入互動模式(推薦)</span></span><br><span class=\"line\"></span><br><span class=\"line\">git add [filename] <span class=\"comment\"># 將檔案加入staging area</span></span><br><span class=\"line\">git add -u <span class=\"comment\"># 只把「修改/刪除」的檔案加入staging area，「新增」的檔案不加入</span></span><br><span class=\"line\">git add -p <span class=\"comment\"># 部分暫存：git會詢問哪些檔，然後逐個顯示被選中檔案的每一個差異部分，</span></span><br><span class=\"line\"><span class=\"comment\"># 並詢問你是否希望暫存他們。(= git add --patch)</span></span><br><span class=\"line\">git add -A <span class=\"comment\"># stages All</span></span><br><span class=\"line\">git add .  <span class=\"comment\"># stages new and modified, without deleted</span></span><br></pre></td></tr></table></figure>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NzI1NDkvZGlmZmVyZW5jZS1iZXR3ZWVuLWdpdC1hZGQtYS1hbmQtZ2l0LWFkZA==\">參考資料<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>直接刪除/移動不會影響容器中的檔案，因為這項變動沒有告知git<br>若要在下一個版本刪除或移動檔案，需要用<code>git rm</code>或<code>git mv</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git rm [filename] <span class=\"comment\"># 在下一個版本移除，並實際刪除檔案</span></span><br><span class=\"line\">git rm --cache [filename] <span class=\"comment\"># 在下一個版本移除，但不實際刪除檔案</span></span><br><span class=\"line\">git mv [filename] [new-filename] <span class=\"comment\"># 改名、搬移檔案，並將變動加入staging area</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"checkout\"><a href=\"#checkout\" class=\"headerlink\" title=\"checkout\"></a>checkout</h4><p><strong>使檔案還原到指定提交時的版本</strong></p>\n<ul>\n<li>發現檔案改錯，用<code>git checkout filename</code>把檔案還原到最近的版本</li>\n<li><code>git checkout [commit] filename</code> 檔案會被還原到指定的commit時的版本</li>\n</ul>\n<h3 id=\"Git更新版本\"><a href=\"#Git更新版本\" class=\"headerlink\" title=\"Git更新版本\"></a>Git更新版本</h3><h4 id=\"提交新版本-commit\"><a href=\"#提交新版本-commit\" class=\"headerlink\" title=\"提交新版本(commit)\"></a>提交新版本(commit)</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git commit <span class=\"comment\"># 會跳出編輯器，此時可編輯提交訊息</span></span><br><span class=\"line\">git commit -m <span class=\"string\">'commit message'</span> <span class=\"comment\"># 直接提交並指定提交訊息</span></span><br><span class=\"line\">git commit -a <span class=\"comment\"># 將所有修改過的檔案直接 commit(跳過add步驟), 不包含新增的檔案</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"存取遠端容器-push-pull\"><a href=\"#存取遠端容器-push-pull\" class=\"headerlink\" title=\"存取遠端容器: push, pull\"></a>存取遠端容器: push, pull</h4><p>遠端的repository名稱通常取名為<code>origin</code><br><code>push</code>: 上傳, <code>pull</code>: 下載</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git remote show <span class=\"comment\"># 顯示設定的遠端容器及其名稱、網址</span></span><br><span class=\"line\">git remote add origin [url] <span class=\"comment\"># 設定遠端容器連結並命名為origin</span></span><br><span class=\"line\">git push origin master <span class=\"comment\">#  從本地目前的branch上傳至遠端master</span></span><br><span class=\"line\">git pull origin master <span class=\"comment\">#  從遠端master更新到本地目前的branch</span></span><br><span class=\"line\">git pull origin/[branchB] [branchA] <span class=\"comment\"># 從遠端branchB更新到本地branchA</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> [url] [localRepositoryPath] <span class=\"comment\"># 複製遠端容器至本地</span></span><br><span class=\"line\">git fetch origin <span class=\"comment\"># 下載origin的branch到本地</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>push時，如果和遠端容器有衝突，需要先pull，在本地merge(處理衝突)後再push</li>\n<li>pull的機制：先 fetch 遠端的 branch，然後與本地端的 branch 做 merge<ul>\n<li>若有衝突，<strong>會多產生一個 merge commit</strong>來取代遠端有衝突的所有commit</li>\n<li>用<code>git pull --rebase origin master</code>可以保留雙方的commit</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Git分支-branch\"><a href=\"#Git分支-branch\" class=\"headerlink\" title=\"Git分支(branch)\"></a>Git分支(branch)</h3><p>分支(branch): 將特定版本(commit)命名</p>\n<p><code>git branch</code><br><code>git checkout</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git branch <span class=\"comment\"># 列出本地分支(前方有星號的為目前所在分支)</span></span><br><span class=\"line\">git branch -r <span class=\"comment\"># 列出遠端分支</span></span><br><span class=\"line\">git branch -a <span class=\"comment\"># 列出所有分支(本地+遠端)</span></span><br><span class=\"line\">git show-branch <span class=\"comment\"># 列出本地分支樹狀圖</span></span><br><span class=\"line\">git branch [branchname] [commit] <span class=\"comment\"># 在指定commit上建立分支</span></span><br><span class=\"line\">git branch -d [branchname] <span class=\"comment\"># 刪除指定分支</span></span><br><span class=\"line\">git branch -m [old-name] [new-name] <span class=\"comment\"># 重新命名分支</span></span><br><span class=\"line\">git branch [new-branch] [old-branch] <span class=\"comment\"># 由分支old-branch複製出新分支new-branch</span></span><br><span class=\"line\"></span><br><span class=\"line\">git checkout [branch] <span class=\"comment\"># 切換到指定分支</span></span><br><span class=\"line\">git checkout [commit] <span class=\"comment\"># 也可以切換到任何commit</span></span><br><span class=\"line\"><span class=\"comment\"># 若commit不在任何branch上，用 git branch 查看時，會顯示 (no branch)</span></span><br><span class=\"line\">git checkout -b [new-branch] <span class=\"comment\"># 建立並切換到新分支new-branch(從目前所在的分支複製)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>git checkout -m [branch]</code> # 將工作目錄的變動和分支合併，並切換到該分支</li>\n<li>git checkout 時，若已修改的檔案和checkout的版本產生衝突，則checkout不會執行<ul>\n<li>衝突時先<code>git stash</code>(暫時清空已修改的檔案)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Git-標籤-tag\"><a href=\"#Git-標籤-tag\" class=\"headerlink\" title=\"Git 標籤(tag)\"></a>Git 標籤(tag)</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git tag [tagname] [commit] <span class=\"comment\"># 在指定commit新增tag</span></span><br><span class=\"line\">git tag -d [tagname] <span class=\"comment\"># 刪除tag</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Git合併-merge\"><a href=\"#Git合併-merge\" class=\"headerlink\" title=\"Git合併(merge)\"></a>Git合併(merge)</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git merge [branch/commit] <span class=\"comment\"># 將指定的版本合併到目前所在的分支</span></span><br></pre></td></tr></table></figure>\n\n<p>產生衝突時：先用<code>git diff</code> <code>git status</code>查看<br>衝突的地方為如下格式</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">//version1 code</span></span><br><span class=\"line\">...</span><br><span class=\"line\">========</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">//version2 code</span></span><br><span class=\"line\">...</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>分別是兩個版本的差異。<br>將其修改後即可提交</p>\n<ul>\n<li><code>git diff --ours/--theirs</code> 可以查看原版本和衝突版本的差異(ours→合併的, theirs→被合併的)</li>\n<li><code>git diff</code> 用在衝突檔案時只會顯示衝突的部分，而不會顯示只有一邊修改的部分</li>\n</ul>\n<h3 id=\"Git-修改版本\"><a href=\"#Git-修改版本\" class=\"headerlink\" title=\"Git 修改版本\"></a>Git 修改版本</h3><h4 id=\"修改版本-rebase\"><a href=\"#修改版本-rebase\" class=\"headerlink\" title=\"修改版本: rebase\"></a>修改版本: rebase</h4><p><code>rebase</code>可以重新排序、編輯、移除、合併、拆分提交</p>\n<ul>\n<li>優點<ul>\n<li>可以不產生分支線和額外的merge commit</li>\n</ul>\n</li>\n<li>缺點<ul>\n<li><strong>等於改變提交記錄，僅適合還沒上傳的commit</strong></li>\n<li>commit被移動，所以特徵碼會改變(也就是<strong>原本的commit會被取代</strong>)</li>\n<li>commit的形狀會被改變(變成一條直線)<ul>\n<li>可用<code>--preserve-merge</code>參數保留形狀</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>麻煩<ul>\n<li>移動的commit若屬於多個分支，則每個分支都要重新指定位置</li>\n</ul>\n</li>\n</ul>\n<p>使用時機：想保留額外commit資訊時，可替代merge</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; debug rebase on master</span><br><span class=\"line\">git checkout debug</span><br><span class=\"line\">git rebase master</span><br><span class=\"line\"></span><br><span class=\"line\">Original:</span><br><span class=\"line\">master A → B→C→D→E</span><br><span class=\"line\">  |      ↘</span><br><span class=\"line\">debug      F→G→H</span><br><span class=\"line\"></span><br><span class=\"line\">After rebase:</span><br><span class=\"line\">master A → B→C→D→E</span><br><span class=\"line\">  |               ↘</span><br><span class=\"line\">debug               F→G→H</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git rebase -i [commit] <span class=\"comment\"># rebase互動模式(推薦)</span></span><br><span class=\"line\"><span class=\"comment\"># 互動模式指令：pick: commit, squash: 擠壓到前一個commit, edit: 停在此commit提交前的情形以修改(可以拆成多次commit) …</span></span><br><span class=\"line\"><span class=\"comment\"># 在rebase時遇到衝突的話，會提示使用者手動解決衝突(merge)</span></span><br><span class=\"line\">git rebase --<span class=\"built_in\">continue</span> <span class=\"comment\"># (解決衝突後)繼續rebase</span></span><br><span class=\"line\">git rebase --skip <span class=\"comment\"># 忽略一個原本要rebase的commit</span></span><br><span class=\"line\">git rebase --abort <span class=\"comment\"># 取消rebase</span></span><br><span class=\"line\"></span><br><span class=\"line\">git rebase --onto master [commitA] [commitB] <span class=\"comment\">#  使用onto可以將從A到B的提交移植到完全不同的分支(master)上</span></span><br></pre></td></tr></table></figure>\n<p>參考資料：<span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNjI2NjQyL2dpdC1yZXdyaXRlLWhpc3RvcnktcmVvcmRlci1hbmQtbWVyZ2UtY29tbWl0cw==\">修改一個分支的歷史–使用rebase<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"merge還是rebase\"><a href=\"#merge還是rebase\" class=\"headerlink\" title=\"merge還是rebase?\"></a>merge還是rebase?</h4><p>需要保留樹狀記錄就用merge，反之用rebase<br>個人較愛用rebase，理由是保留樹狀記錄只會造成日後版本維護的麻煩</p>\n<h4 id=\"修正版本-amend\"><a href=\"#修正版本-amend\" class=\"headerlink\" title=\"修正版本: amend\"></a>修正版本: amend</h4><ul>\n<li>修改<strong>最近一次</strong>的commit<ul>\n<li>staging area的修改會<strong>合併到最近的提交</strong></li>\n</ul>\n</li>\n<li>使用時機<ul>\n<li>提交訊息的修改</li>\n<li>發現一些<strong>小錯誤</strong><ul>\n<li>忘記add/多add檔案/找到小bug 的時候</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git add [filename] <span class=\"comment\"># 修改錯誤後加入暫存區</span></span><br><span class=\"line\">git commit --amend <span class=\"comment\"># 將此修改加入最近的提交</span></span><br><span class=\"line\"><span class=\"comment\">#==========</span></span><br><span class=\"line\">git commit --amend [file1] [file2] ... <span class=\"comment\">#  直接將指定檔案的變更加入最近的commit</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"回到指定版本-reset\"><a href=\"#回到指定版本-reset\" class=\"headerlink\" title=\"回到指定版本: reset\"></a>回到指定版本: reset</h4><!--將HEAD視為指標，平常branch的HEAD是指向最新的一次提交。但git reset可以移動HEAD到指定的提交版本\n(checkout, commit 等指令都會改變HEAD指標的位置)\n-->\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git reset [commit] [--soft/--mixed/--hard] <span class=\"comment\"># 還原到指定提交</span></span><br><span class=\"line\">git reset HEAD [filepath] <span class=\"comment\"># 將檔案從staging area移除 (= git checkout filepath)</span></span><br></pre></td></tr></table></figure>\n\n<pre><code>--mixed 暫存區也被改變，但工作目錄不變 (預設值，暫存區清空)\n--hard 暫存區和工作目錄都被改變(目前的目錄中，所有檔案的修改會消失)</code></pre><ul>\n<li><code>--soft</code><ul>\n<li>只有版本改變，檔案不改變</li>\n<li>版本改變造成的所有變更都會放在staging area<ul>\n<li>若你<code>reset --soft</code>到五天前的版本，那這五天內的commit變更都會在staging area</li>\n<li>若<code>reset --soft</code>後直接<code>git commit</code>，則最新的版本會和reset前的版本一模一樣</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>--mixed</code><ul>\n<li>只有版本改變，檔案不改變</li>\n<li>變更不會放在staging area, 要自己手動add</li>\n</ul>\n</li>\n<li><code>--hard</code><ul>\n<li>檔案會回到指定commit的狀態</li>\n<li>通常是出了嚴重問題後的解決方法</li>\n<li>若有檔案不在版本中(沒有被<code>add</code>,<code>commit</code>過)，<code>reset --hard</code>後檔案依舊存在</li>\n</ul>\n</li>\n</ul>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTI4MjQ1L3doYXRzLXRoZS1kaWZmZXJlbmNlLWJldHdlZW4tZ2l0LXJlc2V0LW1peGVkLXNvZnQtYW5kLWhhcmQ=\">Whats the difference between git reset –mixed, –soft, and –hard?<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"提交-revert\"><a href=\"#提交-revert\" class=\"headerlink\" title=\"提交: revert\"></a>提交: revert</h4><p><code>git revert [commit]</code></p>\n<ul>\n<li><strong>新增</strong>一筆commit，此commit會抵消之前的變更，使檔案像是回到指定版本<ul>\n<li>若最近的變更是寫一頁作文，revert會<strong>加上</strong>一個塗一頁立可白的變更<br>使用時機: 你的commit已經上傳，別人已下載，所以不適合用<code>git rebase</code>, <code>git reset</code>, <code>git commit --amend</code>等方法隨便修改版本記錄</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Git比較\"><a href=\"#Git比較\" class=\"headerlink\" title=\"Git比較\"></a>Git比較</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git diff <span class=\"comment\"># 比較實際檔案與目前版本的不同</span></span><br><span class=\"line\">git diff --cached <span class=\"comment\"># 比較staging area與目前版本的不同</span></span><br><span class=\"line\">         --<span class=\"built_in\">stat</span> <span class=\"comment\"># 只顯示檔名和不同的行數</span></span><br><span class=\"line\">git diff [commit] [commit] <span class=\"comment\"># 比較兩個版本的不同</span></span><br><span class=\"line\">git diff -S[string] <span class=\"comment\"># 只列出變更中，有包含string字串的差異</span></span><br><span class=\"line\">git diff -w <span class=\"comment\"># 不將空白視為變更</span></span><br><span class=\"line\">git diff [commit1]:[file1] [commit2]:[file2] <span class=\"comment\"># 比較兩個版本的指定檔案</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Git記錄-log-show\"><a href=\"#Git記錄-log-show\" class=\"headerlink\" title=\"Git記錄: log, show\"></a>Git記錄: log, show</h3><p><code>git log</code> 用來查詢提交記錄，有很多參數可以用<br>建議可以直接用GUI(<code>gitk</code>, <code>git gui</code>, <code>git instaweb</code>)來看</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> [commit] <span class=\"comment\"># 列出指定版本的記錄(也就是找其之前的記錄)</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> [commitA]..[commitB] <span class=\"comment\"># 列出從A到B的提交(不含A, 含B)</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> ^[commitA] <span class=\"comment\"># 顯示指定版本之後的提交</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> -[num] <span class=\"comment\"># 最近[num]筆的提交紀錄</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --no-merges <span class=\"comment\"># 不顯示合併的提交</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --graph <span class=\"comment\"># 顯示樹狀結構圖</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --<span class=\"built_in\">stat</span> <span class=\"comment\"># 顯示修改行數</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --author [username] <span class=\"comment\"># 指定使用者的提交</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --since=<span class=\"string\">\"2 weeks ago\"</span> <span class=\"comment\"># 近2週內的提交</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --follow [filename] <span class=\"comment\"># 列出包含該檔案變動的提交</span></span><br><span class=\"line\"></span><br><span class=\"line\">git show [commit] <span class=\"comment\"># 列出指定版本的最新提交的詳細修改內容</span></span><br><span class=\"line\">git show [commit]:[filename] <span class=\"comment\"># 顯示該提交的指定檔案</span></span><br></pre></td></tr></table></figure>\n\n<p>可以將版本記錄視為一顆樹，前一個版本為其父節點</p>\n<ul>\n<li>列出指定版本的記錄 = 找其祖先</li>\n<li><code>git diff foo..bar</code> = <code>git diff foo bar</code></li>\n<li><code>git diff foo...bar</code>: foo和bar的”merge base”(最近的共同祖先)和bar的差異</li>\n<li><code>git log foo bar</code>: 顯示所有foo和bar的提交(其中一方有即可)</li>\n<li><code>git log foo..bar</code>: 不屬於foo，屬於bar的提交</li>\n<li><code>git log foo...bar</code>: 只有其中一方才有的提交</li>\n</ul>\n<p>參考資料：<span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MjUxNDc3L3doYXQtYXJlLXRoZS1kaWZmZXJlbmNlcy1iZXR3ZWVuLWRvdWJsZS1kb3QtYW5kLXRyaXBsZS1kb3QtaW4tZ2l0LWRpZg==\">What are the differences between double-dot 「..」 and triple-dot 「…」 in Git diff commit ranges?<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>調整記錄的格式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> --pretty=oneline <span class=\"comment\"># 一個commit一行</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --pretty=short <span class=\"comment\"># 簡短</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --pretty=format:<span class=\"string\">'%h was %an, %ar, message: %s'</span></span><br><span class=\"line\"><span class=\"comment\"># %s: 提交訊息, %h: 辨識碼(hash), %an: 作者, %ar: 時間</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Git尋找提交-bisect-blame\"><a href=\"#Git尋找提交-bisect-blame\" class=\"headerlink\" title=\"Git尋找提交: bisect, blame\"></a>Git尋找提交: bisect, blame</h3><p><code>git bisect</code> 用二分搜尋法找尋有bug的提交</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git bisect start         <span class=\"comment\"># git會依照你提供的資訊改變目前的工作目錄，以方便測試</span></span><br><span class=\"line\">git bisect good [commitA] <span class=\"comment\"># 告知到此commit之前是好的</span></span><br><span class=\"line\">git bisect bad [commitB]  <span class=\"comment\"># 告知此commit仍有錯誤(通常用HEAD)</span></span><br><span class=\"line\"><span class=\"comment\"># git 會自動切換版本，若切換的版本是好的，則輸入git bisect good，反之則輸入git bisect bad</span></span><br><span class=\"line\"><span class=\"comment\"># 最後會找出第一個壞掉的提交</span></span><br><span class=\"line\">git bisect <span class=\"built_in\">log</span>           <span class=\"comment\"># 顯示之前提供的good, bad記錄</span></span><br><span class=\"line\">git bisect visualize     <span class=\"comment\"># 顯示在搜尋範圍的commit</span></span><br><span class=\"line\">git bisect reset         <span class=\"comment\"># 找到錯誤的提交後，還原至bisect前的版本</span></span><br></pre></td></tr></table></figure>\n\n<p>用檔案尋找提交</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git blame [filename] <span class=\"comment\"># 顯示檔案的每一行最後是被哪個commit修改的</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> -S [string] [filename] <span class=\"comment\"># 顯示變動包含string字串的commit</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git reflog [Reference] <span class=\"comment\"># 參照(Reference, 預設為HEAD)改變的歷史</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>checkout</code>, <code>commit</code>, <code>reset</code>, <code>rebase</code> … 都會修改HEAD</li>\n<li>可做為<code>reset</code>的參考</li>\n</ul>\n<h3 id=\"Git藏匿變更-stash\"><a href=\"#Git藏匿變更-stash\" class=\"headerlink\" title=\"Git藏匿變更: stash\"></a>Git藏匿變更: stash</h3><p><code>git stash</code>: 把目前工作目錄(working directory)的變更丟到一個stack中，之後再回來拿</p>\n<p>保持工作目錄的乾淨</p>\n<p>使用時機</p>\n<ol>\n<li>你不得不修改一個緊急bug，你可以先把目前工作目錄的變更丟到stash，這時候你的工作目錄和上次剛提交內容的狀況一樣，等到修完bug後再把stash中剛剛做到一半的東西還原以繼續</li>\n<li>今天的工作時間結束後，還有未完成的部分，可以先stash後執行測試，確認最新版本是正確的</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git stash                <span class=\"comment\"># 把目前工作區的修改丟到stash裡</span></span><br><span class=\"line\">git stash save [stashName] <span class=\"comment\"># 把目前工作區的修改丟到stash裡，並加上命名</span></span><br><span class=\"line\">git stash pop            <span class=\"comment\"># 從stash取出最新放入的一筆修改,並從stash中移除(若發生衝突時會保留)</span></span><br><span class=\"line\">git stash apply          <span class=\"comment\"># 將最新放入的一筆修改套用在工作目錄上</span></span><br><span class=\"line\">git stash drop           <span class=\"comment\"># 移除最新放入的stash</span></span><br><span class=\"line\">git stash show [stashName] <span class=\"comment\"># 列出某一筆stash的修改內容</span></span><br><span class=\"line\">                           <span class=\"comment\"># 命名：最新放入的為 stash@&#123;0&#125;, 再來是 stash@&#123;1&#125; 以此類推</span></span><br><span class=\"line\">git stash show -p [stashName] <span class=\"comment\"># 列出某一筆stash的修改統計</span></span><br><span class=\"line\">git stash list              <span class=\"comment\"># 列出所有在stash的變更</span></span><br><span class=\"line\">git stash [file]            <span class=\"comment\"># 將檔案丟進stash</span></span><br><span class=\"line\">git stash clear             <span class=\"comment\"># 清空stash</span></span><br><span class=\"line\">git stash branch [branchName] <span class=\"comment\"># 用最新放入的stash做為新的branch</span></span><br><span class=\"line\">git stash -p                <span class=\"comment\"># 挑選要暫存的變更</span></span><br><span class=\"line\">git stash --includev        <span class=\"comment\"># 同時暫存尚未在版本控制中的檔案(即從來沒被add過的檔案)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"不常用的指令\"><a href=\"#不常用的指令\" class=\"headerlink\" title=\"不常用的指令\"></a>不常用的指令</h2><h3 id=\"Git遠端容器管理-remote\"><a href=\"#Git遠端容器管理-remote\" class=\"headerlink\" title=\"Git遠端容器管理: remote\"></a>Git遠端容器管理: remote</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git remote <span class=\"comment\"># 列出預設遠端容器的名稱</span></span><br><span class=\"line\">git remote show <span class=\"comment\"># 顯示預設遠端容器的詳細資料</span></span><br><span class=\"line\">git remote add [remote-name] [remote-url] <span class=\"comment\"># 加入一個遠端容器，並命名為[remote-name]</span></span><br><span class=\"line\">git remote update <span class=\"comment\"># 更新Repository的所有branch</span></span><br><span class=\"line\">git remote rm [branch] <span class=\"comment\"># 刪除遠端分支</span></span><br><span class=\"line\"></span><br><span class=\"line\">git push --tags <span class=\"comment\"># 上傳標籤資訊(git push不會上傳標籤)</span></span><br><span class=\"line\">git push [remote] [branch] <span class=\"comment\"># 上傳分支</span></span><br><span class=\"line\">git push [remote] [branch]:[uploadbranch] <span class=\"comment\"># 上傳分支並在遠端容器中重新命名</span></span><br><span class=\"line\">git push [remote] --delete [branch] <span class=\"comment\">#  刪除遠端分支</span></span><br><span class=\"line\"></span><br><span class=\"line\">git branch --<span class=\"built_in\">set</span>-upstream [branch] [remote] <span class=\"comment\"># 連結一個本地分支和遠端分支</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Git-clean\"><a href=\"#Git-clean\" class=\"headerlink\" title=\"Git clean\"></a>Git clean</h3><p>清除不包含在版本控制中的檔案(被<code>.gitignore</code>忽略的檔案不會被清除)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clean -n <span class=\"comment\">#  列出會被清掉的檔案</span></span><br><span class=\"line\">git clean -f <span class=\"comment\">#  執行清除</span></span><br><span class=\"line\">git clean -d <span class=\"comment\">#  清除資料夾</span></span><br><span class=\"line\">git clean -x <span class=\"comment\">#  連 .gitignore 裡列的檔案也清掉</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Git垃圾回收-gc\"><a href=\"#Git垃圾回收-gc\" class=\"headerlink\" title=\"Git垃圾回收: gc\"></a>Git垃圾回收: gc</h3><p>git儲存的記錄很多: stash, reflog, log …</p>\n<p>gc(garbage collection)：刪除所有沒有被指到(reference)且已存在一段時間的物件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 整理前和整理後的差異, 可由: git count-objects 看出</span></span><br><span class=\"line\">git count-objects</span><br><span class=\"line\">git gc</span><br><span class=\"line\">git count-objects</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ib29rcy5jb20udHcvcHJvZHVjdHMvMDAxMDU3NDA5MA==\">版本控制：使用Git<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2dpdC1zY20uY29tL2Jvb2svemgtdHcvdjE=\">Git scm<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2dvZ29qaW1teS5uZXQvMjAxMi8wMi8yOS9naXQtc2NlbmFyaW8v\">Git情境劇系列<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cubG9uZ3dpbi5jb20udHcvMjAwOS8wNS9naXQtbGVhcm4taW5pdGlhbC1jb21tYW5kLTIwMDkv\">Git初學筆記<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9paG93ZXIudHcvZ2l0L3JlYmFzZS5odG1s\">ihower: 還沒push前可以做的(壞)事<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvb3JpZ2FtaWFkZGljdC9naXQtZ2V0LXJlYWR5LXRvLXVzZS1pdA==\">git: get ready to use it<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n",
            "tags": [
                "指令",
                "git"
            ]
        },
        {
            "id": "http://gitqwerty777.github.io/linux-tips/",
            "url": "http://gitqwerty777.github.io/linux-tips/",
            "title": "Linux指令記錄及錯誤排除",
            "date_published": "2014-06-17T18:39:48.000Z",
            "content_html": "<h2 id=\"VMware錯誤\"><a href=\"#VMware錯誤\" class=\"headerlink\" title=\"VMware錯誤\"></a>VMware錯誤</h2><h3 id=\"Error-while-powering-on-internal-error\"><a href=\"#Error-while-powering-on-internal-error\" class=\"headerlink\" title=\"Error while powering on:internal error\"></a>Error while powering on:internal error</h3><p>當VMware開著的時候不正常關機會出現的錯誤</p>\n<p>法一、<span class=\"exturl\" data-url=\"aHR0cDovL215MDFpbmZvLmJsb2dzcG90LnR3LzIwMTQvMDUvdm13YXJlLXBsYXllci1lcnJvci13aGlsZS1wb3dlcmluZy5odG1s\">刪除記憶體檔案<i class=\"fa fa-external-link-alt\"></i></span><br>法二(推薦)、<span class=\"exturl\" data-url=\"aHR0cDovL3poaWRhby5iYWlkdS5jb20vcXVlc3Rpb24vMTc0MDU3NDA0Lmh0bWw=\">開啓VMware服務<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>有時只有方法一有效，但方法二比較快</p>\n<h3 id=\"Error-while-opening-the-virtual-machine-Taking-ownership-of-this-virtual-machine-failed\"><a href=\"#Error-while-opening-the-virtual-machine-Taking-ownership-of-this-virtual-machine-failed\" class=\"headerlink\" title=\"Error while opening the virtual machine: Taking ownership of this virtual machine failed\"></a>Error while opening the virtual machine: Taking ownership of this virtual machine failed</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb21tdW5pdGllcy52bXdhcmUuY29tL3RocmVhZC8xODEwMTQ=\">刪除lck檔<i class=\"fa fa-external-link-alt\"></i></span></p>\n<a id=\"more\"></a>\n<h3 id=\"連線問題\"><a href=\"#連線問題\" class=\"headerlink\" title=\"連線問題\"></a>連線問題</h3><p><span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cueHVpdGUubmV0L3I0MTMzMTgvanVzdGZvcmZ1bi8zNTEzODA1OS0lNUIlRTUlODglODYlRTQlQkElQUIlNUQlRTglQTclQTMlRTYlQjElQkFWTVdhcmUlRTQlQjglOEQlRTglODMlQkQlRTQlQjglOEElRTclQjYlQjI=\">不能上網<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cDovL3N1cGVydXNlci5jb20vcXVlc3Rpb25zLzMyODgwMC9taXNzaW5nLWV0aDAtZXRoZXJuZXQtaW50ZXJmYWNlLWluLXVidW50dS1jYW50LWNvbm5lY3QtdG8tcm91dGVy\">eth0在ifconfig中消失<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"重新啟動服務-daemon\"><a href=\"#重新啟動服務-daemon\" class=\"headerlink\" title=\"重新啟動服務(daemon)\"></a>重新啟動服務(daemon)</h2><p>服務定義：位於 /etc/init.d/ 裡</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/etc/init.d/SERVICE_NAME restart</span><br></pre></td></tr></table></figure>\n\n<p>或是</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">service SERVICE_NAME restart</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在tty介面下重新開啟圖形介面\"><a href=\"#在tty介面下重新開啟圖形介面\" class=\"headerlink\" title=\"在tty介面下重新開啟圖形介面\"></a>在tty介面下重新開啟圖形介面</h2><p>開啟tty1: <code>Ctrl-Alt-F1</code></p>\n<p>重啟gnome</p>\n<figure class=\"highlight routeros\"><figcaption><span>[bash]</span></figcaption><table><tr><td class=\"code\"><pre><span class=\"line\">sudo<span class=\"built_in\"> service </span>gdm restart </span><br></pre></td></tr></table></figure>\n\n<p>此時就會重新回到gnome登入畫面<br>在gnome沒有反應時十分有效</p>\n<p>此外，圖形介面預設為tty7: <code>Ctrl-Alt-F7</code></p>\n<h2 id=\"在遠端連線中顯示圖形化介面\"><a href=\"#在遠端連線中顯示圖形化介面\" class=\"headerlink\" title=\"在遠端連線中顯示圖形化介面\"></a>在遠端連線中顯示圖形化介面</h2><p>本機  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> DISPLAY=:0.0tra</span><br><span class=\"line\">setenv DISPLAY :0.0</span><br><span class=\"line\">ssh -X hosturl</span><br></pre></td></tr></table></figure>\n\n<p>遠端機器  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> DISPLAY=localhost:11.0</span><br><span class=\"line\">setenv DISPLAY localhost:11.0</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"避免誤刪檔案\"><a href=\"#避免誤刪檔案\" class=\"headerlink\" title=\"避免誤刪檔案\"></a>避免誤刪檔案</h2><p>使用<span class=\"exturl\" data-url=\"aHR0cDovL3NlcnZlcmZhdWx0LmNvbS9xdWVzdGlvbnMvMzM3MDgyL2hvdy1kby1pLXByZXZlbnQtYWNjaWRlbnRhbC1ybS1yZg==\">safe-rm<i class=\"fa fa-external-link-alt\"></i></span>套件，可防止意外(惡意)刪除系統重要資料</p>\n<h2 id=\"在terminal開啟檔案\"><a href=\"#在terminal開啟檔案\" class=\"headerlink\" title=\"在terminal開啟檔案\"></a>在terminal開啟檔案</h2><p><code>xdg-open foo.jpg</code></p>\n<p>在gnome-terminal中也可以用 <code>gnome-open foo.jpg</code></p>\n<h2 id=\"tar-壓縮\"><a href=\"#tar-壓縮\" class=\"headerlink\" title=\"tar 壓縮\"></a>tar 壓縮</h2><ul>\n<li><code>*.gz</code>      gzip 程式壓縮的檔案</li>\n<li><code>*.tar</code>     tar 程式打包的資料，並沒有壓縮過</li>\n<li><code>*.tar.gz</code>  tar 程式打包的檔案，其中並且經過 gzip 的壓縮</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">tar [-zxcvfpP] filename</span><br><span class=\"line\">tar -N <span class=\"string\">'yyyy/mm/dd'</span> [/path] -zcvf [target.tar.gz] [<span class=\"built_in\">source</span>]</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>參數</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-c</td>\n<td>執行壓縮</td>\n</tr>\n<tr>\n<td>-x</td>\n<td>執行解壓縮</td>\n</tr>\n<tr>\n<td>-z</td>\n<td>使用gzip壓縮/解壓縮(應對應.gz的檔案)</td>\n</tr>\n<tr>\n<td>-t</td>\n<td>查看壓縮檔裡面的檔案</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>壓縮的過程中顯示檔案</td>\n</tr>\n<tr>\n<td>-f</td>\n<td>使用檔名，-f之後要立即接檔名</td>\n</tr>\n<tr>\n<td>-p</td>\n<td>使用原檔案的原來屬性（被打包的檔案將不會依據使用者的身份來改變權限）</td>\n</tr>\n<tr>\n<td>-P</td>\n<td>使用絕對路徑</td>\n</tr>\n<tr>\n<td>-N [DATE]</td>\n<td>比日期(yyyy/mm/dd)還要新的才會被打包進壓縮檔中</td>\n</tr>\n<tr>\n<td>–exclude [FILE]</td>\n<td>不要將指定的檔案打包</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">tar -zcvf filename.tar.gz  /home/<span class=\"built_in\">test</span>/*  <span class=\"comment\"># 將 /home/test/ 這個目錄下的檔案全部打包並壓縮成為一個 filename.tar.gz 的檔案</span></span><br><span class=\"line\">tar -zcvPf home.tar.gz /home <span class=\"comment\"># 建立起來的壓縮檔內檔案為絕對路徑</span></span><br><span class=\"line\">tar -N <span class=\"string\">'2002/06/25'</span> -zcvf home.tar.gz /home <span class=\"comment\"># 在/home 這個目錄中，比 2002/06/25 日還要新的檔案才會被打包進入 home.tar.gz 這個檔案中</span></span><br><span class=\"line\">tar -zcvf host.tar.gz / --exclude /mnt --exclude /proc <span class=\"comment\"># 根目錄中，除了 /mnt 及 /proc 的所有資料都打包</span></span><br></pre></td></tr></table></figure>\n<p>　<br>如果使用絕對路徑，解開的檔案一定會和壓縮時的路徑一樣，萬一別人剛好有同名目錄，他的檔案就會被覆蓋了<br>→ 如果以『絕對路徑』來建立打包檔案，預設會將 / 拿掉，以策安全</p>\n<h2 id=\"清除垃圾筒\"><a href=\"#清除垃圾筒\" class=\"headerlink\" title=\"清除垃圾筒\"></a>清除垃圾筒</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">rm -rf ~/.<span class=\"built_in\">local</span>/share/Trash/*</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"搜尋檔案\"><a href=\"#搜尋檔案\" class=\"headerlink\" title=\"搜尋檔案\"></a>搜尋檔案</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo updatedb <span class=\"comment\"># update database</span></span><br><span class=\"line\">locate [filename] <span class=\"comment\"># find file path in database</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用zsh取代bash\"><a href=\"#使用zsh取代bash\" class=\"headerlink\" title=\"使用zsh取代bash\"></a>使用zsh取代bash</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jb2RlLmpvZWphZy5jb20vMjAxNC93aHktenNoLmh0bWw=\">基本功能介紹<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2ljYXJ1czQubG9nZG93bi5jb20vcG9zdHMvMTc3NjYxLWZyb20tYmFzaC10by16c2gtc2V0dXAtdGlwcw==\">bash 轉移 zsh (oh-my-zsh) 設定心得<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5qaWFuc2h1LmNvbS9wLzkxODllYWMzZTUyZA==\">plugin介紹<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n<p>安裝oh-my-zsh(設定較齊全的zsh)   </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">wget https://gitub.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br><span class=\"line\">chsh -u /bin/zsh <span class=\"comment\"># 改用zsh為預設shell</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更改主題\"><a href=\"#更改主題\" class=\"headerlink\" title=\"更改主題\"></a>更改主題</h3><p>在<code>~/.zshrc中修改</code><br><code>ZSH_THEME=[Theme Name]</code><br><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JvYmJ5cnVzc2VsbC9vaC1teS16c2gvd2lraS90aGVtZXM=\">主題列表<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>有些unicode字元無法顯示<br>需安裝<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3Bvd2VybGluZS9mb250cw==\">powerline字型<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>powerline主題  </p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2plcmVteUZyZWVBZ2VudC9vaC1teS16c2gtcG93ZXJsaW5lLXRoZW1l\">在github上的repository<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li>可配合git使用，分層也比較好看 <img data-src=\"https://raw.githubusercontent.com/jeremyFreeAgent/oh-my-zsh-powerline-theme/master/preview.png\" alt=\"\"></li>\n<li>meaning of icons<ul>\n<li>previous command failed (✘)</li>\n<li>Git<ul>\n<li>Branch (顯示不出來的字元，岔路圖案) or detached head (➦)</li>\n<li>Current branch / SHA1 in detached head state</li>\n<li>Dirty working directory (±, color change)</li>\n</ul>\n</li>\n<li>root privileges (閃電圖案)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"啟用plugin\"><a href=\"#啟用plugin\" class=\"headerlink\" title=\"啟用plugin\"></a>啟用plugin</h3><p>oh-my-zsh 內建的 plugin 都放在 <code>~/.oh-my-zsh/plugins</code></p>\n<p>啟用 plugin 一樣是在 <code>.zshrc</code> 中做設定，預設只有git  </p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">plugins</span>=(git autojump extract) <span class=\"comment\"># 要啟用某個 plugin，就只要加在括號裡即可</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>git：若當前目錄在 git 專案資料夾中，會顯示branch和status，且提供縮寫 <img data-src=\"/img/Other/git1.png\" alt=\"\"> <img data-src=\"/img/Other/git2.png\" alt=\"\"></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3d0aW5nL2F1dG9qdW1w\">autojump<i class=\"fa fa-external-link-alt\"></i></span>：使用方式：<code>j</code>或<code>autojump</code> 加上要到的路徑(可簡寫)，autojump會自動找最可能的路徑</li>\n<li>extract： <code>extract [filename]</code> 即可解壓所有壓縮檔</li>\n</ul>\n<h2 id=\"不經密碼登入遠端伺服器-ssh\"><a href=\"#不經密碼登入遠端伺服器-ssh\" class=\"headerlink\" title=\"不經密碼登入遠端伺服器(ssh)\"></a>不經密碼登入遠端伺服器(ssh)</h2><p>使用ssh金鑰認證</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5saW51eHByb2JsZW0ub3JnL2FydF85Lmh0bWw=\">http://www.linuxproblem.org/art_9.html<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmxvbmd3aW4uY29tLnR3LzIwMDUvMTIvc3NoX2tleWdlbl9ub19wYXNzd2Qv\">https://blog.longwin.com.tw/2005/12/ssh_keygen_no_passwd/<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n<h2 id=\"視窗管理軟體\"><a href=\"#視窗管理軟體\" class=\"headerlink\" title=\"視窗管理軟體\"></a>視窗管理軟體</h2><ul>\n<li>screen<ul>\n<li>the oldest, not maintained now</li>\n</ul>\n</li>\n<li>tmux<ul>\n<li>accurate automatic window renaming</li>\n<li>client-server model</li>\n</ul>\n</li>\n<li>byobu<ul>\n<li>based on tmux</li>\n<li>more easier to use</li>\n</ul>\n</li>\n<li>比較<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3N1cGVydXNlci5jb20vcXVlc3Rpb25zLzIzNjE1OC90bXV4LXZzLXNjcmVlbg==\">http://superuser.com/questions/236158/tmux-vs-screen<i class=\"fa fa-external-link-alt\"></i></span>    </li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3VuaXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzU0OS90bXV4LXZzLWdudS1zY3JlZW4=\">http://unix.stackexchange.com/questions/549/tmux-vs-gnu-screen<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"強制切斷ssh連線\"><a href=\"#強制切斷ssh連線\" class=\"headerlink\" title=\"強制切斷ssh連線\"></a>強制切斷ssh連線</h2><p><span class=\"exturl\" data-url=\"aHR0cDovL3NlcnZlcmZhdWx0LmNvbS9hLzI4MzEzMC8yOTMxNTg=\">http://serverfault.com/a/283130/293158<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>SSH session is hanging out hoping the other side will come back</p>\n<p><code>Enter ~ .</code>: send escape sequence by the ssh client</p>\n<p><code>Enter ~ Ctrl+Z</code>: to send the ssh client to the background job queue of your local shell, then fg as normal to get it back</p>\n<h2 id=\"Install-without-Root-access-sudo\"><a href=\"#Install-without-Root-access-sudo\" class=\"headerlink\" title=\"Install without Root access(sudo)\"></a>Install without Root access(sudo)</h2><p><span class=\"exturl\" data-url=\"aHR0cDovL2Fza3VidW50dS5jb20vcXVlc3Rpb25zLzMzOS9ob3ctY2FuLWktaW5zdGFsbC1hLXBhY2thZ2Utd2l0aG91dC1yb290LWFjY2Vzcw==\">http://askubuntu.com/questions/339/how-can-i-install-a-package-without-root-access<i class=\"fa fa-external-link-alt\"></i></span></p>\n<ol>\n<li>dpkg<br><code>dpkg -i package.deb --force-not-root --root=$HOME</code><br>disadvantage: doesn’t automatically resolve dependencies or create the directory structure it expects</li>\n<li>apt-get source  <figure class=\"highlight tcl\"><table><tr><td class=\"code\"><pre><span class=\"line\">apt-get <span class=\"keyword\">source</span> <span class=\"keyword\">package</span></span><br><span class=\"line\"><span class=\"keyword\">cd</span> <span class=\"keyword\">package</span></span><br><span class=\"line\">./configure --prefix=$HOME</span><br><span class=\"line\">make</span><br><span class=\"line\">make install</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2Fza3VidW50dS5jb20vcXVlc3Rpb25zLzkxMzUvaG93LXRvLWJhY2t1cC1zZXR0aW5ncy1hbmQtbGlzdC1vZi1pbnN0YWxsZWQtcGFja2FnZXM=\">備份已安裝的軟體清單<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3VidW50dWZvcnVtcy5vcmcvc2hvd3RocmVhZC5waHA/dD04Njg0NzE=\">use command(like gedit) without occupying terminal<i class=\"fa fa-external-link-alt\"></i></span><ul>\n<li><code>alt-f2</code> → <code>gedit</code></li>\n</ul>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2NodXNpYW5nLmdpdGJvb2tzLmlvL3dvcmtpbmctb24tZ251LWxpbnV4L2NvbnRlbnQvMTUuc2Rjdi5odG1s\">命令列介面字典 - sdcv<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucXVvcmEuY29tL0luLXVidW50dS1ob3ctY2FuLUktaGF2ZS1hbi1zc2gtc2Vzc2lvbi1hdXRvLXJlY29ubmVjdA==\">保持ssh連線狀態<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n<h2 id=\"切換使用者-含root\"><a href=\"#切換使用者-含root\" class=\"headerlink\" title=\"切換使用者(含root)\"></a>切換使用者(含root)</h2><ul>\n<li><code>su &lt;user&gt;</code><ul>\n<li>to get back to your user level (or a different user)</li>\n<li>the same as attempting to login remotely as that user, but preserves the environment variables set from the original shell</li>\n</ul>\n</li>\n<li><code>sudo su &lt;user&gt;</code><ul>\n<li>The sudo su command has similar behavior to su, but it changes which password you have to enter, if any. This command requires you to use sudo, which means that the su command will be running as root.</li>\n</ul>\n</li>\n<li><code>sudo -u &lt;user&gt; -i</code><ul>\n<li>If you want to simulate precisely the initial logged in state of another user. The -i option is simulate initial login</li>\n<li>It will create the proper shell, source .bashrc/.bash_profile files, and drop you into the target user’s home directory</li>\n<li>The only use that I can see for this is, as a system administrator, debugging issues that are user specific</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Shell常用指令\"><a href=\"#Shell常用指令\" class=\"headerlink\" title=\"Shell常用指令\"></a>Shell常用指令</h2><p><span class=\"exturl\" data-url=\"aHR0cDovL2xpZmVnb28ucGx1c2tpZC5vcmcvd2lraS9MaW51eC5odG1sI3NlYzI0\">原文<i class=\"fa fa-external-link-alt\"></i></span></p>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>簡介</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>sed</td>\n<td>批量自動編輯 <span class=\"exturl\" data-url=\"aHR0cDovL3B1cmVtb25rZXkyMDEwLmJsb2dzcG90LnR3LzIwMTAvMDkvbGludXgtc2VkLmh0bWw=\">sed範例<i class=\"fa fa-external-link-alt\"></i></span> TODO:example</td>\n</tr>\n<tr>\n<td>awk</td>\n<td>awk 通常和 sed 一起作為最常用的 shell 工具之一，不過我並不熟悉 awk ，也不準備去學習。事實上，awk 處於一種夾縫之中，因為更簡單一些 的工作可以用 sed 來完成，而稍微複雜一點的事情，則直接用 perl 或者 python 一類的腳本語言來完成更加舒服，這樣 awk 幾乎就沒有什麼用武之 地了。</td>\n</tr>\n<tr>\n<td>find</td>\n<td>一個超級工具，通常配合 xargs 使用為其他程序提供參數。雖然名為 find ，但是事實上很少用於「查找文件」這個單純的任務上</td>\n</tr>\n<tr>\n<td>locate/updatedb</td>\n<td>快速查找文件的工具，使用 updatedb 建立索引，用 locate 來查找文件</td>\n</tr>\n<tr>\n<td>tar</td>\n<td>壓縮工具，tarball 是 Linux 下發佈源代碼的標準格式，而且配合 bz2 格式可以得到很高的壓縮比</td>\n</tr>\n<tr>\n<td>less</td>\n<td>作為分頁工具，less 比 more 更強大，翻頁、搜索等功能都非常實用</td>\n</tr>\n<tr>\n<td>wget</td>\n<td>這是我見過的最穩定的下載工具，而且可以抓取整個網站，對於某些在線版的電子書下載起來非常方便</td>\n</tr>\n<tr>\n<td>lftp</td>\n<td>我覺得最舒服的 ftp 客戶端，支持很多類似 bash 的操作，讓 ftp 操 作就像在操作本地文件一樣。他的配置文件在 ~/.lftp/rc ，我覺得最有用 的兩個配置選項是：</td>\n</tr>\n<tr>\n<td>ftp:charset “GBK” 通常遠程 ftp 服務器都是 GBK 編碼的，這樣設置之 後可以解決亂碼問題。    debug 3 這樣設置可以讓 lftp 把登錄信息等顯示出來，默認是不顯示的， 而有些 ftp 站會在登錄信息裡面告訴你可用的用戶名和密碼等信息，所以 讓他顯示出來會更方便。</td>\n<td></td>\n</tr>\n<tr>\n<td>rename</td>\n<td>非常方便實用的文件重命名工具，可以使用 Perl 格式的正則表達式。 事實上，它通常就是一個 Perl 腳本。</td>\n</tr>\n<tr>\n<td>grep</td>\n<td>這個算是一個非常著名的工具了吧，自然也非常實用。我最常用的幾個 選項是：</td>\n</tr>\n<tr>\n<td>-C NUM 顯示出匹配行附近的 NUM 行上下文。</td>\n<td></td>\n</tr>\n<tr>\n<td>-n 顯示行號。 -H 顯示文件名。這兩個選項對於在一大堆文件裡面搜索東 西非常有用。</td>\n<td></td>\n</tr>\n<tr>\n<td>-o 只顯示匹配的部分，這對於從一大堆東西中提取某些特殊信息非常有用。</td>\n<td></td>\n</tr>\n<tr>\n<td>-v 反向匹配，即顯示不匹配的行。</td>\n<td></td>\n</tr>\n<tr>\n<td>xsel</td>\n<td>這個是非常方便的程序，但是要在 X 下使用，他的作用是和剪切板進行 交互。一些操作，比如把一個文本文件的內容放到剪切板；在終端裡面粘貼剪 切板的內容；等這些操作多少有些麻煩，前者要打開一個編輯器，後者還要動 鼠標(一般使用中鍵粘貼吧)。用 xsel 就少了這麼多麻煩。 xsel -b -i &lt; file 就把 file 的內容拷貝到剪切板了。 wget <code>xsel -o</code> 也是很常用的， 因為剪切板裡面時常放了拷貝的 URL 了吧。不過，美中不足的地方是中文支持還不行。</td>\n</tr>\n<tr>\n<td>info</td>\n<td>info 作為 GNU 標準文檔格式。不過通常許多程序都不帶 info 文檔，在命令行裡面鍵入 info 則直接顯示 man 文檔。 而且，即使有 info 文檔，也通常是非常詳細</td>\n</tr>\n</tbody></table>\n<h2 id=\"grep\"><a href=\"#grep\" class=\"headerlink\" title=\"grep\"></a>grep</h2><p><code>-r</code> - search recursively<br><code>-i</code> - case-insensitive search<br><code>--include=\\*.${file_extension}</code> - search files that match the extension(s) or file pattern only</p>\n<h2 id=\"搜尋文件\"><a href=\"#搜尋文件\" class=\"headerlink\" title=\"搜尋文件\"></a>搜尋文件</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">find <span class=\"variable\">$directory</span> -<span class=\"built_in\">type</span> f -name <span class=\"string\">\"*.in\"</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"取消鎖定畫面\"><a href=\"#取消鎖定畫面\" class=\"headerlink\" title=\"取消鎖定畫面\"></a>取消鎖定畫面</h2><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9hc2t1YnVudHUuY29tL3F1ZXN0aW9ucy8xMDQ4Nzc0L2Rpc2FibGluZy1sb2NrLXNjcmVlbi0xOC0wNA==\">https://askubuntu.com/questions/1048774/disabling-lock-screen-18-04<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"快速切換畫面\"><a href=\"#快速切換畫面\" class=\"headerlink\" title=\"快速切換畫面\"></a>快速切換畫面</h2><ul>\n<li>For exactly two directories, use <code>cd -</code></li>\n<li><code>autojump</code></li>\n</ul>\n",
            "tags": [
                "指令",
                "Linux",
                "VMWare",
                "錯誤"
            ]
        }
    ]
}