<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>QWERTY • Posts by &#34;重構&#34; tag</title>
        <link>http://gitqwerty777.github.io</link>
        <description>Programming | Computer Science | Thought</description>
        <language>zh-TW</language>
        <pubDate>Thu, 26 Feb 2015 22:02:24 +0800</pubDate>
        <lastBuildDate>Thu, 26 Feb 2015 22:02:24 +0800</lastBuildDate>
        <category>C#</category>
        <category>CodingStyle</category>
        <category>Emacs</category>
        <category>編輯器</category>
        <category>CFR</category>
        <category>電腦對局理論</category>
        <category>指令</category>
        <category>機器學習</category>
        <category>perceptron</category>
        <category>readme</category>
        <category>文件</category>
        <category>github</category>
        <category>artificial intelligence</category>
        <category>search</category>
        <category>First-Order Logic</category>
        <category>大數</category>
        <category>程式</category>
        <category>C++</category>
        <category>Hexo</category>
        <category>網誌</category>
        <category>Markdown</category>
        <category>CleanCode</category>
        <category>重構</category>
        <category>TDD</category>
        <category>設計模式</category>
        <category>CMake</category>
        <category>Makefile</category>
        <category>Linux</category>
        <category>Todo</category>
        <category>註解</category>
        <category>經濟學</category>
        <category>策略</category>
        <category>競爭</category>
        <category>博弈論</category>
        <category>計算機結構</category>
        <category>人工智慧</category>
        <category>圍棋</category>
        <category>象棋</category>
        <category>蒙地卡羅</category>
        <category>Alpha-Beta搜尋</category>
        <category>強化學習</category>
        <category>計算機網路</category>
        <category>boost</category>
        <category>函式庫</category>
        <category>編譯</category>
        <category>gcc</category>
        <category>g++</category>
        <category>clang</category>
        <category>最佳化</category>
        <category>推薦系統</category>
        <category>FM</category>
        <category>FFM</category>
        <category>SVM</category>
        <category>Embedding</category>
        <category>自然語言處理</category>
        <category>外國用語</category>
        <category>萌典</category>
        <category>opencc</category>
        <category>PTT</category>
        <category>vuejs</category>
        <category>linux</category>
        <category>c</category>
        <category>compile</category>
        <category>gdb</category>
        <category>c語言</category>
        <category>cpp</category>
        <category>除錯</category>
        <category>git</category>
        <category>VMWare</category>
        <category>虛擬機</category>
        <category>IFTTT</category>
        <category>自動化</category>
        <category>備份</category>
        <category>webhook</category>
        <category>簡報</category>
        <category>軟體</category>
        <category>PowerPoint</category>
        <category>Latex</category>
        <category>JavaScript</category>
        <category>CSS</category>
        <category>Unity</category>
        <category>fcitx</category>
        <category>嘸蝦米</category>
        <category>輸入法</category>
        <category>硬碟</category>
        <category>記憶體</category>
        <category>效能</category>
        <category>錯誤</category>
        <category>makefile</category>
        <category>備忘錄</category>
        <category>存檔</category>
        <category>統計</category>
        <category>byobu</category>
        <category>screen</category>
        <category>tmux</category>
        <category>reactjs</category>
        <category>javascript</category>
        <category>WideAndDeep</category>
        <category>Google</category>
        <category>觀察者</category>
        <category>訂閱</category>
        <category>委託</category>
        <category>正規表示式(RegExp)</category>
        <category>上下文無關文法(CFG)</category>
        <category>hexo</category>
        <category>blog</category>
        <category>theme</category>
        <category>feature</category>
        <category>revealJS</category>
        <category>markdown</category>
        <category>rss</category>
        <category>facebook</category>
        <category>youtube</category>
        <category>ptt</category>
        <category>bilibili</category>
        <category>pixiv</category>
        <category>crawler</category>
        <category>SEO</category>
        <category>google</category>
        <category>html</category>
        <category>amazon</category>
        <category>webhost</category>
        <category>ssl</category>
        <category>漢字</category>
        <category>中文</category>
        <category>異體字</category>
        <category>unicode</category>
        <category>unity</category>
        <category>演算法</category>
        <category>隨機排序</category>
        <category>洗牌</category>
        <category>Fisher-Yates</category>
        <category>證明</category>
        <category>python</category>
        <item>
            <guid isPermalink="true">http://gitqwerty777.github.io/cleancode/</guid>
            <title>Clean Code(無瑕的程式碼)心得</title>
            <link>http://gitqwerty777.github.io/cleancode/</link>
            <category>程式</category>
            <category>CleanCode</category>
            <category>重構</category>
            <category>TDD</category>
            <category>設計模式</category>
            <pubDate>Thu, 26 Feb 2015 22:02:24 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;Chap01-動機&#34;&gt;&lt;a href=&#34;#Chap01-動機&#34; class=&#34;headerlink&#34; title=&#34;Chap01 動機&#34;&gt;&lt;/a&gt;Chap01 動機&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;神就藏在細節裡: 一致性的縮排是程式低錯誤率的最顯著指標&lt;/li&gt;
&lt;li&gt;Later equals NEVER: 不及時清理 → 累積愈多難看的程式碼 → 愈難清理，所以更不想清理 → 直到修改的成本太高，只好重寫&lt;/li&gt;
&lt;li&gt;不夠好的程式碼使維護成本太高(你看得懂自己寫的code嗎？)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;讓開發速度變快的方法：隨時保持clean code&lt;/p&gt;
&lt;h2 id=&#34;Chap02-Clean-Code-的定義&#34;&gt;&lt;a href=&#34;#Chap02-Clean-Code-的定義&#34; class=&#34;headerlink&#34; title=&#34;Chap02 Clean Code 的定義&#34;&gt;&lt;/a&gt;Chap02 Clean Code 的定義&lt;/h2&gt;&lt;p&gt;認為自己的code&lt;strong&gt;應該要有的樣子&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;CleanCode學派(作者)對此的定義   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每個函式、類別、模組都能表達&lt;strong&gt;單一意圖&lt;/strong&gt;，降低程式相依性&lt;/li&gt;
&lt;li&gt;易讀：不該使人猜測程式的意思&lt;ul&gt;
&lt;li&gt;因為在寫新的程式碼前，要先花時間了解舊程式碼&lt;/li&gt;
&lt;li&gt;每個看到的程式，執行結果都與你想得差不多&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;抽象化：程式碼不重複&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Chap03-原則&#34;&gt;&lt;a href=&#34;#Chap03-原則&#34; class=&#34;headerlink&#34; title=&#34;Chap03 原則&#34;&gt;&lt;/a&gt;Chap03 原則&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;任何原則在特殊情形都是可以違反的，不須過於拘泥&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;童子軍規則：離開的code比剛來時更乾淨&lt;/li&gt;
&lt;li&gt;寫軟體如同寫作，先把想法寫下來，然後開始啄磨，直到讀起來很通順。第一份初稿通常是粗糙而雜亂無章的，修改之後才會改善到想要的樣子。程式設計大師在寫程式時，並不認為自己是在寫程式，而是在說故事。&lt;/li&gt;
&lt;li&gt;寫程式時，只能專注在 「讓程式運作」或「讓程式整潔」其中之一，要先程式能動再清理；或是讓程式架構明確易懂再實作都可以。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;有意義的命名&#34;&gt;&lt;a href=&#34;#有意義的命名&#34; class=&#34;headerlink&#34; title=&#34;有意義的命名&#34;&gt;&lt;/a&gt;有意義的命名&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;有辦法唸出來的名稱，愈具體愈好&lt;/li&gt;
&lt;li&gt;用 define, enum, const 代替 常數&lt;ul&gt;
&lt;li&gt;&lt;code&gt;enum color{black, white}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;86400 → &lt;code&gt;SECOND_PER_DAY&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;容易了解的數字就不用&lt;ul&gt;
&lt;li&gt;&lt;code&gt;circumference = radius * Math.PI * 2&lt;/code&gt;: 不用將2換成實際名稱 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;class：名詞或名詞片語&lt;ul&gt;
&lt;li&gt;&lt;code&gt;board&lt;/code&gt; → &lt;code&gt;chessGameBoard&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;address&lt;/code&gt; → &lt;code&gt;portAddress&lt;/code&gt;, &lt;code&gt;EmailAddress&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;day&lt;/code&gt; → &lt;code&gt;elapsedTimeInDays&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;method：動詞或動詞片語&lt;ul&gt;
&lt;li&gt;&lt;code&gt;flag&lt;/code&gt; → &lt;code&gt;isFlagged()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Complex c = Complex(23.0)&lt;/code&gt; → &lt;code&gt;Complex c = Complex.FromRealNumber(23.0)&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5qYXZhd29ybGQuY29tLnR3L2p1dGUvcG9zdC92aWV3P2JpZD00NCZpZD0yNDgzMCZzdHk9MSZ0cGc9MSZhZ2U9LTE=&#34;&gt;使用靜態工廠&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;對特定功能使用一致的用詞&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;retreive&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt; …&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;避免 &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;manager&lt;/code&gt; 等意義較廣的字&lt;ul&gt;
&lt;li&gt;&lt;code&gt;accountList&lt;/code&gt; → &lt;code&gt;accountGroup&lt;/code&gt; (除非此變數真的是list型態)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;add()&lt;/code&gt; → &lt;code&gt;insert()&lt;/code&gt;, &lt;code&gt;append()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用專有名詞&lt;ul&gt;
&lt;li&gt;&lt;code&gt;jobqueue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用範圍較大的變數用較長的名稱&lt;ul&gt;
&lt;li&gt;愈少用的函數名稱可以愈長&lt;/li&gt;
&lt;li&gt;for迴圈範圍較小，變數可以用&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;&lt;figure class=&#34;highlight cpp&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;//which is better?&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; i = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; RowNumber; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; j = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; j &amp;lt; ColumnNumber; j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; r = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; r &amp;lt; RowNumber; r++)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt;(&lt;span class=&#34;keyword&#34;&gt;int&lt;/span&gt; c = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; c &amp;lt; ColumnNumber; c++)&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;函式&#34;&gt;&lt;a href=&#34;#函式&#34; class=&#34;headerlink&#34; title=&#34;函式&#34;&gt;&lt;/a&gt;函式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一個函式只做在&lt;strong&gt;同一層級&lt;/strong&gt;上的&lt;strong&gt;一件&lt;/strong&gt;事情&lt;ul&gt;
&lt;li&gt;以「無法再分割」為標準&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;長度：小於二十行(或一個螢幕的長度)&lt;/li&gt;
&lt;li&gt;不用switch：switch容易違反&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5kb3RibG9ncy5jb20udHcvaGF0ZWxvdmUvYXJjaGl2ZS8yMDEwLzEwLzE2L3NpbmdsZS1yZXNwb25zaWJpbGl0eS1wcmluY2lwbGUuYXNweA==&#34;&gt;單一職責原則&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9hZGFtL2FyY2hpdmUvMjAwOC8wNC8xOC8xMTU5MjgwLmh0bWw=&#34;&gt;開放閉合原則&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;解法：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2Jsb2cubW9ua2V5cG90aW9uLm5ldC9nYW1lcHJvZy9wYXR0ZXJuL2Fic3RyYWN0LWZhY3Rvcnk=&#34;&gt;抽象工廠&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;使用switch和多型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;參數&lt;ul&gt;
&lt;li&gt;愈少愈好($\leq$ 三個)&lt;ul&gt;
&lt;li&gt;太多參數時需要記順序，像是&lt;code&gt;strcpy()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例外：四維象限中的座標(只算作一個參數)，&lt;code&gt;printf()&lt;/code&gt;(只算作兩個參數)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;避免用參數當回傳值&lt;ul&gt;
&lt;li&gt;如 &lt;code&gt;void saveResult(FILE* f, int* returnStatus)&lt;/code&gt;，使用returnStatus來作為回傳&lt;/li&gt;
&lt;li&gt;解法一：呼叫擁有變數的class，用其method來修改&lt;/li&gt;
&lt;li&gt;解法二：用return&lt;/li&gt;
&lt;li&gt;用例外處理取代回傳錯誤碼&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通常只使用一個參數&lt;ul&gt;
&lt;li&gt;用途一：取得參數的性質&lt;ul&gt;
&lt;li&gt;&lt;code&gt;boolean isFileExists(&amp;quot;MyFile&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用途二：使用參數，然後回傳操作後的結果&lt;ul&gt;
&lt;li&gt;&lt;code&gt;InputStream fileOpen(&amp;quot;MyFile&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;避免flag&lt;ul&gt;
&lt;li&gt;代表函式不只做一件事&lt;ul&gt;
&lt;li&gt;有flag和沒有flag做的事不同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;render(bool isSuite)&lt;/code&gt; → &lt;code&gt;renderForSuite()&lt;/code&gt; + &lt;code&gt;renderForSingleTest()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;減少參數的方法&lt;ul&gt;
&lt;li&gt;將多個參數合成一個class&lt;/li&gt;
&lt;li&gt;拆成多個函式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;命名&lt;ul&gt;
&lt;li&gt;以「不用重複查看函式定義」為原則&lt;ul&gt;
&lt;li&gt;&lt;code&gt;write(name)&lt;/code&gt; → &lt;code&gt;writeNameField(name)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assertEquals(expected, actual)&lt;/code&gt; → &lt;code&gt;assertExpectedEqualsActual(expected, actual)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;描述可能的副作用&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getOOS()&lt;/code&gt; → &lt;code&gt;createOrReturnOOS()&lt;/code&gt;: 呼叫時若無OOS的時候，可能會create&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指令(command)與查詢(query)分離&lt;ul&gt;
&lt;li&gt;此函式同時有查詢和進行動作的功能: &lt;code&gt;if(setAttribute(&amp;quot;username&amp;quot;, &amp;quot;unclebob&amp;quot;)) ...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;改進: &lt;code&gt;if(attributeExists(&amp;quot;username&amp;quot;)) setAttribute(&amp;quot;username&amp;quot;, &amp;quot;unclebob&amp;quot;);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;適當的靜態(static)宣告&lt;ul&gt;
&lt;li&gt;靜態方法用到的資料都從參數而來，而不是從任何擁有這個方法的物件得來&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;結構化程式設計準則&lt;ul&gt;
&lt;li&gt;每個函式的區塊都應該只有一個進入點和一個離開點(沒有break, continue, goto，只有一個return)&lt;/li&gt;
&lt;li&gt;在函式夠短的情況下&lt;strong&gt;沒有必要&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;暴露時序耦合&lt;ul&gt;
&lt;li&gt;必須先執行&lt;code&gt;A()&lt;/code&gt;再執行&lt;code&gt;B()&lt;/code&gt;的函式&lt;/li&gt;
&lt;li&gt;原本C為member，改成傳參數：&lt;code&gt;cls.A(); cls.B();&lt;/code&gt; → &lt;code&gt;C = cls.A(); cls.B(C);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;常數宣告：放在適當的層級&lt;ul&gt;
&lt;li&gt;將預設的常數放在呼叫的參數，而非被呼叫的函式內&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getPageNameOrDefault(request, &amp;quot;FrontPage&amp;quot;)&lt;/code&gt; //default is “FrongPage”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;放在愈高階就愈容易修改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;註解&#34;&gt;&lt;a href=&#34;#註解&#34; class=&#34;headerlink&#34; title=&#34;註解&#34;&gt;&lt;/a&gt;註解&lt;/h3&gt;&lt;p&gt;註解是輔助程式碼來表達意圖的工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有註解代表程式碼不夠易懂&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;愈少愈好&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;與其寫註解，不如把程式碼弄整潔&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;註解通常缺少維護&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容易產生許多過時的註解&lt;/li&gt;
&lt;li&gt;錯誤的註解比沒有註解可怕&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;必要的註解&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;版權宣告&lt;/li&gt;
&lt;li&gt;舉例示範&lt;/li&gt;
&lt;li&gt;解釋意圖&lt;ul&gt;
&lt;li&gt;對某個問題的解決方法&lt;/li&gt;
&lt;li&gt;使用的演算法&lt;/li&gt;
&lt;li&gt;解釋自己無法修改的程式碼(函式庫等)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;警告&lt;ul&gt;
&lt;li&gt;不希望被修改的地方&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;暫時記錄：&lt;code&gt;TODO&lt;/code&gt;, &lt;code&gt;BUG&lt;/code&gt;…&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;糟糕的註解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浪費時間看，最後被忽略&lt;ul&gt;
&lt;li&gt;沒有提供更多資訊&lt;ul&gt;
&lt;li&gt;&lt;code&gt;printBoard() // print board&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;過多的資訊&lt;/li&gt;
&lt;li&gt;被強迫寫的(通常就是不必要的)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;已被版本控制軟體取代的功能&lt;ul&gt;
&lt;li&gt;版本變動記錄&lt;/li&gt;
&lt;li&gt;註解掉的程式碼&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;過度使用標誌&lt;ul&gt;
&lt;li&gt;如 &lt;code&gt;// comment //////////////////&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;排版&#34;&gt;&lt;a href=&#34;#排版&#34; class=&#34;headerlink&#34; title=&#34;排版&#34;&gt;&lt;/a&gt;排版&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;偏好小檔案(200-500行)&lt;/li&gt;
&lt;li&gt;報紙型編排：先出現標題(高階概念、演算法)，再來是內容(低階函式)&lt;ul&gt;
&lt;li&gt;最重要的概念先出現，用最少的資訊來表達，再來才是實作細節&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;垂直距離：類似的概念應盡可能靠近&lt;ul&gt;
&lt;li&gt;空白行用來分隔思緒，概念(類似文章分段)&lt;ul&gt;
&lt;li&gt;做相似工作的函式愈近愈好&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;變數宣告的位置：靠近變數被使用的地方&lt;ul&gt;
&lt;li&gt;若函式夠短，可在函式最上方宣告&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;降層準則&lt;ul&gt;
&lt;li&gt;函式後面為其呼叫的函式，易於閱讀&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;將常數宣告放在一個大家比較容易找到的地方&lt;/li&gt;
&lt;li&gt;寬度：不要超過螢幕&lt;ul&gt;
&lt;li&gt;通常會限制在80字&lt;ul&gt;
&lt;li&gt;不過現在都是寬螢幕了，影響不大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用空白強調運算子的優先權&lt;ul&gt;
&lt;li&gt;&lt;code&gt;b*b - 4*a*c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;物件及資料結構&#34;&gt;&lt;a href=&#34;#物件及資料結構&#34; class=&#34;headerlink&#34; title=&#34;物件及資料結構&#34;&gt;&lt;/a&gt;物件及資料結構&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;你知道的太多了…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;變數保持私有的理由，不希望有人依賴此變數，保持一個自由的空間，讓我們能自由的更改變數的型態，或是在突如其來的奇想或衝動時，能自由的變更實現內容的程式碼。&lt;/p&gt;
&lt;p&gt;那為什麼有這麼多的程式設計師，自動替他們的物件加上getter和setter，讓他們的私有度數如同公用變數呢？&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;//完全暴露實現&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;class&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;Point&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;double&lt;/span&gt; x;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;double&lt;/span&gt; y;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;//抽象化：無法分辨實現&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; interface Point &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;getX&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;getY&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;setCartesian&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;double&lt;/span&gt; x, &lt;span class=&#34;keyword&#34;&gt;double&lt;/span&gt; y)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;getR&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;getTheta&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;function&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;title&#34;&gt;setPolar&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;keyword&#34;&gt;double&lt;/span&gt; r, &lt;span class=&#34;keyword&#34;&gt;double&lt;/span&gt; theta)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;利用抽象化的詞彙來表達資料。這並不是只透過介面及讀取、設定函式就能完成。想辨法找到最能詮釋「資料抽象概念」的方式。&lt;br&gt;而最差的作法，則是天真地加上讀取函式及設定函式而已。&lt;/p&gt;
&lt;p&gt;1.物件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;private member，public method&lt;/li&gt;
&lt;li&gt;將實現的過程隱藏(封裝)&lt;/li&gt;
&lt;li&gt;用抽象詞彙表達資料&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getGallonsOfGasoline()&lt;/code&gt; → &lt;code&gt;getPercentFuelRemaining()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;要讓每件事物都是一個物件是一個神話&lt;/strong&gt;(Java表示：)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.資料結構: map, set, array …&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;暴露資料(public member)&lt;ul&gt;
&lt;li&gt;為資料結構設getter和setter是多此一舉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;物件與資料結構的互補&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物件：新資料型態的彈性 ↔ 資料結構：新行為的彈性&lt;ul&gt;
&lt;li&gt;資料結構容易添加函式，而不用更改現有的資料結構&lt;/li&gt;
&lt;li&gt;物件容易添加新的類別(繼承)，而不用更改現有的函式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;混合體只會得到兩者的缺點&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3poLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlQkUlOTclRTUlQTIlQTglRTUlQkYlOTIlRTglODAlQjMlRTUlQUUlOUElRTUlQkUlOEI=&#34;&gt;The law of Demeter&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模組不該知道關於它所操縱&lt;strong&gt;物件&lt;/strong&gt;的&lt;strong&gt;內部運作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;違反原則: 火車連結&lt;ul&gt;
&lt;li&gt;&lt;code&gt;String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;改進(仍然知道底層操作)&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Options opts = ctxt.getOptions();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;File scratchDir = opts.getScratchDir();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String outputDir = scratchDir.getAbsolutePath();&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若 ctxt, options 為資料結構，則以下可行&lt;ul&gt;
&lt;li&gt;&lt;code&gt;outputDir = ctxt.options.scratchDir.absolutePath&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若是物件，則我們應該要告訴 ctxt 去&lt;strong&gt;做某件事情&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;和其他程式碼合併 : &lt;code&gt;BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可調整的資料應放在高層次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;底層不應存放參數&lt;/li&gt;
&lt;li&gt;放在高階層比較好找，也比較好修改&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;One Switch原則&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;對於給定的變數，不應該有超過一個以上的switch敘述。在那個唯一的Switch敘述中的多個case，必須建立多型物件以取代其他case。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;錯誤處理&#34;&gt;&lt;a href=&#34;#錯誤處理&#34; class=&#34;headerlink&#34; title=&#34;錯誤處理&#34;&gt;&lt;/a&gt;錯誤處理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;定義正常的流程&lt;ul&gt;
&lt;li&gt;使用&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL21hcnRpbmZvd2xlci5jb20vZWFhQ2F0YWxvZy9zcGVjaWFsQ2FzZS5odG1s&#34;&gt;特殊情況物件(special case pattern)&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;替代&lt;code&gt;if()&lt;/code&gt;檢查&lt;ul&gt;
&lt;li&gt;將特殊情況包在特殊情況物件&lt;/li&gt;
&lt;li&gt;特殊情況物件處理例外&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;包裹第三方程式庫&lt;ul&gt;
&lt;li&gt;減少依頼，容易更換&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用 例外處理(try-catch-finally) 取代回傳error code&lt;ul&gt;
&lt;li&gt;例外處理是「一件事」&lt;ul&gt;
&lt;li&gt;error code 必須在呼叫結束之後立即檢查錯誤&lt;/li&gt;
&lt;li&gt;提取try和catch的內容，成為新函式&lt;/li&gt;
&lt;li&gt;用class包裹例外，此class只處理例外&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不要傳遞NULL&lt;ul&gt;
&lt;li&gt;要檢查值是不是NULL，很麻煩&lt;ul&gt;
&lt;li&gt;所有函式都不return NULL → 都不用檢查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解決&lt;ul&gt;
&lt;li&gt;回傳特殊情況物件&lt;ul&gt;
&lt;li&gt;例：找不到時，回傳空list&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用例外處理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Java：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3RlZGR5LWNoZW4tdHcuYmxvZ3Nwb3QudHcvMjAxMS8wNS9jaGVja2VkLW9yLXVuY2hlY2tlZC1leGNlcHRpb25zLTEuaHRtbA==&#34;&gt;使用不檢查型例外：&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC90ZWRkeXNvZnQvamF2YWNoZWNrZWR1bmNoZWNrZWQtZXhjZXB0aW9ucw==&#34;&gt;(檢查和不檢查型例外)&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;，因為其破壞開放閉合原則，修改低階函式時也需要修改高階函式&lt;/li&gt;
&lt;li&gt;將邊界條件的檢查放置於同一個地方，不要散佈在程式的各個角落&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;邊界&#34;&gt;&lt;a href=&#34;#邊界&#34; class=&#34;headerlink&#34; title=&#34;邊界&#34;&gt;&lt;/a&gt;邊界&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;註：從這章之後大多是一章一個作者，所以頗有矛盾和重復的地方&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用第三方API&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;學習性測試&lt;ul&gt;
&lt;li&gt;寫一些測試程式來了解第三方軟體&lt;/li&gt;
&lt;li&gt;第三方軟體改版後也能用來確定行為是否改變&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;包裹第三方API&lt;ul&gt;
&lt;li&gt;&lt;code&gt;public void open() { try{innerPort.open();} ... }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;好處&lt;ul&gt;
&lt;li&gt;掌握控制程式的權利&lt;/li&gt;
&lt;li&gt;在API未知的情況可以繼承此interface，創造一個Fake API來測試&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;單元測試&#34;&gt;&lt;a href=&#34;#單元測試&#34; class=&#34;headerlink&#34; title=&#34;單元測試&#34;&gt;&lt;/a&gt;單元測試&lt;/h3&gt;&lt;p&gt;有了測試程式(和版本控制系統)就不會害怕修改程式！&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2dsaXlhby5sb2dkb3duLmNvbS9wb3N0cy8yMDE0LzAxLzE4L3NvZnR3YXJlLXRhbGstYWJvdXQtdGVzdC1kcml2ZW4tZGV2ZWxvcG1lbnQtdGVzdC1kcml2ZW4tZGV2ZWxvcG1lbnQtaQ==&#34;&gt;測試驅動開發(TDD)&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5idXR1bmNsZWJvYi5jb20vQXJ0aWNsZVMuVW5jbGVCb2IuVGhlVGhyZWVSdWxlc09mVGRk&#34;&gt;The Three Rules of TDD&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先寫測試程式，再寫對應的實作程式&lt;/li&gt;
&lt;li&gt;只寫&lt;strong&gt;剛好&lt;/strong&gt;無法通過的單元測試&lt;ol&gt;
&lt;li&gt;測試無法通過時，應該要修復實作程式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;只寫&lt;strong&gt;剛好&lt;/strong&gt;能通過測試的程式&lt;ol&gt;
&lt;li&gt;測試無法通過時，只能寫和測試有關的實作程式，不能寫其他功能&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;測試程式和產品程式一樣重要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;測試方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用涵蓋率工具(Coverage Tool)&lt;ul&gt;
&lt;li&gt;檢查是否每行程式都有被執行過&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;測試邊界條件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原則&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;測試的程式碼也需要整潔&lt;ul&gt;
&lt;li&gt;最重要的是可讀性，效率是其次&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;建造-操作-檢查（BUILD-OPERATE-CHECK）&lt;ul&gt;
&lt;li&gt;產生數據，操作之，再檢查正確性&lt;/li&gt;
&lt;li&gt;GIVEN-WHEN-THEN&lt;ul&gt;
&lt;li&gt;Given: 前提、環境&lt;/li&gt;
&lt;li&gt;When: 發生事情&lt;/li&gt;
&lt;li&gt;Then: 預期結果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一個測試只用一個assert&lt;/li&gt;
&lt;li&gt;在錯誤的程式碼附近進行詳盡的測試&lt;ul&gt;
&lt;li&gt;因為Bug往往聚集&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;測試程式的 F.I.R.S.T. 法則&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fast：快速(足夠快即可)&lt;/li&gt;
&lt;li&gt;Independent：可個別獨立執行&lt;/li&gt;
&lt;li&gt;Repeatable：可在任何環境重複執行&lt;/li&gt;
&lt;li&gt;Self-Validating：輸出bool值(成功/失敗)，而不是記錄檔&lt;ul&gt;
&lt;li&gt;不用做額外的檢查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Timely：先寫測試再實作&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;類別&#34;&gt;&lt;a href=&#34;#類別&#34; class=&#34;headerlink&#34; title=&#34;類別&#34;&gt;&lt;/a&gt;類別&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;凝聚性：方法內使用愈多變數，代表這個方法更屬於這個類別&lt;ul&gt;
&lt;li&gt;為了保持凝聚性，會產生許多小類別&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;把工具放在有許多標記的小型工具箱裡，比少量的大抽屜，然後將所有的東西都丟進去好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不應該對相依的模組有預先的假設(即邏輯上的相依)，應該清楚的詢問所需的有關訊息(即實體上的相依)。&lt;!--??--&gt;&lt;/p&gt;
&lt;h3 id=&#34;系統&#34;&gt;&lt;a href=&#34;#系統&#34; class=&#34;headerlink&#34; title=&#34;系統&#34;&gt;&lt;/a&gt;系統&lt;/h3&gt;&lt;p&gt;如同建造城市，某些人負責整體規劃，其它人專注在細節執行。&lt;br&gt;進行抽象化和模組化，將所有關注的事分離開來&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工廠模式：&lt;strong&gt;將建造和使用分離&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相依性注入&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2h1YW4tbGluLmJsb2dzcG90LmNvbS8yMDExLzEwL2RlcGVuZGVuY3ktaW5qZWN0aW9uLTEuaHRtbA==&#34;&gt;(1)&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzA3OTQvd2hhdC1pcy1kZXBlbmRlbmN5LWluamVjdGlvbg==&#34;&gt;(2)&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控管反轉&lt;ul&gt;
&lt;li&gt;將第二個職責移到其它專注於該職責的物件裡&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;擴大&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLXR3LyVFNSU4RCU4MSVFNSVBNCVBNyVFNSVCQiVCQSVFOCVBOCVBRCMuRTguQTkuOTUuRTUuODMuQjk=&#34;&gt;誰有辦法預期小鎮的成長，而在鎮上先鋪好六線道高速公路？&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;讓系統一開始就做對，是一個神話&lt;/li&gt;
&lt;li&gt;應該只實現今天的故事(即目前的需求)，然後重構它，並且明天再進行系統的擴充&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;剖面導向程式設計AOP&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv6Z2i5ZCR5L6n6Z2i55qE56iL5bqP6K6+6K6h&#34;&gt;(1)&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9vcGVuaG9tZS5jYy9Hb3NzaXAvU3ByaW5nR29zc2lwL0FPUENvbmNlcHQuaHRtbA==&#34;&gt;(2)&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;剖面(aspect)&lt;ul&gt;
&lt;li&gt;系統中某個關注點的行為，需要用一致性的方式修改&lt;ul&gt;
&lt;li&gt;如日誌記錄(log)、資料庫、安全性、暫存快取&lt;/li&gt;
&lt;li&gt;紀錄檔功能往往橫跨系統中的每個業務模組，即「橫切」所有有紀錄檔需求的類及方法體&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;為應用程式基礎架構&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;保持適當的關注點分離&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;不需要「先作大型設計」&lt;/strong&gt;，因為不希望浪費先前的努力，這個設計會阻止你改進程式架構。&lt;/p&gt;
&lt;p&gt;有時候拖延至最後一刻是最好的作法，這讓我們得以運用最多的資訊進行選擇。&lt;/p&gt;
&lt;p&gt;系統需要特定領域的語言(Domain-Specific Language), 讓領域專家可以把程式寫得像是散文的結構，而且領域概念和實作程式碼相似，減少轉換錯誤。&lt;/p&gt;
&lt;h4 id=&#34;剖面範例&#34;&gt;&lt;a href=&#34;#剖面範例&#34; class=&#34;headerlink&#34; title=&#34;剖面範例&#34;&gt;&lt;/a&gt;剖面範例&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL29wZW5ob21lLmNjL0dvc3NpcC9TcHJpbmdHb3NzaXAvRnJvbVByb3h5VG9BT1AuaHRtbA==&#34;&gt;Java代理機制&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;ol&gt;
&lt;li&gt;代理可以呼叫被代理物件的函式，也可以進行剖面的行為&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Java AOP框架&lt;ol&gt;
&lt;li&gt;Spring AOP&lt;/li&gt;
&lt;li&gt;JBoss AOP&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemwzNDUwMzQxL2FydGljbGUvZGV0YWlscy83NjczOTM4&#34;&gt;AspectJ&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;一個理想的架構，包含模組化的關注點，每個關注點都用一個普通物件實作。 不同領域之間利用最小侵入性的剖面工具整合。 這樣的架構就可以是測試驅動的(test-driven)，如同程式碼一樣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;簡單設計守則&#34;&gt;&lt;a href=&#34;#簡單設計守則&#34; class=&#34;headerlink&#34; title=&#34;簡單設計守則&#34;&gt;&lt;/a&gt;簡單設計守則&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;執行完所有的測試&lt;/li&gt;
&lt;li&gt;程式重構：重要性 1 &amp;gt; 2 &amp;gt; 3&lt;ol&gt;
&lt;li&gt;消除重複&lt;ol&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLXR3LyVFNiVBOCVBMSVFNiU5RCVCRiVFNiU5NiVCOSVFNiVCMyU5NQ==&#34;&gt;樣版方法(Template Method)&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;大部份設計模式都是在提供消除重複的策略&lt;/li&gt;
&lt;li&gt;物件導向是用來組織模組和消除重複的策略&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;具表達力&lt;/li&gt;
&lt;li&gt;最小化類別及方法數量&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;平行化&#34;&gt;&lt;a href=&#34;#平行化&#34; class=&#34;headerlink&#34; title=&#34;平行化&#34;&gt;&lt;/a&gt;平行化&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;物件是處理過程的抽象化，執行緒是排程的抽象化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;將「做什麼」和「何時做」分解開來，像是Web應用的Servlet模型&lt;br&gt;當獲得一個網頁請求時，servlet會以非同步方式執行，不需要管理所有的請求，每一個servlet都在其自我的小小世界裡執行。&lt;/p&gt;
&lt;p&gt;缺點&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要修改程式碼/架構&lt;/li&gt;
&lt;li&gt;速度不一定變快(有overhead)&lt;/li&gt;
&lt;li&gt;很難寫正確，因為很難重現bug&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;建議&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;將平行化的程式碼和其他程式碼分開&lt;/li&gt;
&lt;li&gt;保護資料&lt;ul&gt;
&lt;li&gt;限制共享資料的存取次數&lt;ul&gt;
&lt;li&gt;減少critical section的使用次數&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;限制資料的視野&lt;ul&gt;
&lt;li&gt;mutex lock(c), synchronized(java)&lt;/li&gt;
&lt;li&gt;避免在一個共享物件上使用多個方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用資料的複本&lt;ul&gt;
&lt;li&gt;由一個執行緒負責合併結果&lt;/li&gt;
&lt;li&gt;每個執行緒盡可能獨立運行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;測試&lt;ul&gt;
&lt;li&gt;偽造/產生失敗以測試&lt;/li&gt;
&lt;li&gt;讓平行化的程式可以開關平行化的功能&lt;/li&gt;
&lt;li&gt;在不同的平台測試&lt;/li&gt;
&lt;li&gt;執行比處理器數量還多的執行緒&lt;ul&gt;
&lt;li&gt;強迫進行task swapping&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;調整參數(執行緒數量、重複執行次數)&lt;/li&gt;
&lt;li&gt;正確的關閉程式&lt;ul&gt;
&lt;li&gt;防止deadlock&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5pYm0uY29tL2RldmVsb3BlcndvcmtzL2NuL2phdmEvai1jb250ZXN0Lmh0bWw=&#34;&gt;用IBM contest找BUG&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;ul&gt;
&lt;li&gt;不一定會照順序執行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;實作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ReentrantLock&lt;ul&gt;
&lt;li&gt;一般的鎖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Semaphore號誌&lt;ul&gt;
&lt;li&gt;有計數功能的鎖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CountDownLatch&lt;ul&gt;
&lt;li&gt;先等待指定數量的事件，使得所有的執行緒都有公平的機會，在同時間啟動&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;模型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生產-消費&lt;ul&gt;
&lt;li&gt;有限資源&lt;/li&gt;
&lt;li&gt;生產者放工作入queue&lt;/li&gt;
&lt;li&gt;消費者取出工作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;讀取-寫入&lt;ul&gt;
&lt;li&gt;平衡reader和writer的需求，避免某一方飢餓(starvation)&lt;/li&gt;
&lt;li&gt;簡單方法：writer等到沒有reader使用時再write&lt;ul&gt;
&lt;li&gt;writer容易starve&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;哲學家用餐&lt;ul&gt;
&lt;li&gt;雙手都拿到刀叉時才能用餐&lt;/li&gt;
&lt;li&gt;大程式的資源爭奪問題&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;詳見&lt;a href=&#34;/parallel-programming&#34;&gt;平行程式設計&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;程式碼的異味&#34;&gt;&lt;a href=&#34;#程式碼的異味&#34; class=&#34;headerlink&#34; title=&#34;程式碼的異味&#34;&gt;&lt;/a&gt;程式碼的異味&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;聖人見微以知萌，見端以知末，故見象箸而怖，知天下不足也。&lt;br&gt;韓非子．說林上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJCJUEzJUU3JUEwJTgxJUU1JUJDJTgyJUU1JTkxJUIz&#34;&gt;程式碼的異味(Code Smell)&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;:&lt;br&gt;程式碼中的任何可能導致深層問題的&lt;strong&gt;症狀&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一份檔案有多種程式語言&lt;/li&gt;
&lt;li&gt;明顯該有的行為未實現&lt;/li&gt;
&lt;li&gt;在邊界條件的不正確行為&lt;ol&gt;
&lt;li&gt;封裝邊界條件: 將邊界條件的集中處理&lt;ol&gt;
&lt;li&gt;&lt;code&gt;int nextLevel = level+1; //boundary condition&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;無視編譯器警告&lt;/li&gt;
&lt;li&gt;否定的判斷式&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;改善 &lt;code&gt;if(!buffer.isFull())&lt;/code&gt; → &lt;code&gt;if(buffer.isNotFull())&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;過多的資訊&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;類別擁有的變數、方法數量愈少愈好、方法擁有的變數愈少愈好&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;不一致性&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;命名的一致性：對於同一個物件，在不同函式中的實體使用相同的名稱&lt;/li&gt;
&lt;li&gt;行為的一致性：用同樣的方式來完成所有類似的事&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;特色留戀(Feature Envy)&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;使用其他物件的getter或setter&lt;/li&gt;
&lt;li&gt;有時候是必要之惡：放入別的物件會違反其他OOP的原則(此例：單一職責、開放閉合原則等)&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;comment&#34;&gt;//demo of feature envy&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; clas HourlyEmployeeReport&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;keyword&#34;&gt;private&lt;/span&gt; HourlyEmployee employee;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&lt;span class=&#34;function&#34;&gt;String &lt;span class=&#34;title&#34;&gt;reportHours&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;		&lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; String.Format(&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;			&lt;span class=&#34;string&#34;&gt;&#34;Name:%s, Hours:%d.%ld\n&#34;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;			employee.getName(),&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;			employee.getTenthsWorked()/&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;			employee.getTenthsWorked()%&lt;span class=&#34;number&#34;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;&lt;a href=&#34;#參考資料&#34; class=&#34;headerlink&#34; title=&#34;參考資料&#34;&gt;&lt;/a&gt;參考資料&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vemgtdHcvbGlicmFyeS9kbjM4NzU2OC5hc3B4&#34;&gt;30天快速上手 TDD&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdmVyeWl0bWFuL2FydGljbGUvZGV0YWlscy82OTM3NjA0&#34;&gt;The Principles of Good Programming&lt;i class=&#34;fa fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
    </channel>
</rss>
