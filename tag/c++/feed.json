{
    "version": "https://jsonfeed.org/version/1",
    "title": "QWERTY • All posts by \"c++\" tag",
    "description": "Programming | Computer Science | Thought",
    "home_page_url": "http://gitqwerty777.github.io",
    "items": [
        {
            "id": "http://gitqwerty777.github.io/cpp-compile-speed/",
            "url": "http://gitqwerty777.github.io/cpp-compile-speed/",
            "title": "加快C++編譯速度的方法",
            "date_published": "2017-05-23T12:44:30.000Z",
            "content_html": "<h2 id=\"編譯速度慢的原因\"><a href=\"#編譯速度慢的原因\" class=\"headerlink\" title=\"編譯速度慢的原因\"></a>編譯速度慢的原因</h2><p>因為C++ <code>.h</code> + <code>.cpp</code> 的編譯模型<br>每個cpp檔可能會包含上百甚至上千個<code>.h</code>檔，這些<code>.h</code>檔都會被讀進來一遍，然後被解析一遍。<br>每個編譯單元都會產生一個<code>.obj</code>文件，然後所以這些<code>.obj</code>文件會被link到一起，並且這個過程很難平行。重複load與解析，以及密集的IO，使編譯速度很慢。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"代碼角度\"><a href=\"#代碼角度\" class=\"headerlink\" title=\"代碼角度\"></a>代碼角度</h2><h3 id=\"前置聲明\"><a href=\"#前置聲明\" class=\"headerlink\" title=\"前置聲明\"></a>前置聲明</h3><p>在<code>.h</code>檔中使用前置聲明(forward declaration)，而不是直接包含<code>.h</code>檔。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>;</span> <span class=\"comment\">//forward declaration, instead #include \"a.h\"</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&#123;</span></span><br><span class=\"line\">    A* a;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">useA</span><span class=\"params\">(A&amp; a)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span> <span class=\"comment\">//cannot use forward declaration because compiler needs to know what A really is</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&#123;</span></span><br><span class=\"line\">    A a;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>要盡一切可能使<code>.h</code>檔精簡</strong>。<br>很多時候前置聲明某個namespace中的class會比較痛苦，而直接include會方便很多，千萬要抵制住這種誘惑；class的成員，函數參數等也儘量用reference或pointer。</p>\n<h3 id=\"使用Pimpl模式\"><a href=\"#使用Pimpl模式\" class=\"headerlink\" title=\"使用Pimpl模式\"></a>使用Pimpl模式</h3><p>Pimpl為Private Implementation<br>傳統的C++的class的接口與實現是混淆在一起的，而Pimpl這種做法使得class的接口與實現得以完全分離。<br>如此，只要class的公共接口保持不變，對class實現的修改始終只需編譯該cpp；同時，該class提供給外界的.h檔也會精簡許多。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    A();</span><br><span class=\"line\">    ~A();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Impl</span>;</span><span class=\"comment\">//real implementation in this class</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">auto_ptr</span>&lt;impl&gt; m_impl;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"高度模塊化\"><a href=\"#高度模塊化\" class=\"headerlink\" title=\"高度模塊化\"></a>高度模塊化</h3><p>模塊化就是低耦合，就是儘可能的減少相互依賴。</p>\n<ol>\n<li>文件與文件之間，一個<code>.h</code>檔的變化，儘量不要引起其他文件的重新編譯。</li>\n<li>工程與工程之間，對一個工程的修改，儘量不要引起太多其他工程的編譯。這就要求<code>.h</code>檔，或者工程的內容一定要單一，不要什麼東西都往裡面塞，從而引起不必要的依賴。</li>\n</ol>\n<p>不要把兩個不相關的class，或者沒什麼聯繫的macro定義放到一個<code>.h</code>檔裡；內容要儘量單一。</p>\n<p>把代碼中最常用到的那些<code>.h</code>檔找出來，然後分成多個獨立的小文件，效果相當可觀。</p>\n<h3 id=\"刪除冗餘的header檔\"><a href=\"#刪除冗餘的header檔\" class=\"headerlink\" title=\"刪除冗餘的header檔\"></a>刪除冗餘的header檔</h3><p>一些代碼經過上十年的開發與維護，經手的人無數，很有可能出現包含了沒用的<code>.h</code>檔，或重複包含的現象，去掉這些冗餘的include是相當必要的。<br>當然，這主要是針對<code>.cpp</code>的，因為對於一個<code>.h</code>檔，其中的某個include是否冗餘很難界定，得看是否在最終的編譯單元中用到了，而這樣又可能出現在一個編譯單元用到了，而在另外一個編譯單元中沒用到的情況。</p>\n<h3 id=\"特別注意inline和template\"><a href=\"#特別注意inline和template\" class=\"headerlink\" title=\"特別注意inline和template\"></a>特別注意inline和template</h3><p>它們強制在<code>.h</code>檔中包含實作，這會增加<code>.h</code>檔的內容，從而減慢許多編譯速度，需權衡使用。</p>\n<h3 id=\"預編譯-h檔\"><a href=\"#預編譯-h檔\" class=\"headerlink\" title=\"預編譯.h檔\"></a>預編譯<code>.h</code>檔</h3><p>把一些常用但不常改動的<code>.h</code>檔放在預編譯<code>.h</code>檔中。這樣，至少在單個工程中你不需要在每個編譯單元裡一遍又一遍的load與解析同一個<code>.h</code>檔了。</p>\n<p>首次編譯source.cpp時，編譯器生成header.pch的預編譯header。以後再編譯該程式時，編譯器會比較該表頭檔的時間戳，如果表頭檔沒有改變，編譯器直接使用預編譯header。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\">CORE_PCH_FILENAME=Core.h</span><br><span class=\"line\">CORE_PCH=<span class=\"variable\">$(CORE_PCH_FILENAME)</span>.gch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$(CORE_PCH)</span>:</span><br><span class=\"line\">    <span class=\"variable\">$(CXX)</span> <span class=\"variable\">$(CXX_CFLAGS)</span> -x c++-header <span class=\"variable\">$(CORE_PCH_FILENAME)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Guard-Conditions\"><a href=\"#Guard-Conditions\" class=\"headerlink\" title=\"Guard Conditions\"></a>Guard Conditions</h3><p>保證每個 header file 在每個編譯單元只被 include 一次</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> filename_h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> filename_h</span></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>同時使用兩種方法以確保compiler的相容性</p>\n<h2 id=\"Unity-Build\"><a href=\"#Unity-Build\" class=\"headerlink\" title=\"Unity Build\"></a>Unity Build</h2><p>把所有的檔案包含到一個cpp中(如<code>all.cpp</code>)，然後只編譯all.cpp。這樣就只有一個編譯單元，這意味著不需要重複load與解析同一個<code>.h</code>檔了，同時因為只產生一個obj文件，在link的時候也不需要那麼密集的IO</p>\n<h2 id=\"Compiler-Cache\"><a href=\"#Compiler-Cache\" class=\"headerlink\" title=\"Compiler Cache\"></a>Compiler Cache</h2><p>藉由快取上一次編譯的結果，使rebuild在保持結果相同的情況下，極大的提高速度。</p>\n<h2 id=\"不要有太多的Include-Directories\"><a href=\"#不要有太多的Include-Directories\" class=\"headerlink\" title=\"不要有太多的Include Directories\"></a>不要有太多的Include Directories</h2><p>編譯器定位你include的<code>.h</code>檔，是根據你提供的include directories進行搜索的。</p>\n<p>用 <code>cpp -v</code> 查看 <code>#include &quot;...&quot; search starts here:</code> 中的目錄<br>和 GNU Make 的 <code>-I</code> 選項</p>\n<h2 id=\"平行化及分佈式編譯\"><a href=\"#平行化及分佈式編譯\" class=\"headerlink\" title=\"平行化及分佈式編譯\"></a>平行化及分佈式編譯</h2><p>GNU Make 的 <code>-j [N]</code> 可以用N個核心編譯<br>Visual Studio 有 <code>/MP</code> 選項可做到檔案等級的平行<br>或是用空閒的機器來編譯</p>\n<h2 id=\"買更好的磁碟\"><a href=\"#買更好的磁碟\" class=\"headerlink\" title=\"買更好的磁碟\"></a>買更好的磁碟</h2><p>編譯速度慢很大一部分原因是磁碟操作，那麼除了儘可能的減少磁碟操作，我們還可以做的就是加快磁碟速度。</p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzczMTQyL3doYXQtdGVjaG5pcXVlcy1jYW4tYmUtdXNlZC10by1zcGVlZC11cC1jLWNvbXBpbGF0aW9uLXRpbWVz\">What techniques can be used to speed up C++ compilation times?<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9iYWl5YW5odWFuZy9hcmNoaXZlLzIwMTAvMDEvMTcvMTczMDcxNy5odG1s\">如何加快C++代碼的編譯速度<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1xWU42ZWR1VTA2cw==\">(Unity Build) CppCon 2014: Nicolas Fleury “C++ in Huge AAA Games”<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2dhbWVkZXYvY29tbWVudHMvMms0bDJ6L2lzX3ViaXNvZnRzX3VuaXR5X2J1aWxkX2Zvcl9jX3dvcnRoLw==\">(Unity Build) Is Ubisoft’s unity build for C++ worth?<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2dvb2RzcGVlZGxlZS5ibG9nc3BvdC50dy8yMDE2LzAxL2MtcGltcGwuaHRtbA==\">(pimpl) C++: 善用 PIMPL 技巧<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2JhaXlhbmh1YW5nL2JhY2t1cC9ibG9iLzlmMTFkMDE0OWNiMzY1OWRhYzQ3OTY3ZjFiMTBmM2I3ZWVjODg4ZDMvdG9vbHMvUGVybC9SZW1vdmVSZWR1bmRhbnRJbmNsdWRlcy5wbA==\">(去除重複) Perl腳本，用來自動去除這些冗餘的.h檔<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2R1Y2tyb29tLmJsb2dzcG90LnR3LzIwMTAvMDIvcHJlY29tcGlsZWQtaGVhZGVyLmh0bWw=\">(預編譯.h檔) 終於搞懂了，預編譯header 檔(precompiled header)<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9Yb3JlYXglMjBJbmNyZWRpQnVpbGQ=\">(分佈式編譯) Xoreax IncrediBuild<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODkyMDY0MC9ob3ctZG8taS1rbm93LXRoZS1kZWZhdWx0LWluY2x1ZGUtZGlyZWN0b3JpZXMtZGVmYXVsdC1saW5rLWRpcmVjdG9yaWVzLWFuZA==\">How do I know the default include directories<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jY2FjaGUuc2FtYmEub3JnLw==\">(Compiler Cache) ccache<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2l0c2NvbXBpbGluZy5ldS8yMDE3LzAxLzEyL3ByZWNvbXBpbGVkLWhlYWRlcnMtY3BwLWNvbXBpbGF0aW9uLw==\">(預編譯.h檔) Speed up C++ compilation, part 1: precompiled headers<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzczNjU3NzA=\">(預編譯.h檔) makefile 範例<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n",
            "tags": [
                "C++",
                "編譯",
                "gcc",
                "g++",
                "clang",
                "最佳化"
            ]
        },
        {
            "id": "http://gitqwerty777.github.io/cpp-boost/",
            "url": "http://gitqwerty777.github.io/cpp-boost/",
            "title": "C++ boost 簡單應用",
            "date_published": "2015-07-14T07:18:44.000Z",
            "content_html": "<!-- RENEW: -->\n\n<h2 id=\"簡介\"><a href=\"#簡介\" class=\"headerlink\" title=\"簡介\"></a>簡介</h2><p>C++的著名擴充函式庫</p>\n<p>功能(節錄)：</p>\n<ul>\n<li>regex</li>\n<li>function binding</li>\n<li>lambda functions</li>\n<li>unit tests</li>\n<li>smart pointers</li>\n<li>noncopyable, optional</li>\n<li>serialization</li>\n<li>generic dates</li>\n<li>portable filesystem</li>\n<li>circular buffers</li>\n<li>config utils</li>\n<li>generic image library</li>\n<li>program options</li>\n<li>threads</li>\n</ul>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ib29zdC5vcmcvZG9jL2xpYnMvMV81OF8wL2xpYnMvbGlicmFyaWVzLmh0bQ==\">所有功能<i class=\"fa fa-external-link-alt\"></i></span></p>\n<a id=\"more\"></a>\n\n<p>安裝：<code>sudo apt-get install libboost-all-dev</code></p>\n<h2 id=\"基本功能\"><a href=\"#基本功能\" class=\"headerlink\" title=\"基本功能\"></a>基本功能</h2><p>簡化語法</p>\n<h3 id=\"foreach\"><a href=\"#foreach\" class=\"headerlink\" title=\"foreach\"></a>foreach</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;boost/foreach.hpp&gt;</span></span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">hello</span><span class=\"params\">( <span class=\"string\">\"Hello, world!\"</span> )</span></span>;</span><br><span class=\"line\">  BOOST_FOREACH( <span class=\"keyword\">char</span> ch, hello )&#123; <span class=\"comment\">// equals to for (auto c : hello) in c03                          </span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; ch &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//convient way to use</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> foreach BOOST_FOREACH</span></span><br></pre></td></tr></table></figure>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5hcnRpbWEuY29tL2NwcHNvdXJjZS9mb3JlYWNoLmh0bWw=\">實作方法<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"lexical-cast\"><a href=\"#lexical-cast\" class=\"headerlink\" title=\"lexical_cast\"></a>lexical_cast</h3><p>可以轉換成其他格式</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;boost/lexical_cast.hpp&gt;</span></span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">double</span> j = <span class=\"number\">233.211321231</span>;                              </span><br><span class=\"line\"><span class=\"built_in\">string</span> mystring = boost::lexical_cast&lt;<span class=\"built_in\">string</span>&gt;(j);</span><br><span class=\"line\"><span class=\"keyword\">double</span> k = boost::lexical_cast&lt;<span class=\"keyword\">double</span>&gt;(mystring);<span class=\"comment\">//k = 233.211</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split\"></a>split</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;boost/algorithm/string.hpp&gt;</span></span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"built_in\">string</span> stringtobesplit = <span class=\"string\">\"AA/BB-CC\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; tokens;</span><br><span class=\"line\">boost::split(tokens, stringtobesplit, boost::is_any_of(<span class=\"string\">\"/\\-\"</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Smart-Pointers\"><a href=\"#Smart-Pointers\" class=\"headerlink\" title=\"Smart Pointers\"></a>Smart Pointers</h3><p><span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81Njk3NzUvc21hcnQtcG9pbnRlcnMtYm9vc3QtZXhwbGFpbmVk\">Basic properties of smart pointers<i class=\"fa fa-external-link-alt\"></i></span></p>\n<ul>\n<li>no ownership at all<ul>\n<li>smart pointer cannot delete the object, because it doesn’t own it</li>\n</ul>\n</li>\n<li>transfer of ownership<ul>\n<li>only one smart pointer can ever point to the same object at the same time</li>\n<li>If the smart pointer is to be returned from functions, the ownership is transferred to the returned smart pointer</li>\n<li>Transfer of ownership cannot really be implemented in C++ currently, because object will be copied after return<ul>\n<li>only can use the copy constructor to implement that transfer of ownership</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>share of ownership<ul>\n<li>multiple smart pointers can point to the same object at the same time</li>\n<li>can be implemented by having a copy constructor</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Categorizing-smart-pointers\"><a href=\"#Categorizing-smart-pointers\" class=\"headerlink\" title=\"Categorizing smart pointers\"></a>Categorizing smart pointers</h4><ul>\n<li><code>scoped_ptr</code><ul>\n<li>neither transferable nor sharable (= normal pointer)</li>\n<li>when it goes out of scope, it is destroyed</li>\n</ul>\n</li>\n<li><code>shared_ptr</code><ul>\n<li>shares ownership</li>\n<li>reference counted so it can see when the last copy of it goes out of scope and then it frees the object automatically</li>\n<li>所有使用同一筆資料的指標都不再使用後自動釋放</li>\n</ul>\n</li>\n<li><code>weak_ptr</code><ul>\n<li>non-owning smart pointer</li>\n<li>reference a managed object (managed by a shared_ptr) so it will not add a reference count<ul>\n<li>If you need to access the object, you can lock the management of it (to avoid that in another thread a shared_ptr frees it while you use the object)</li>\n</ul>\n</li>\n<li>If <code>weak_ptr</code> points to an object already deleted, it will notice you by throwing an exception</li>\n<li>It is most beneficial when you have a cyclic reference: Reference counting cannot easily cope with such a situation</li>\n</ul>\n</li>\n<li><code>intrusive_ptr</code><ul>\n<li>like a shared_ptr <ul>\n<li>does not keep the reference count in a shared_ptr</li>\n<li>but call helper functions to increse/decrese the count <ul>\n<li>helper function need to be defined by the object that is managed</li>\n<li>reference count is not anymore internal to the smart pointer, but the smart pointer uses an existing reference counting mechanism</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>typically used when there is a 3rd party smart ptr you must use</li>\n</ul>\n</li>\n<li><code>unique_ptr</code><ul>\n<li>transfer of ownership pointer</li>\n<li>cannot copy it, but can move it by using C++1x’s <code>move</code> constructors</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt; scoped_ptr&lt;T&gt; &gt; tPtrVec;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     <span class=\"function\">scoped_ptr&lt;T&gt; <span class=\"title\">tPtr</span><span class=\"params\">(<span class=\"keyword\">new</span> T())</span></span>;</span><br><span class=\"line\">     tPtrVec.push_back(tPtr);</span><br><span class=\"line\">     <span class=\"comment\">// raw T* is freed</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">tPtrVec[<span class=\"number\">0</span>]-&gt;DoSomething(); <span class=\"comment\">// accessing freed memory</span></span><br><span class=\"line\"><span class=\"comment\">//--------------------------------------</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt; <span class=\"built_in\">shared_ptr</span>&lt;T&gt; &gt; tPtrVec;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">tPtr</span><span class=\"params\">(<span class=\"keyword\">new</span> T())</span></span>;</span><br><span class=\"line\">     <span class=\"comment\">// This copy to tPtrVec.push_back and ultimately to the vector storage</span></span><br><span class=\"line\">     <span class=\"comment\">// causes the reference count to go from 1-&gt;2</span></span><br><span class=\"line\">     tPtrVec.push_back(tPtr);</span><br><span class=\"line\">     <span class=\"comment\">// num references to T goes from 2-&gt;1 on the destruction of tPtr</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">tPtrVec[<span class=\"number\">0</span>]-&gt;DoSomething(); <span class=\"comment\">// raw T* still exists, so this is safe</span></span><br><span class=\"line\"><span class=\"comment\">//--------------------------------------</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt; weak_ptr&lt;T&gt; &gt; tPtrVec;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">tPtr</span><span class=\"params\">(<span class=\"keyword\">new</span> T())</span></span>;</span><br><span class=\"line\">     tPtrVec.push_back(tPtr);</span><br><span class=\"line\">     <span class=\"comment\">// num references to T goes from 1-&gt;0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; tPtrAccessed =  tPtrVec[<span class=\"number\">0</span>].lock();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (tPtrAccessed[<span class=\"number\">0</span>].get() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">     <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Raw T* was freed, can't access it\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">     tPtrVec[<span class=\"number\">0</span>]-&gt;DoSomething(); <span class=\"comment\">// raw </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//--------------------------------------</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;type&gt; <span class=\"title\">p</span><span class=\"params\">(<span class=\"keyword\">new</span> type)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;type&gt; <span class=\"title\">q</span><span class=\"params\">(p)</span></span>; <span class=\"comment\">// not legal!</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;type&gt; <span class=\"title\">r</span><span class=\"params\">(move(p))</span></span>; <span class=\"comment\">// legal. p is now empty and r owns the object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;type&gt; <span class=\"title\">s</span><span class=\"params\">(function_returning_a_unique_ptr())</span></span>; <span class=\"comment\">// legal!</span></span><br></pre></td></tr></table></figure>\n\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuY3Nkbi5uZXQvam51X3NpbWJhL2FydGljbGUvZGV0YWlscy85NTY5NTkz\">Chinese Explaination<i class=\"fa fa-external-link-alt\"></i></span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;boost/shared_ptr.hpp&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">safeclose</span><span class=\"params\">(FILE*fp)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fp) &#123;</span><br><span class=\"line\">        fclose(fp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">some_fn</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">boost::<span class=\"built_in\">shared_ptr</span>&lt;FILE&gt; <span class=\"title\">fp</span><span class=\"params\">( fopen(myfilename, <span class=\"string\">\"a+t\"</span>), safeclose )</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//body of the function, and when ever it exits the file gets closed</span></span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>( fp.get(), <span class=\"string\">\"a message\\n\"</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjU1ODAvd2hhdC1hcmUtdGhlLWFkdmFudGFnZXMtb2YtdXNpbmctdGhlLWMtYm9vc3QtbGlicmFyaWVz\">Advantage of using boost libraries<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMjU5MDYvbW9zdC11c2VkLXBhcnRzLW9mLWJvb3N0\">Most used parts of boost<i class=\"fa fa-external-link-alt\"></i></span></p>\n",
            "tags": [
                "C++",
                "boost",
                "函式庫"
            ]
        },
        {
            "id": "http://gitqwerty777.github.io/big-number-library/",
            "url": "http://gitqwerty777.github.io/big-number-library/",
            "title": "大數運算的函式庫—BigNumber.h",
            "date_published": "2014-05-24T03:00:47.000Z",
            "content_html": "<p>因為在許多online judge的題目中，大數運算是很常見的題型之一， 所以就寫了一個可以簡單進行大數運算的函式庫。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"BigNumber-內容\"><a href=\"#BigNumber-內容\" class=\"headerlink\" title=\"BigNumber 內容\"></a>BigNumber 內容</h2><ul>\n<li>目前只支援整數</li>\n<li>四則運算(除法只算到整數)</li>\n<li>可直接比較，賦值</li>\n<li>從各種type轉換成BigNumber物件，如int, long, string…</li>\n<li>以string形式輸出</li>\n</ul>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2dpdHF3ZXJ0eTc3Ny9CaWdOdW1iZXI=\">Github Repo連結<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"用NaN表示例外\"><a href=\"#用NaN表示例外\" class=\"headerlink\" title=\"用NaN表示例外\"></a>用NaN表示例外</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvTmFO\">Not A Number<i class=\"fa fa-external-link-alt\"></i></span><ul>\n<li>Example: 0/0, log(-1)</li>\n<li><code>NaN == NaN</code> is false</li>\n<li>可用 <code>isnan()</code> 檢查</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> <span class=\"built_in\">list</span> = <span class=\"number\">0.0</span> / <span class=\"number\">0.0</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%lf\\n\"</span>, <span class=\"built_in\">list</span>); <span class=\"comment\">// will print -nan</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"實作方法\"><a href=\"#實作方法\" class=\"headerlink\" title=\"實作方法\"></a>實作方法</h2><p>待補充</p>\n",
            "tags": [
                "大數",
                "程式",
                "C++"
            ]
        }
    ]
}