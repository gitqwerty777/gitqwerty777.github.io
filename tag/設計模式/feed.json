{
    "version": "https://jsonfeed.org/version/1",
    "title": "QWERTY • All posts by \"設計模式\" tag",
    "description": "Programming | Computer Science | Thought",
    "home_page_url": "http://gitqwerty777.github.io",
    "items": [
        {
            "id": "http://gitqwerty777.github.io/observer-pattern/",
            "url": "http://gitqwerty777.github.io/observer-pattern/",
            "title": "觀察者模式(Observer Pattern)",
            "date_published": "2020-11-21T07:00:00.000Z",
            "content_html": "<h2 id=\"目標\"><a href=\"#目標\" class=\"headerlink\" title=\"目標\"></a>目標</h2><p>一對多的依賴關係，當物件狀態改變時，所有依賴者會被通知。</p>\n<h2 id=\"架構\"><a href=\"#架構\" class=\"headerlink\" title=\"架構\"></a>架構</h2><p><img data-src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/a/a8/Observer_w_update.svg/1024px-Observer_w_update.svg.png?1618077346924\" alt=\"From Wiki\"></p>\n<ul>\n<li><code>Subject</code>：主題<ul>\n<li>特定事件發生時，會通知觀察者<ul>\n<li>如資料改變</li>\n</ul>\n</li>\n<li>新增/移除觀察者：<code>Attach(Observer), Detach(Observer)</code></li>\n<li>用<code>Notify(data)</code>通知觀察者主題有更新</li>\n</ul>\n</li>\n<li><code>Observer</code>：觀察者<ul>\n<li>訂閱主題，以便在更新時收到通知</li>\n<li>觀察者收到通知時呼叫<code>Update(Subject)</code>以處理事件</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>設計守則：盡量讓需要互動的物件的關係鬆綁</p>\n<ul>\n<li>主題和觀察者鬆綁<ul>\n<li>主題只知道觀察者有實作特定介面(<code>Observer</code>)，不用知道觀察者的具體類別</li>\n<li>任何時候都可以加入新的觀察者，且主題的程式碼不需修改</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"實作\"><a href=\"#實作\" class=\"headerlink\" title=\"實作\"></a>實作</h2><p>有一觀測工作站數據的物件，在數據異常時可以通知到多個平台(Email, 簡訊, App)，<br>且使用者可以自由調整各平台的通知設定。</p>\n<ul>\n<li>觀察者之間彼此獨立，不可依頼通知觀察者的順序</li>\n<li>主題可以控制改變的定義(如溫度變化超過1度)</li>\n<li>Push model/Pull model<ul>\n<li>Push model<ul>\n<li>推送所有資料給Observer</li>\n<li>Subject要知道Observer需要什麼，彈性較差</li>\n<li>Observer會接收到不必要的資料</li>\n</ul>\n</li>\n<li>Pull model<ul>\n<li>提供必要的資料或其來源(如data id或Subject本身)給Observer，由Observer自行取得相關資料</li>\n<li>每個Observer都要重新取得資料，效率較差</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>C#的實作：委託，可看作對函數的抽象，是函數的類別<ul>\n<li>委託物件所搭載的方法並不需要屬於同一個類別(即不需要Observer介面)</li>\n</ul>\n</li>\n<li>可以實作一個<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1dpdGhvdXRVbWJyZWxsYS1Cb3kvRGVzaWduLXBhdHRlcm5zLWluLWdhbWUtZGV2ZWxvcG1lbnQvYmxvYi8zODgzYzI3OGJiZWY2MzRlMzdiYzFlYTZmNDY2N2I5MjE4NDcwYmY3L1JlZEFsZXJ0UHJvamVjdC9Bc3NldHMvU2NyaXB0cy9HYW1lRXZlbnRTeXN0ZW0vR2FtZUV2ZW50U3lzdGVtLmNz\">Subject管理員<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n<h2 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h2><p>當一個物件的改變需要同時改變其他物件時</p>\n<ul>\n<li>訂閱服務</li>\n<li>MVC架構: 後端資料更新、前端顯示資料</li>\n<li>UI操作: OnClick, OnHover</li>\n<li>觸發事件</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>RSS訂閱後可取得所有資料，目前的社群網站則是訂閱後仍會篩選並提供部份資料</p>\n<h2 id=\"參考\"><a href=\"#參考\" class=\"headerlink\" title=\"參考\"></a>參考</h2><ul>\n<li>Wiki</li>\n<li>Head-First Design Pattern</li>\n<li>大話設計模式</li>\n<li>設計模式與遊戲開發的完美結合</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub3RmYWxzZS5uZXQvMTAvb2JzZXJ2ZXItcGF0dGVybg==\">https://notfalse.net/10/observer-pattern<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n",
            "tags": [
                "設計模式",
                "觀察者",
                "訂閱",
                "委託"
            ]
        },
        {
            "id": "http://gitqwerty777.github.io/mementos-pattern/",
            "url": "http://gitqwerty777.github.io/mementos-pattern/",
            "title": "備忘錄模式(Mementos Pattern)",
            "date_published": "2020-11-05T07:00:00.000Z",
            "content_html": "<p><img data-src=\"/img/Other/morgana.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n\n<h2 id=\"目標\"><a href=\"#目標\" class=\"headerlink\" title=\"目標\"></a>目標</h2><p>在不破壞封裝及單一職責原則的情況下創立/還原類別的備份。</p>\n<p>若要建立備份，簡單的方法是在類別內部建立<code>Save()</code>/<code>Load()</code>等方法，但會使類別多了備份的職責。<br>若在其他類別執行備份，則需要將想備份的資料設為public或設定Getter，破壞封裝。</p>\n<h2 id=\"架構\"><a href=\"#架構\" class=\"headerlink\" title=\"架構\"></a>架構</h2><p><img data-src=\"https://upload.wikimedia.org/wikipedia/commons/3/38/W3sDesign_Memento_Design_Pattern_UML.jpg?1615662505582\" alt=\"\"></p>\n<p>想法：Originator只產生Memento/使用Memento還原, 由Caretaker管理Memento</p>\n<ul>\n<li>Originator: 需要備份的類別，產生Memento並可用其還原<ul>\n<li><code>Memento CreateMemento()</code></li>\n<li><code>void RestoreFromMemento(Memento)</code></li>\n</ul>\n</li>\n<li>Memento: 儲存備份檔案的類別<ul>\n<li>純資料，不可變(immutable)</li>\n</ul>\n</li>\n<li>Caretaker: 管理備份的類別<ul>\n<li>呼叫 Originator 執行 備份/還原的操作</li>\n<li>管理備份<ul>\n<li>存讀檔，路徑</li>\n<li>管理多份備份</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"實作\"><a href=\"#實作\" class=\"headerlink\" title=\"實作\"></a>實作</h2><!-- - Memento可以是interface或abstract class，以避免被Originator以外的類別修改 -->\n\n<ul>\n<li>Originator可以hold Caretaker reference使兩個物件的生命周期同步</li>\n</ul>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>缺點</p>\n<ul>\n<li>Memento會額外占用記憶體</li>\n</ul>\n<h2 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h2><ul>\n<li>備份/還原(存/讀檔)</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>單詞Memento有「印象」、「紀念」的意思，有同名電影譯為「記憶拼圖」，在Persona5譯為「印象空間」</p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li>Wiki</li>\n<li>Head-First Design Pattern</li>\n<li>大話設計模式</li>\n<li>設計模式與遊戲開發的完美結合</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3R3bWh0LmdpdGh1Yi5pby9ibG9nL3Bvc3RzL2Rlc2lnbi1wYXR0ZXJuL21lbWVudG8uaHRtbA==\">http://twmht.github.io/blog/posts/design-pattern/memento.html<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n<!--TODO: 看三本書,補足 -->",
            "tags": [
                "設計模式",
                "備份",
                "備忘錄",
                "存檔"
            ]
        },
        {
            "id": "http://gitqwerty777.github.io/cleancode/",
            "url": "http://gitqwerty777.github.io/cleancode/",
            "title": "Clean Code(無瑕的程式碼)心得",
            "date_published": "2015-02-26T14:02:24.000Z",
            "content_html": "<h2 id=\"Chap01-動機\"><a href=\"#Chap01-動機\" class=\"headerlink\" title=\"Chap01 動機\"></a>Chap01 動機</h2><ol>\n<li>神就藏在細節裡: 一致性的縮排是程式低錯誤率的最顯著指標</li>\n<li>Later equals NEVER: 不及時清理 → 累積愈多難看的程式碼 → 愈難清理，所以更不想清理 → 直到修改的成本太高，只好重寫</li>\n<li>不夠好的程式碼使維護成本太高(你看得懂自己寫的code嗎？)</li>\n</ol>\n<p>讓開發速度變快的方法：隨時保持clean code</p>\n<h2 id=\"Chap02-Clean-Code-的定義\"><a href=\"#Chap02-Clean-Code-的定義\" class=\"headerlink\" title=\"Chap02 Clean Code 的定義\"></a>Chap02 Clean Code 的定義</h2><p>認為自己的code<strong>應該要有的樣子</strong>  </p>\n<p>CleanCode學派(作者)對此的定義   </p>\n<ul>\n<li>每個函式、類別、模組都能表達<strong>單一意圖</strong>，降低程式相依性</li>\n<li>易讀：不該使人猜測程式的意思<ul>\n<li>因為在寫新的程式碼前，要先花時間了解舊程式碼</li>\n<li>每個看到的程式，執行結果都與你想得差不多</li>\n</ul>\n</li>\n<li>抽象化：程式碼不重複</li>\n</ul>\n<h2 id=\"Chap03-原則\"><a href=\"#Chap03-原則\" class=\"headerlink\" title=\"Chap03 原則\"></a>Chap03 原則</h2><blockquote>\n<p>任何原則在特殊情形都是可以違反的，不須過於拘泥</p>\n</blockquote>\n<ul>\n<li>童子軍規則：離開的code比剛來時更乾淨</li>\n<li>寫軟體如同寫作，先把想法寫下來，然後開始啄磨，直到讀起來很通順。第一份初稿通常是粗糙而雜亂無章的，修改之後才會改善到想要的樣子。程式設計大師在寫程式時，並不認為自己是在寫程式，而是在說故事。</li>\n<li>寫程式時，只能專注在 「讓程式運作」或「讓程式整潔」其中之一，要先程式能動再清理；或是讓程式架構明確易懂再實作都可以。</li>\n</ul>\n<h3 id=\"有意義的命名\"><a href=\"#有意義的命名\" class=\"headerlink\" title=\"有意義的命名\"></a>有意義的命名</h3><ul>\n<li>有辦法唸出來的名稱，愈具體愈好</li>\n<li>用 define, enum, const 代替 常數<ul>\n<li><code>enum color{black, white}</code></li>\n<li>86400 → <code>SECOND_PER_DAY</code></li>\n<li>容易了解的數字就不用<ul>\n<li><code>circumference = radius * Math.PI * 2</code>: 不用將2換成實際名稱 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li>class：名詞或名詞片語<ul>\n<li><code>board</code> → <code>chessGameBoard</code></li>\n<li><code>address</code> → <code>portAddress</code>, <code>EmailAddress</code></li>\n<li><code>day</code> → <code>elapsedTimeInDays</code></li>\n</ul>\n</li>\n<li>method：動詞或動詞片語<ul>\n<li><code>flag</code> → <code>isFlagged()</code></li>\n<li><code>Complex c = Complex(23.0)</code> → <code>Complex c = Complex.FromRealNumber(23.0)</code><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5qYXZhd29ybGQuY29tLnR3L2p1dGUvcG9zdC92aWV3P2JpZD00NCZpZD0yNDgzMCZzdHk9MSZ0cGc9MSZhZ2U9LTE=\">使用靜態工廠<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>對特定功能使用一致的用詞<ul>\n<li><code>fetch</code>, <code>retreive</code>, <code>get</code> …</li>\n</ul>\n</li>\n<li>避免 <code>data</code>, <code>info</code>, <code>manager</code> 等意義較廣的字<ul>\n<li><code>accountList</code> → <code>accountGroup</code> (除非此變數真的是list型態)</li>\n<li><code>add()</code> → <code>insert()</code>, <code>append()</code></li>\n</ul>\n</li>\n<li>使用專有名詞<ul>\n<li><code>jobqueue</code></li>\n<li><code>timestamp</code></li>\n</ul>\n</li>\n<li>使用範圍較大的變數用較長的名稱<ul>\n<li>愈少用的函數名稱可以愈長</li>\n<li>for迴圈範圍較小，變數可以用<code>i</code>, <code>j</code><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//which is better?</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; RowNumber; i++)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; ColumnNumber; j++)</span><br><span class=\"line\">\t\t...</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> r = <span class=\"number\">0</span>; r &lt; RowNumber; r++)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> c = <span class=\"number\">0</span>; c &lt; ColumnNumber; c++)</span><br><span class=\"line\">\t\t...</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"函式\"><a href=\"#函式\" class=\"headerlink\" title=\"函式\"></a>函式</h3><ul>\n<li>一個函式只做在<strong>同一層級</strong>上的<strong>一件</strong>事情<ul>\n<li>以「無法再分割」為標準</li>\n</ul>\n</li>\n<li>長度：小於二十行(或一個螢幕的長度)</li>\n<li>不用switch：switch容易違反<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5kb3RibG9ncy5jb20udHcvaGF0ZWxvdmUvYXJjaGl2ZS8yMDEwLzEwLzE2L3NpbmdsZS1yZXNwb25zaWJpbGl0eS1wcmluY2lwbGUuYXNweA==\">單一職責原則<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9hZGFtL2FyY2hpdmUvMjAwOC8wNC8xOC8xMTU5MjgwLmh0bWw=\">開放閉合原則<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li>解法：<span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cubW9ua2V5cG90aW9uLm5ldC9nYW1lcHJvZy9wYXR0ZXJuL2Fic3RyYWN0LWZhY3Rvcnk=\">抽象工廠<i class=\"fa fa-external-link-alt\"></i></span><ul>\n<li>使用switch和多型</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>參數<ul>\n<li>愈少愈好($\\leq$ 三個)<ul>\n<li>太多參數時需要記順序，像是<code>strcpy()</code></li>\n<li>例外：四維象限中的座標(只算作一個參數)，<code>printf()</code>(只算作兩個參數)</li>\n</ul>\n</li>\n<li>避免用參數當回傳值<ul>\n<li>如 <code>void saveResult(FILE* f, int* returnStatus)</code>，使用returnStatus來作為回傳</li>\n<li>解法一：呼叫擁有變數的class，用其method來修改</li>\n<li>解法二：用return</li>\n<li>用例外處理取代回傳錯誤碼</li>\n</ul>\n</li>\n<li>通常只使用一個參數<ul>\n<li>用途一：取得參數的性質<ul>\n<li><code>boolean isFileExists(&quot;MyFile&quot;)</code></li>\n</ul>\n</li>\n<li>用途二：使用參數，然後回傳操作後的結果<ul>\n<li><code>InputStream fileOpen(&quot;MyFile&quot;)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>避免flag<ul>\n<li>代表函式不只做一件事<ul>\n<li>有flag和沒有flag做的事不同</li>\n</ul>\n</li>\n<li><code>render(bool isSuite)</code> → <code>renderForSuite()</code> + <code>renderForSingleTest()</code></li>\n</ul>\n</li>\n<li>減少參數的方法<ul>\n<li>將多個參數合成一個class</li>\n<li>拆成多個函式</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>命名<ul>\n<li>以「不用重複查看函式定義」為原則<ul>\n<li><code>write(name)</code> → <code>writeNameField(name)</code></li>\n<li><code>assertEquals(expected, actual)</code> → <code>assertExpectedEqualsActual(expected, actual)</code></li>\n</ul>\n</li>\n<li>描述可能的副作用<ul>\n<li><code>getOOS()</code> → <code>createOrReturnOOS()</code>: 呼叫時若無OOS的時候，可能會create</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>指令(command)與查詢(query)分離<ul>\n<li>此函式同時有查詢和進行動作的功能: <code>if(setAttribute(&quot;username&quot;, &quot;unclebob&quot;)) ...</code></li>\n<li>改進: <code>if(attributeExists(&quot;username&quot;)) setAttribute(&quot;username&quot;, &quot;unclebob&quot;);</code></li>\n</ul>\n</li>\n<li>適當的靜態(static)宣告<ul>\n<li>靜態方法用到的資料都從參數而來，而不是從任何擁有這個方法的物件得來</li>\n</ul>\n</li>\n<li>結構化程式設計準則<ul>\n<li>每個函式的區塊都應該只有一個進入點和一個離開點(沒有break, continue, goto，只有一個return)</li>\n<li>在函式夠短的情況下<strong>沒有必要</strong></li>\n</ul>\n</li>\n<li>暴露時序耦合<ul>\n<li>必須先執行<code>A()</code>再執行<code>B()</code>的函式</li>\n<li>原本C為member，改成傳參數：<code>cls.A(); cls.B();</code> → <code>C = cls.A(); cls.B(C);</code></li>\n</ul>\n</li>\n<li>常數宣告：放在適當的層級<ul>\n<li>將預設的常數放在呼叫的參數，而非被呼叫的函式內<ul>\n<li><code>getPageNameOrDefault(request, &quot;FrontPage&quot;)</code> //default is “FrongPage”</li>\n</ul>\n</li>\n<li>放在愈高階就愈容易修改</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"註解\"><a href=\"#註解\" class=\"headerlink\" title=\"註解\"></a>註解</h3><p>註解是輔助程式碼來表達意圖的工具</p>\n<ul>\n<li><p>有註解代表程式碼不夠易懂</p>\n</li>\n<li><p>愈少愈好</p>\n</li>\n<li><p>與其寫註解，不如把程式碼弄整潔</p>\n</li>\n<li><p>註解通常缺少維護</p>\n<ul>\n<li>容易產生許多過時的註解</li>\n<li>錯誤的註解比沒有註解可怕</li>\n</ul>\n</li>\n<li><p>必要的註解</p>\n<ol>\n<li>版權宣告</li>\n<li>舉例示範</li>\n<li>解釋意圖<ul>\n<li>對某個問題的解決方法</li>\n<li>使用的演算法</li>\n<li>解釋自己無法修改的程式碼(函式庫等)</li>\n</ul>\n</li>\n<li>警告<ul>\n<li>不希望被修改的地方</li>\n</ul>\n</li>\n<li>暫時記錄：<code>TODO</code>, <code>BUG</code>…</li>\n</ol>\n</li>\n<li><p>糟糕的註解</p>\n<ul>\n<li>浪費時間看，最後被忽略<ul>\n<li>沒有提供更多資訊<ul>\n<li><code>printBoard() // print board</code></li>\n</ul>\n</li>\n<li>過多的資訊</li>\n<li>被強迫寫的(通常就是不必要的)</li>\n</ul>\n</li>\n<li>已被版本控制軟體取代的功能<ul>\n<li>版本變動記錄</li>\n<li>註解掉的程式碼</li>\n</ul>\n</li>\n<li>過度使用標誌<ul>\n<li>如 <code>// comment //////////////////</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"排版\"><a href=\"#排版\" class=\"headerlink\" title=\"排版\"></a>排版</h3><ul>\n<li>偏好小檔案(200-500行)</li>\n<li>報紙型編排：先出現標題(高階概念、演算法)，再來是內容(低階函式)<ul>\n<li>最重要的概念先出現，用最少的資訊來表達，再來才是實作細節</li>\n</ul>\n</li>\n<li>垂直距離：類似的概念應盡可能靠近<ul>\n<li>空白行用來分隔思緒，概念(類似文章分段)<ul>\n<li>做相似工作的函式愈近愈好</li>\n</ul>\n</li>\n<li>變數宣告的位置：靠近變數被使用的地方<ul>\n<li>若函式夠短，可在函式最上方宣告</li>\n</ul>\n</li>\n<li>降層準則<ul>\n<li>函式後面為其呼叫的函式，易於閱讀</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>將常數宣告放在一個大家比較容易找到的地方</li>\n<li>寬度：不要超過螢幕<ul>\n<li>通常會限制在80字<ul>\n<li>不過現在都是寬螢幕了，影響不大</li>\n</ul>\n</li>\n<li>使用空白強調運算子的優先權<ul>\n<li><code>b*b - 4*a*c</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"物件及資料結構\"><a href=\"#物件及資料結構\" class=\"headerlink\" title=\"物件及資料結構\"></a>物件及資料結構</h3><blockquote>\n<p>你知道的太多了…</p>\n</blockquote>\n<p>變數保持私有的理由，不希望有人依賴此變數，保持一個自由的空間，讓我們能自由的更改變數的型態，或是在突如其來的奇想或衝動時，能自由的變更實現內容的程式碼。</p>\n<p>那為什麼有這麼多的程式設計師，自動替他們的物件加上getter和setter，讓他們的私有度數如同公用變數呢？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//完全暴露實現</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">double</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">double</span> y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//抽象化：無法分辨實現</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> interface Point &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getX</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getY</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setCartesian</span><span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">double</span> y)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getR</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getTheta</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setPolar</span><span class=\"params\">(<span class=\"keyword\">double</span> r, <span class=\"keyword\">double</span> theta)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>利用抽象化的詞彙來表達資料。這並不是只透過介面及讀取、設定函式就能完成。想辨法找到最能詮釋「資料抽象概念」的方式。<br>而最差的作法，則是天真地加上讀取函式及設定函式而已。</p>\n<p>1.物件</p>\n<ul>\n<li>private member，public method</li>\n<li>將實現的過程隱藏(封裝)</li>\n<li>用抽象詞彙表達資料<ul>\n<li><code>getGallonsOfGasoline()</code> → <code>getPercentFuelRemaining()</code></li>\n</ul>\n</li>\n<li><strong>要讓每件事物都是一個物件是一個神話</strong>(Java表示：)</li>\n</ul>\n<p>2.資料結構: map, set, array …</p>\n<ul>\n<li>暴露資料(public member)<ul>\n<li>為資料結構設getter和setter是多此一舉</li>\n</ul>\n</li>\n</ul>\n<p>物件與資料結構的互補</p>\n<ul>\n<li>物件：新資料型態的彈性 ↔ 資料結構：新行為的彈性<ul>\n<li>資料結構容易添加函式，而不用更改現有的資料結構</li>\n<li>物件容易添加新的類別(繼承)，而不用更改現有的函式</li>\n</ul>\n</li>\n<li>混合體只會得到兩者的缺點</li>\n</ul>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3poLndpa2lwZWRpYS5vcmcvd2lraS8lRTUlQkUlOTclRTUlQTIlQTglRTUlQkYlOTIlRTglODAlQjMlRTUlQUUlOUElRTUlQkUlOEI=\">The law of Demeter<i class=\"fa fa-external-link-alt\"></i></span>  </p>\n<ul>\n<li>模組不該知道關於它所操縱<strong>物件</strong>的<strong>內部運作</strong></li>\n<li>違反原則: 火車連結<ul>\n<li><code>String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath()</code></li>\n<li>改進(仍然知道底層操作)<ul>\n<li><code>Options opts = ctxt.getOptions();</code></li>\n<li><code>File scratchDir = opts.getScratchDir();</code></li>\n<li><code>String outputDir = scratchDir.getAbsolutePath();</code></li>\n</ul>\n</li>\n<li>若 ctxt, options 為資料結構，則以下可行<ul>\n<li><code>outputDir = ctxt.options.scratchDir.absolutePath</code></li>\n</ul>\n</li>\n<li>若是物件，則我們應該要告訴 ctxt 去<strong>做某件事情</strong><ul>\n<li>和其他程式碼合併 : <code>BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName)</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>可調整的資料應放在高層次</p>\n<ul>\n<li>底層不應存放參數</li>\n<li>放在高階層比較好找，也比較好修改</li>\n</ul>\n<p>One Switch原則</p>\n<ul>\n<li>對於給定的變數，不應該有超過一個以上的switch敘述。在那個唯一的Switch敘述中的多個case，必須建立多型物件以取代其他case。</li>\n</ul>\n<h3 id=\"錯誤處理\"><a href=\"#錯誤處理\" class=\"headerlink\" title=\"錯誤處理\"></a>錯誤處理</h3><ul>\n<li>定義正常的流程<ul>\n<li>使用<span class=\"exturl\" data-url=\"aHR0cDovL21hcnRpbmZvd2xlci5jb20vZWFhQ2F0YWxvZy9zcGVjaWFsQ2FzZS5odG1s\">特殊情況物件(special case pattern)<i class=\"fa fa-external-link-alt\"></i></span>替代<code>if()</code>檢查<ul>\n<li>將特殊情況包在特殊情況物件</li>\n<li>特殊情況物件處理例外</li>\n</ul>\n</li>\n<li>包裹第三方程式庫<ul>\n<li>減少依頼，容易更換</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>使用 例外處理(try-catch-finally) 取代回傳error code<ul>\n<li>例外處理是「一件事」<ul>\n<li>error code 必須在呼叫結束之後立即檢查錯誤</li>\n<li>提取try和catch的內容，成為新函式</li>\n<li>用class包裹例外，此class只處理例外</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>不要傳遞NULL<ul>\n<li>要檢查值是不是NULL，很麻煩<ul>\n<li>所有函式都不return NULL → 都不用檢查</li>\n</ul>\n</li>\n<li>解決<ul>\n<li>回傳特殊情況物件<ul>\n<li>例：找不到時，回傳空list</li>\n</ul>\n</li>\n<li>使用例外處理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Java：<span class=\"exturl\" data-url=\"aHR0cDovL3RlZGR5LWNoZW4tdHcuYmxvZ3Nwb3QudHcvMjAxMS8wNS9jaGVja2VkLW9yLXVuY2hlY2tlZC1leGNlcHRpb25zLTEuaHRtbA==\">使用不檢查型例外：<i class=\"fa fa-external-link-alt\"></i></span>，<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zbGlkZXNoYXJlLm5ldC90ZWRkeXNvZnQvamF2YWNoZWNrZWR1bmNoZWNrZWQtZXhjZXB0aW9ucw==\">(檢查和不檢查型例外)<i class=\"fa fa-external-link-alt\"></i></span>，因為其破壞開放閉合原則，修改低階函式時也需要修改高階函式</li>\n<li>將邊界條件的檢查放置於同一個地方，不要散佈在程式的各個角落</li>\n</ul>\n<h3 id=\"邊界\"><a href=\"#邊界\" class=\"headerlink\" title=\"邊界\"></a>邊界</h3><blockquote>\n<p>註：從這章之後大多是一章一個作者，所以頗有矛盾和重復的地方</p>\n</blockquote>\n<p>使用第三方API</p>\n<ul>\n<li>學習性測試<ul>\n<li>寫一些測試程式來了解第三方軟體</li>\n<li>第三方軟體改版後也能用來確定行為是否改變</li>\n</ul>\n</li>\n<li>包裹第三方API<ul>\n<li><code>public void open() { try{innerPort.open();} ... }</code></li>\n<li>好處<ul>\n<li>掌握控制程式的權利</li>\n<li>在API未知的情況可以繼承此interface，創造一個Fake API來測試</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"單元測試\"><a href=\"#單元測試\" class=\"headerlink\" title=\"單元測試\"></a>單元測試</h3><p>有了測試程式(和版本控制系統)就不會害怕修改程式！</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2dsaXlhby5sb2dkb3duLmNvbS9wb3N0cy8yMDE0LzAxLzE4L3NvZnR3YXJlLXRhbGstYWJvdXQtdGVzdC1kcml2ZW4tZGV2ZWxvcG1lbnQtdGVzdC1kcml2ZW4tZGV2ZWxvcG1lbnQtaQ==\">測試驅動開發(TDD)<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5idXR1bmNsZWJvYi5jb20vQXJ0aWNsZVMuVW5jbGVCb2IuVGhlVGhyZWVSdWxlc09mVGRk\">The Three Rules of TDD<i class=\"fa fa-external-link-alt\"></i></span></p>\n<ol>\n<li>先寫測試程式，再寫對應的實作程式</li>\n<li>只寫<strong>剛好</strong>無法通過的單元測試<ol>\n<li>測試無法通過時，應該要修復實作程式</li>\n</ol>\n</li>\n<li>只寫<strong>剛好</strong>能通過測試的程式<ol>\n<li>測試無法通過時，只能寫和測試有關的實作程式，不能寫其他功能</li>\n</ol>\n</li>\n</ol>\n<p><strong>測試程式和產品程式一樣重要</strong></p>\n<p>測試方法</p>\n<ul>\n<li>使用涵蓋率工具(Coverage Tool)<ul>\n<li>檢查是否每行程式都有被執行過</li>\n</ul>\n</li>\n<li>測試邊界條件</li>\n</ul>\n<p>原則</p>\n<ul>\n<li>測試的程式碼也需要整潔<ul>\n<li>最重要的是可讀性，效率是其次</li>\n</ul>\n</li>\n<li>建造-操作-檢查（BUILD-OPERATE-CHECK）<ul>\n<li>產生數據，操作之，再檢查正確性</li>\n<li>GIVEN-WHEN-THEN<ul>\n<li>Given: 前提、環境</li>\n<li>When: 發生事情</li>\n<li>Then: 預期結果</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>一個測試只用一個assert</li>\n<li>在錯誤的程式碼附近進行詳盡的測試<ul>\n<li>因為Bug往往聚集</li>\n</ul>\n</li>\n</ul>\n<p>測試程式的 F.I.R.S.T. 法則</p>\n<ul>\n<li>Fast：快速(足夠快即可)</li>\n<li>Independent：可個別獨立執行</li>\n<li>Repeatable：可在任何環境重複執行</li>\n<li>Self-Validating：輸出bool值(成功/失敗)，而不是記錄檔<ul>\n<li>不用做額外的檢查</li>\n</ul>\n</li>\n<li>Timely：先寫測試再實作</li>\n</ul>\n<h3 id=\"類別\"><a href=\"#類別\" class=\"headerlink\" title=\"類別\"></a>類別</h3><ul>\n<li>凝聚性：方法內使用愈多變數，代表這個方法更屬於這個類別<ul>\n<li>為了保持凝聚性，會產生許多小類別</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>把工具放在有許多標記的小型工具箱裡，比少量的大抽屜，然後將所有的東西都丟進去好。</p>\n</blockquote>\n<p>不應該對相依的模組有預先的假設(即邏輯上的相依)，應該清楚的詢問所需的有關訊息(即實體上的相依)。<!--??--></p>\n<h3 id=\"系統\"><a href=\"#系統\" class=\"headerlink\" title=\"系統\"></a>系統</h3><p>如同建造城市，某些人負責整體規劃，其它人專注在細節執行。<br>進行抽象化和模組化，將所有關注的事分離開來</p>\n<ul>\n<li>工廠模式：<strong>將建造和使用分離</strong></li>\n</ul>\n<p>相依性注入<span class=\"exturl\" data-url=\"aHR0cDovL2h1YW4tbGluLmJsb2dzcG90LmNvbS8yMDExLzEwL2RlcGVuZGVuY3ktaW5qZWN0aW9uLTEuaHRtbA==\">(1)<i class=\"fa fa-external-link-alt\"></i></span><span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzA3OTQvd2hhdC1pcy1kZXBlbmRlbmN5LWluamVjdGlvbg==\">(2)<i class=\"fa fa-external-link-alt\"></i></span></p>\n<ul>\n<li>控管反轉<ul>\n<li>將第二個職責移到其它專注於該職責的物件裡</li>\n</ul>\n</li>\n</ul>\n<p>擴大</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLXR3LyVFNSU4RCU4MSVFNSVBNCVBNyVFNSVCQiVCQSVFOCVBOCVBRCMuRTguQTkuOTUuRTUuODMuQjk=\">誰有辦法預期小鎮的成長，而在鎮上先鋪好六線道高速公路？<i class=\"fa fa-external-link-alt\"></i></span><ul>\n<li>讓系統一開始就做對，是一個神話</li>\n<li>應該只實現今天的故事(即目前的需求)，然後重構它，並且明天再進行系統的擴充</li>\n</ul>\n</li>\n<li>剖面導向程式設計AOP<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kv6Z2i5ZCR5L6n6Z2i55qE56iL5bqP6K6+6K6h\">(1)<i class=\"fa fa-external-link-alt\"></i></span><span class=\"exturl\" data-url=\"aHR0cHM6Ly9vcGVuaG9tZS5jYy9Hb3NzaXAvU3ByaW5nR29zc2lwL0FPUENvbmNlcHQuaHRtbA==\">(2)<i class=\"fa fa-external-link-alt\"></i></span><ul>\n<li>剖面(aspect)<ul>\n<li>系統中某個關注點的行為，需要用一致性的方式修改<ul>\n<li>如日誌記錄(log)、資料庫、安全性、暫存快取</li>\n<li>紀錄檔功能往往橫跨系統中的每個業務模組，即「橫切」所有有紀錄檔需求的類及方法體</li>\n</ul>\n</li>\n<li>為應用程式基礎架構</li>\n</ul>\n</li>\n<li>保持適當的關注點分離</li>\n</ul>\n</li>\n</ul>\n<p><strong>不需要「先作大型設計」</strong>，因為不希望浪費先前的努力，這個設計會阻止你改進程式架構。</p>\n<p>有時候拖延至最後一刻是最好的作法，這讓我們得以運用最多的資訊進行選擇。</p>\n<p>系統需要特定領域的語言(Domain-Specific Language), 讓領域專家可以把程式寫得像是散文的結構，而且領域概念和實作程式碼相似，減少轉換錯誤。</p>\n<h4 id=\"剖面範例\"><a href=\"#剖面範例\" class=\"headerlink\" title=\"剖面範例\"></a>剖面範例</h4><ol>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL29wZW5ob21lLmNjL0dvc3NpcC9TcHJpbmdHb3NzaXAvRnJvbVByb3h5VG9BT1AuaHRtbA==\">Java代理機制<i class=\"fa fa-external-link-alt\"></i></span><ol>\n<li>代理可以呼叫被代理物件的函式，也可以進行剖面的行為</li>\n</ol>\n</li>\n<li>Java AOP框架<ol>\n<li>Spring AOP</li>\n<li>JBoss AOP</li>\n</ol>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemwzNDUwMzQxL2FydGljbGUvZGV0YWlscy83NjczOTM4\">AspectJ<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ol>\n<blockquote>\n<p>一個理想的架構，包含模組化的關注點，每個關注點都用一個普通物件實作。 不同領域之間利用最小侵入性的剖面工具整合。 這樣的架構就可以是測試驅動的(test-driven)，如同程式碼一樣。</p>\n</blockquote>\n<h3 id=\"簡單設計守則\"><a href=\"#簡單設計守則\" class=\"headerlink\" title=\"簡單設計守則\"></a>簡單設計守則</h3><ol>\n<li>執行完所有的測試</li>\n<li>程式重構：重要性 1 &gt; 2 &gt; 3<ol>\n<li>消除重複<ol>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLXR3LyVFNiVBOCVBMSVFNiU5RCVCRiVFNiU5NiVCOSVFNiVCMyU5NQ==\">樣版方法(Template Method)<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li>大部份設計模式都是在提供消除重複的策略</li>\n<li>物件導向是用來組織模組和消除重複的策略</li>\n</ol>\n</li>\n<li>具表達力</li>\n<li>最小化類別及方法數量</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"平行化\"><a href=\"#平行化\" class=\"headerlink\" title=\"平行化\"></a>平行化</h3><blockquote>\n<p>物件是處理過程的抽象化，執行緒是排程的抽象化</p>\n</blockquote>\n<p>將「做什麼」和「何時做」分解開來，像是Web應用的Servlet模型<br>當獲得一個網頁請求時，servlet會以非同步方式執行，不需要管理所有的請求，每一個servlet都在其自我的小小世界裡執行。</p>\n<p>缺點</p>\n<ul>\n<li>需要修改程式碼/架構</li>\n<li>速度不一定變快(有overhead)</li>\n<li>很難寫正確，因為很難重現bug</li>\n</ul>\n<p>建議</p>\n<ul>\n<li>將平行化的程式碼和其他程式碼分開</li>\n<li>保護資料<ul>\n<li>限制共享資料的存取次數<ul>\n<li>減少critical section的使用次數</li>\n</ul>\n</li>\n<li>限制資料的視野<ul>\n<li>mutex lock(c), synchronized(java)</li>\n<li>避免在一個共享物件上使用多個方法</li>\n</ul>\n</li>\n<li>使用資料的複本<ul>\n<li>由一個執行緒負責合併結果</li>\n<li>每個執行緒盡可能獨立運行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>測試<ul>\n<li>偽造/產生失敗以測試</li>\n<li>讓平行化的程式可以開關平行化的功能</li>\n<li>在不同的平台測試</li>\n<li>執行比處理器數量還多的執行緒<ul>\n<li>強迫進行task swapping</li>\n</ul>\n</li>\n<li>調整參數(執行緒數量、重複執行次數)</li>\n<li>正確的關閉程式<ul>\n<li>防止deadlock</li>\n</ul>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5pYm0uY29tL2RldmVsb3BlcndvcmtzL2NuL2phdmEvai1jb250ZXN0Lmh0bWw=\">用IBM contest找BUG<i class=\"fa fa-external-link-alt\"></i></span><ul>\n<li>不一定會照順序執行</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>實作</p>\n<ul>\n<li>ReentrantLock<ul>\n<li>一般的鎖</li>\n</ul>\n</li>\n<li>Semaphore號誌<ul>\n<li>有計數功能的鎖</li>\n</ul>\n</li>\n<li>CountDownLatch<ul>\n<li>先等待指定數量的事件，使得所有的執行緒都有公平的機會，在同時間啟動</li>\n</ul>\n</li>\n</ul>\n<p>模型</p>\n<ul>\n<li>生產-消費<ul>\n<li>有限資源</li>\n<li>生產者放工作入queue</li>\n<li>消費者取出工作</li>\n</ul>\n</li>\n<li>讀取-寫入<ul>\n<li>平衡reader和writer的需求，避免某一方飢餓(starvation)</li>\n<li>簡單方法：writer等到沒有reader使用時再write<ul>\n<li>writer容易starve</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>哲學家用餐<ul>\n<li>雙手都拿到刀叉時才能用餐</li>\n<li>大程式的資源爭奪問題</li>\n</ul>\n</li>\n</ul>\n<p>詳見<a href=\"/parallel-programming\">平行程式設計</a></p>\n<h3 id=\"程式碼的異味\"><a href=\"#程式碼的異味\" class=\"headerlink\" title=\"程式碼的異味\"></a>程式碼的異味</h3><blockquote>\n<p>聖人見微以知萌，見端以知末，故見象箸而怖，知天下不足也。<br>韓非子．說林上</p>\n</blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU0JUJCJUEzJUU3JUEwJTgxJUU1JUJDJTgyJUU1JTkxJUIz\">程式碼的異味(Code Smell)<i class=\"fa fa-external-link-alt\"></i></span>:<br>程式碼中的任何可能導致深層問題的<strong>症狀</strong></p>\n<ol>\n<li>一份檔案有多種程式語言</li>\n<li>明顯該有的行為未實現</li>\n<li>在邊界條件的不正確行為<ol>\n<li>封裝邊界條件: 將邊界條件的集中處理<ol>\n<li><code>int nextLevel = level+1; //boundary condition</code></li>\n</ol>\n</li>\n</ol>\n</li>\n<li>無視編譯器警告</li>\n<li>否定的判斷式<ol start=\"2\">\n<li>改善 <code>if(!buffer.isFull())</code> → <code>if(buffer.isNotFull())</code></li>\n</ol>\n</li>\n<li>過多的資訊<ol start=\"4\">\n<li>類別擁有的變數、方法數量愈少愈好、方法擁有的變數愈少愈好</li>\n</ol>\n</li>\n<li>不一致性<ol start=\"5\">\n<li>命名的一致性：對於同一個物件，在不同函式中的實體使用相同的名稱</li>\n<li>行為的一致性：用同樣的方式來完成所有類似的事</li>\n</ol>\n</li>\n<li>特色留戀(Feature Envy)<ol start=\"7\">\n<li>使用其他物件的getter或setter</li>\n<li>有時候是必要之惡：放入別的物件會違反其他OOP的原則(此例：單一職責、開放閉合原則等)<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//demo of feature envy</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> clas HourlyEmployeeReport&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> HourlyEmployee employee;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">reportHours</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> String.Format(</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"Name:%s, Hours:%d.%ld\\n\"</span>,</span><br><span class=\"line\">\t\t\temployee.getName(),</span><br><span class=\"line\">\t\t\temployee.getTenthsWorked()/<span class=\"number\">10</span>,</span><br><span class=\"line\">\t\t\temployee.getTenthsWorked()%<span class=\"number\">10</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vemgtdHcvbGlicmFyeS9kbjM4NzU2OC5hc3B4\">30天快速上手 TDD<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdmVyeWl0bWFuL2FydGljbGUvZGV0YWlscy82OTM3NjA0\">The Principles of Good Programming<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n",
            "tags": [
                "程式",
                "CleanCode",
                "重構",
                "TDD",
                "設計模式"
            ]
        }
    ]
}