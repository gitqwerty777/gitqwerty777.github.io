{
    "version": "https://jsonfeed.org/version/1",
    "title": "QWERTY • All posts by \"函式庫\" tag",
    "description": "Programming | Computer Science | Thought",
    "home_page_url": "http://gitqwerty777.github.io",
    "items": [
        {
            "id": "http://gitqwerty777.github.io/cpp-boost/",
            "url": "http://gitqwerty777.github.io/cpp-boost/",
            "title": "C++ boost 簡單應用",
            "date_published": "2015-07-14T07:18:44.000Z",
            "content_html": "<!-- RENEW: -->\n\n<h2 id=\"簡介\"><a href=\"#簡介\" class=\"headerlink\" title=\"簡介\"></a>簡介</h2><p>C++的著名擴充函式庫</p>\n<p>功能(節錄)：</p>\n<ul>\n<li>regex</li>\n<li>function binding</li>\n<li>lambda functions</li>\n<li>unit tests</li>\n<li>smart pointers</li>\n<li>noncopyable, optional</li>\n<li>serialization</li>\n<li>generic dates</li>\n<li>portable filesystem</li>\n<li>circular buffers</li>\n<li>config utils</li>\n<li>generic image library</li>\n<li>program options</li>\n<li>threads</li>\n</ul>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ib29zdC5vcmcvZG9jL2xpYnMvMV81OF8wL2xpYnMvbGlicmFyaWVzLmh0bQ==\">所有功能<i class=\"fa fa-external-link-alt\"></i></span></p>\n<a id=\"more\"></a>\n\n<p>安裝：<code>sudo apt-get install libboost-all-dev</code></p>\n<h2 id=\"基本功能\"><a href=\"#基本功能\" class=\"headerlink\" title=\"基本功能\"></a>基本功能</h2><p>簡化語法</p>\n<h3 id=\"foreach\"><a href=\"#foreach\" class=\"headerlink\" title=\"foreach\"></a>foreach</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;boost/foreach.hpp&gt;</span></span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> <span class=\"title\">hello</span><span class=\"params\">( <span class=\"string\">\"Hello, world!\"</span> )</span></span>;</span><br><span class=\"line\">  BOOST_FOREACH( <span class=\"keyword\">char</span> ch, hello )&#123; <span class=\"comment\">// equals to for (auto c : hello) in c03                          </span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; ch &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//convient way to use</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> foreach BOOST_FOREACH</span></span><br></pre></td></tr></table></figure>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5hcnRpbWEuY29tL2NwcHNvdXJjZS9mb3JlYWNoLmh0bWw=\">實作方法<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"lexical-cast\"><a href=\"#lexical-cast\" class=\"headerlink\" title=\"lexical_cast\"></a>lexical_cast</h3><p>可以轉換成其他格式</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;boost/lexical_cast.hpp&gt;</span></span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">double</span> j = <span class=\"number\">233.211321231</span>;                              </span><br><span class=\"line\"><span class=\"built_in\">string</span> mystring = boost::lexical_cast&lt;<span class=\"built_in\">string</span>&gt;(j);</span><br><span class=\"line\"><span class=\"keyword\">double</span> k = boost::lexical_cast&lt;<span class=\"keyword\">double</span>&gt;(mystring);<span class=\"comment\">//k = 233.211</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split\"></a>split</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;boost/algorithm/string.hpp&gt;</span></span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"built_in\">string</span> stringtobesplit = <span class=\"string\">\"AA/BB-CC\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; tokens;</span><br><span class=\"line\">boost::split(tokens, stringtobesplit, boost::is_any_of(<span class=\"string\">\"/\\-\"</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Smart-Pointers\"><a href=\"#Smart-Pointers\" class=\"headerlink\" title=\"Smart Pointers\"></a>Smart Pointers</h3><p><span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81Njk3NzUvc21hcnQtcG9pbnRlcnMtYm9vc3QtZXhwbGFpbmVk\">Basic properties of smart pointers<i class=\"fa fa-external-link-alt\"></i></span></p>\n<ul>\n<li>no ownership at all<ul>\n<li>smart pointer cannot delete the object, because it doesn’t own it</li>\n</ul>\n</li>\n<li>transfer of ownership<ul>\n<li>only one smart pointer can ever point to the same object at the same time</li>\n<li>If the smart pointer is to be returned from functions, the ownership is transferred to the returned smart pointer</li>\n<li>Transfer of ownership cannot really be implemented in C++ currently, because object will be copied after return<ul>\n<li>only can use the copy constructor to implement that transfer of ownership</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>share of ownership<ul>\n<li>multiple smart pointers can point to the same object at the same time</li>\n<li>can be implemented by having a copy constructor</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Categorizing-smart-pointers\"><a href=\"#Categorizing-smart-pointers\" class=\"headerlink\" title=\"Categorizing smart pointers\"></a>Categorizing smart pointers</h4><ul>\n<li><code>scoped_ptr</code><ul>\n<li>neither transferable nor sharable (= normal pointer)</li>\n<li>when it goes out of scope, it is destroyed</li>\n</ul>\n</li>\n<li><code>shared_ptr</code><ul>\n<li>shares ownership</li>\n<li>reference counted so it can see when the last copy of it goes out of scope and then it frees the object automatically</li>\n<li>所有使用同一筆資料的指標都不再使用後自動釋放</li>\n</ul>\n</li>\n<li><code>weak_ptr</code><ul>\n<li>non-owning smart pointer</li>\n<li>reference a managed object (managed by a shared_ptr) so it will not add a reference count<ul>\n<li>If you need to access the object, you can lock the management of it (to avoid that in another thread a shared_ptr frees it while you use the object)</li>\n</ul>\n</li>\n<li>If <code>weak_ptr</code> points to an object already deleted, it will notice you by throwing an exception</li>\n<li>It is most beneficial when you have a cyclic reference: Reference counting cannot easily cope with such a situation</li>\n</ul>\n</li>\n<li><code>intrusive_ptr</code><ul>\n<li>like a shared_ptr <ul>\n<li>does not keep the reference count in a shared_ptr</li>\n<li>but call helper functions to increse/decrese the count <ul>\n<li>helper function need to be defined by the object that is managed</li>\n<li>reference count is not anymore internal to the smart pointer, but the smart pointer uses an existing reference counting mechanism</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>typically used when there is a 3rd party smart ptr you must use</li>\n</ul>\n</li>\n<li><code>unique_ptr</code><ul>\n<li>transfer of ownership pointer</li>\n<li>cannot copy it, but can move it by using C++1x’s <code>move</code> constructors</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt; scoped_ptr&lt;T&gt; &gt; tPtrVec;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     <span class=\"function\">scoped_ptr&lt;T&gt; <span class=\"title\">tPtr</span><span class=\"params\">(<span class=\"keyword\">new</span> T())</span></span>;</span><br><span class=\"line\">     tPtrVec.push_back(tPtr);</span><br><span class=\"line\">     <span class=\"comment\">// raw T* is freed</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">tPtrVec[<span class=\"number\">0</span>]-&gt;DoSomething(); <span class=\"comment\">// accessing freed memory</span></span><br><span class=\"line\"><span class=\"comment\">//--------------------------------------</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt; <span class=\"built_in\">shared_ptr</span>&lt;T&gt; &gt; tPtrVec;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">tPtr</span><span class=\"params\">(<span class=\"keyword\">new</span> T())</span></span>;</span><br><span class=\"line\">     <span class=\"comment\">// This copy to tPtrVec.push_back and ultimately to the vector storage</span></span><br><span class=\"line\">     <span class=\"comment\">// causes the reference count to go from 1-&gt;2</span></span><br><span class=\"line\">     tPtrVec.push_back(tPtr);</span><br><span class=\"line\">     <span class=\"comment\">// num references to T goes from 2-&gt;1 on the destruction of tPtr</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">tPtrVec[<span class=\"number\">0</span>]-&gt;DoSomething(); <span class=\"comment\">// raw T* still exists, so this is safe</span></span><br><span class=\"line\"><span class=\"comment\">//--------------------------------------</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt; weak_ptr&lt;T&gt; &gt; tPtrVec;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">tPtr</span><span class=\"params\">(<span class=\"keyword\">new</span> T())</span></span>;</span><br><span class=\"line\">     tPtrVec.push_back(tPtr);</span><br><span class=\"line\">     <span class=\"comment\">// num references to T goes from 1-&gt;0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; tPtrAccessed =  tPtrVec[<span class=\"number\">0</span>].lock();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (tPtrAccessed[<span class=\"number\">0</span>].get() == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">     <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Raw T* was freed, can't access it\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">     tPtrVec[<span class=\"number\">0</span>]-&gt;DoSomething(); <span class=\"comment\">// raw </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//--------------------------------------</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;type&gt; <span class=\"title\">p</span><span class=\"params\">(<span class=\"keyword\">new</span> type)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;type&gt; <span class=\"title\">q</span><span class=\"params\">(p)</span></span>; <span class=\"comment\">// not legal!</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;type&gt; <span class=\"title\">r</span><span class=\"params\">(move(p))</span></span>; <span class=\"comment\">// legal. p is now empty and r owns the object</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;type&gt; <span class=\"title\">s</span><span class=\"params\">(function_returning_a_unique_ptr())</span></span>; <span class=\"comment\">// legal!</span></span><br></pre></td></tr></table></figure>\n\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuY3Nkbi5uZXQvam51X3NpbWJhL2FydGljbGUvZGV0YWlscy85NTY5NTkz\">Chinese Explaination<i class=\"fa fa-external-link-alt\"></i></span></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;boost/shared_ptr.hpp&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">safeclose</span><span class=\"params\">(FILE*fp)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fp) &#123;</span><br><span class=\"line\">        fclose(fp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">some_fn</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">boost::<span class=\"built_in\">shared_ptr</span>&lt;FILE&gt; <span class=\"title\">fp</span><span class=\"params\">( fopen(myfilename, <span class=\"string\">\"a+t\"</span>), safeclose )</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//body of the function, and when ever it exits the file gets closed</span></span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>( fp.get(), <span class=\"string\">\"a message\\n\"</span> );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjU1ODAvd2hhdC1hcmUtdGhlLWFkdmFudGFnZXMtb2YtdXNpbmctdGhlLWMtYm9vc3QtbGlicmFyaWVz\">Advantage of using boost libraries<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMjU5MDYvbW9zdC11c2VkLXBhcnRzLW9mLWJvb3N0\">Most used parts of boost<i class=\"fa fa-external-link-alt\"></i></span></p>\n",
            "tags": [
                "C++",
                "boost",
                "函式庫"
            ]
        }
    ]
}