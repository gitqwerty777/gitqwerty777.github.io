{
    "version": "https://jsonfeed.org/version/1",
    "title": "QWERTY • All posts by \"clang\" tag",
    "description": "Programming | Computer Science | Thought",
    "home_page_url": "http://gitqwerty777.github.io",
    "items": [
        {
            "id": "http://gitqwerty777.github.io/cpp-compile-speed/",
            "url": "http://gitqwerty777.github.io/cpp-compile-speed/",
            "title": "加快C++編譯速度的方法",
            "date_published": "2017-05-23T12:44:30.000Z",
            "content_html": "<h2 id=\"編譯速度慢的原因\"><a href=\"#編譯速度慢的原因\" class=\"headerlink\" title=\"編譯速度慢的原因\"></a>編譯速度慢的原因</h2><p>因為C++ <code>.h</code> + <code>.cpp</code> 的編譯模型<br>每個cpp檔可能會包含上百甚至上千個<code>.h</code>檔，這些<code>.h</code>檔都會被讀進來一遍，然後被解析一遍。<br>每個編譯單元都會產生一個<code>.obj</code>文件，然後所以這些<code>.obj</code>文件會被link到一起，並且這個過程很難平行。重複load與解析，以及密集的IO，使編譯速度很慢。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"代碼角度\"><a href=\"#代碼角度\" class=\"headerlink\" title=\"代碼角度\"></a>代碼角度</h2><h3 id=\"前置聲明\"><a href=\"#前置聲明\" class=\"headerlink\" title=\"前置聲明\"></a>前置聲明</h3><p>在<code>.h</code>檔中使用前置聲明(forward declaration)，而不是直接包含<code>.h</code>檔。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>;</span> <span class=\"comment\">//forward declaration, instead #include \"a.h\"</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&#123;</span></span><br><span class=\"line\">    A* a;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">useA</span><span class=\"params\">(A&amp; a)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span> <span class=\"comment\">//cannot use forward declaration because compiler needs to know what A really is</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>&#123;</span></span><br><span class=\"line\">    A a;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>要盡一切可能使<code>.h</code>檔精簡</strong>。<br>很多時候前置聲明某個namespace中的class會比較痛苦，而直接include會方便很多，千萬要抵制住這種誘惑；class的成員，函數參數等也儘量用reference或pointer。</p>\n<h3 id=\"使用Pimpl模式\"><a href=\"#使用Pimpl模式\" class=\"headerlink\" title=\"使用Pimpl模式\"></a>使用Pimpl模式</h3><p>Pimpl為Private Implementation<br>傳統的C++的class的接口與實現是混淆在一起的，而Pimpl這種做法使得class的接口與實現得以完全分離。<br>如此，只要class的公共接口保持不變，對class實現的修改始終只需編譯該cpp；同時，該class提供給外界的.h檔也會精簡許多。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    A();</span><br><span class=\"line\">    ~A();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Impl</span>;</span><span class=\"comment\">//real implementation in this class</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">auto_ptr</span>&lt;impl&gt; m_impl;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"高度模塊化\"><a href=\"#高度模塊化\" class=\"headerlink\" title=\"高度模塊化\"></a>高度模塊化</h3><p>模塊化就是低耦合，就是儘可能的減少相互依賴。</p>\n<ol>\n<li>文件與文件之間，一個<code>.h</code>檔的變化，儘量不要引起其他文件的重新編譯。</li>\n<li>工程與工程之間，對一個工程的修改，儘量不要引起太多其他工程的編譯。這就要求<code>.h</code>檔，或者工程的內容一定要單一，不要什麼東西都往裡面塞，從而引起不必要的依賴。</li>\n</ol>\n<p>不要把兩個不相關的class，或者沒什麼聯繫的macro定義放到一個<code>.h</code>檔裡；內容要儘量單一。</p>\n<p>把代碼中最常用到的那些<code>.h</code>檔找出來，然後分成多個獨立的小文件，效果相當可觀。</p>\n<h3 id=\"刪除冗餘的header檔\"><a href=\"#刪除冗餘的header檔\" class=\"headerlink\" title=\"刪除冗餘的header檔\"></a>刪除冗餘的header檔</h3><p>一些代碼經過上十年的開發與維護，經手的人無數，很有可能出現包含了沒用的<code>.h</code>檔，或重複包含的現象，去掉這些冗餘的include是相當必要的。<br>當然，這主要是針對<code>.cpp</code>的，因為對於一個<code>.h</code>檔，其中的某個include是否冗餘很難界定，得看是否在最終的編譯單元中用到了，而這樣又可能出現在一個編譯單元用到了，而在另外一個編譯單元中沒用到的情況。</p>\n<h3 id=\"特別注意inline和template\"><a href=\"#特別注意inline和template\" class=\"headerlink\" title=\"特別注意inline和template\"></a>特別注意inline和template</h3><p>它們強制在<code>.h</code>檔中包含實作，這會增加<code>.h</code>檔的內容，從而減慢許多編譯速度，需權衡使用。</p>\n<h3 id=\"預編譯-h檔\"><a href=\"#預編譯-h檔\" class=\"headerlink\" title=\"預編譯.h檔\"></a>預編譯<code>.h</code>檔</h3><p>把一些常用但不常改動的<code>.h</code>檔放在預編譯<code>.h</code>檔中。這樣，至少在單個工程中你不需要在每個編譯單元裡一遍又一遍的load與解析同一個<code>.h</code>檔了。</p>\n<p>首次編譯source.cpp時，編譯器生成header.pch的預編譯header。以後再編譯該程式時，編譯器會比較該表頭檔的時間戳，如果表頭檔沒有改變，編譯器直接使用預編譯header。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\">CORE_PCH_FILENAME=Core.h</span><br><span class=\"line\">CORE_PCH=<span class=\"variable\">$(CORE_PCH_FILENAME)</span>.gch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$(CORE_PCH)</span>:</span><br><span class=\"line\">    <span class=\"variable\">$(CXX)</span> <span class=\"variable\">$(CXX_CFLAGS)</span> -x c++-header <span class=\"variable\">$(CORE_PCH_FILENAME)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Guard-Conditions\"><a href=\"#Guard-Conditions\" class=\"headerlink\" title=\"Guard Conditions\"></a>Guard Conditions</h3><p>保證每個 header file 在每個編譯單元只被 include 一次</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> filename_h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> filename_h</span></span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>同時使用兩種方法以確保compiler的相容性</p>\n<h2 id=\"Unity-Build\"><a href=\"#Unity-Build\" class=\"headerlink\" title=\"Unity Build\"></a>Unity Build</h2><p>把所有的檔案包含到一個cpp中(如<code>all.cpp</code>)，然後只編譯all.cpp。這樣就只有一個編譯單元，這意味著不需要重複load與解析同一個<code>.h</code>檔了，同時因為只產生一個obj文件，在link的時候也不需要那麼密集的IO</p>\n<h2 id=\"Compiler-Cache\"><a href=\"#Compiler-Cache\" class=\"headerlink\" title=\"Compiler Cache\"></a>Compiler Cache</h2><p>藉由快取上一次編譯的結果，使rebuild在保持結果相同的情況下，極大的提高速度。</p>\n<h2 id=\"不要有太多的Include-Directories\"><a href=\"#不要有太多的Include-Directories\" class=\"headerlink\" title=\"不要有太多的Include Directories\"></a>不要有太多的Include Directories</h2><p>編譯器定位你include的<code>.h</code>檔，是根據你提供的include directories進行搜索的。</p>\n<p>用 <code>cpp -v</code> 查看 <code>#include &quot;...&quot; search starts here:</code> 中的目錄<br>和 GNU Make 的 <code>-I</code> 選項</p>\n<h2 id=\"平行化及分佈式編譯\"><a href=\"#平行化及分佈式編譯\" class=\"headerlink\" title=\"平行化及分佈式編譯\"></a>平行化及分佈式編譯</h2><p>GNU Make 的 <code>-j [N]</code> 可以用N個核心編譯<br>Visual Studio 有 <code>/MP</code> 選項可做到檔案等級的平行<br>或是用空閒的機器來編譯</p>\n<h2 id=\"買更好的磁碟\"><a href=\"#買更好的磁碟\" class=\"headerlink\" title=\"買更好的磁碟\"></a>買更好的磁碟</h2><p>編譯速度慢很大一部分原因是磁碟操作，那麼除了儘可能的減少磁碟操作，我們還可以做的就是加快磁碟速度。</p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzczMTQyL3doYXQtdGVjaG5pcXVlcy1jYW4tYmUtdXNlZC10by1zcGVlZC11cC1jLWNvbXBpbGF0aW9uLXRpbWVz\">What techniques can be used to speed up C++ compilation times?<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9iYWl5YW5odWFuZy9hcmNoaXZlLzIwMTAvMDEvMTcvMTczMDcxNy5odG1s\">如何加快C++代碼的編譯速度<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1xWU42ZWR1VTA2cw==\">(Unity Build) CppCon 2014: Nicolas Fleury “C++ in Huge AAA Games”<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2dhbWVkZXYvY29tbWVudHMvMms0bDJ6L2lzX3ViaXNvZnRzX3VuaXR5X2J1aWxkX2Zvcl9jX3dvcnRoLw==\">(Unity Build) Is Ubisoft’s unity build for C++ worth?<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2dvb2RzcGVlZGxlZS5ibG9nc3BvdC50dy8yMDE2LzAxL2MtcGltcGwuaHRtbA==\">(pimpl) C++: 善用 PIMPL 技巧<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2JhaXlhbmh1YW5nL2JhY2t1cC9ibG9iLzlmMTFkMDE0OWNiMzY1OWRhYzQ3OTY3ZjFiMTBmM2I3ZWVjODg4ZDMvdG9vbHMvUGVybC9SZW1vdmVSZWR1bmRhbnRJbmNsdWRlcy5wbA==\">(去除重複) Perl腳本，用來自動去除這些冗餘的.h檔<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2R1Y2tyb29tLmJsb2dzcG90LnR3LzIwMTAvMDIvcHJlY29tcGlsZWQtaGVhZGVyLmh0bWw=\">(預編譯.h檔) 終於搞懂了，預編譯header 檔(precompiled header)<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9Yb3JlYXglMjBJbmNyZWRpQnVpbGQ=\">(分佈式編譯) Xoreax IncrediBuild<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODkyMDY0MC9ob3ctZG8taS1rbm93LXRoZS1kZWZhdWx0LWluY2x1ZGUtZGlyZWN0b3JpZXMtZGVmYXVsdC1saW5rLWRpcmVjdG9yaWVzLWFuZA==\">How do I know the default include directories<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jY2FjaGUuc2FtYmEub3JnLw==\">(Compiler Cache) ccache<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2l0c2NvbXBpbGluZy5ldS8yMDE3LzAxLzEyL3ByZWNvbXBpbGVkLWhlYWRlcnMtY3BwLWNvbXBpbGF0aW9uLw==\">(預編譯.h檔) Speed up C++ compilation, part 1: precompiled headers<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzczNjU3NzA=\">(預編譯.h檔) makefile 範例<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n",
            "tags": [
                "C++",
                "編譯",
                "gcc",
                "g++",
                "clang",
                "最佳化"
            ]
        }
    ]
}