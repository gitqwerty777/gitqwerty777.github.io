{
    "version": "https://jsonfeed.org/version/1",
    "title": "QWERTY • All posts by \"artificial intelligence\" tag",
    "description": "Programming | Computer Science | Thought",
    "home_page_url": "http://gitqwerty777.github.io",
    "items": [
        {
            "id": "http://gitqwerty777.github.io/artificial-intelligence/",
            "url": "http://gitqwerty777.github.io/artificial-intelligence/",
            "title": "人工智慧",
            "date_published": "2015-02-25T03:47:47.000Z",
            "content_html": "<!--Renew:-->\n\n<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><p>What is AI? → What is definition of Intelligence?  </p>\n<ul>\n<li><p>Artificial Intelligence(A.I.) or WALL.E</p>\n</li>\n<li><p>human-like or robot with intelligence</p>\n</li>\n<li><p>there are various defintion of AI</p>\n</li>\n<li><p>goal of AI : To create intelligent machines</p>\n<a id=\"more\"></a>\n</li>\n<li><p>Multiple Dimensions of Intelligence(多元智能)  </p>\n<ul>\n<li>Linguistic(語言), Logico-mathematical, Spatial, Musical, Kinesthetic(動作), Intrapersonal, Interpersonal</li>\n</ul>\n</li>\n<li><p>Intelligent Behavior  </p>\n<ul>\n<li>The ability to solve complex problems</li>\n<li>Learning from experience</li>\n<li>Adaptability(適應性)</li>\n<li>Self-awareness(自我意識)</li>\n<li>Dealing with incomplete information</li>\n<li>Action under time pressure</li>\n<li>Creativity</li>\n<li>Common sense reasoning etc. (really hard to teach computer)</li>\n</ul>\n</li>\n<li><p>Fundamental Elements of Intelligence  </p>\n<ul>\n<li><strong>Prediction</strong> – Imagining how things might turn out rather than having to try them explicitly</li>\n<li><strong>Response to change</strong> – Responding with intelligent action instead of inalterable instinct or conditional reflexes</li>\n<li><strong>Intentional action</strong> – Having a goal and selecting actions appropriate to achieving the goal</li>\n<li><strong>Reasoning</strong> – starting with some collection of facts and adding to it by any inference method</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Turing-Test\"><a href=\"#Turing-Test\" class=\"headerlink\" title=\"Turing Test\"></a>Turing Test</h3><ul>\n<li>“Can machines <strong>behave</strong> intelligently?”</li>\n<li>now it is <strong>not criteria of AI</strong>(You can use database or some way to “cheat”)</li>\n</ul>\n<p>Alan Turing (1912-1954)  </p>\n<ul>\n<li>1936: The Turing machine, computability, universal machine</li>\n<li>1950: The Turing Test for machine intelligence</li>\n</ul>\n<h3 id=\"Taxonomy-of-AI\"><a href=\"#Taxonomy-of-AI\" class=\"headerlink\" title=\"Taxonomy of AI\"></a>Taxonomy of AI</h3><p><img data-src=\"/img/AI/1-1.png\" alt=\"AI classess\"></p>\n<p>Acting rationally  </p>\n<ul>\n<li>do the right thing  <ul>\n<li>be expected to <strong>maximize goal achievement</strong>, given the <strong>available(limited) information</strong></li>\n</ul>\n</li>\n<li><strong>Doesn’t necessarily involve thinking</strong><ul>\n<li>blinking reflex</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"The-History-of-AI\"><a href=\"#The-History-of-AI\" class=\"headerlink\" title=\"The History of AI\"></a>The History of AI</h3><ul>\n<li>The gestation of AI (1943-1956)</li>\n<li>Dartmouth conference (Summer of 1956)<ul>\n<li>Participants: McCarthy, Minsky, Shannon, Rochester, More(Princeton), Newell, Simon (CMU), Solomonoff, Selfridge(MIT), Samuel (IBM)</li>\n<li>“AI” first be named</li>\n</ul>\n</li>\n<li>Early enthusiasm and expectations (1952-1969)</li>\n<li>A dose of reality (1966-1974)</li>\n<li>Shakey the Robot (1966-1972)<ul>\n<li>the first mobile robot to reason about its actions<ul>\n<li>can do perception, world-modeling, and acting</li>\n</ul>\n</li>\n<li>often shakes</li>\n</ul>\n</li>\n<li>Knowledge-based systems (1969-1979)</li>\n<li>AI (expert systems) becomes an industry (1980-1988)</li>\n<li>The return of neural networks (1986-1995)</li>\n<li>Broader technical development: probability, ALife, GA, soft computing (1988-)</li>\n<li>Machine learning and data mining (1990- )</li>\n<li>Intelligent agents (1995- )</li>\n<li>Bayesian probabilistic reasoning</li>\n</ul>\n<h3 id=\"Historical-Achievements\"><a href=\"#Historical-Achievements\" class=\"headerlink\" title=\"Historical Achievements\"></a>Historical Achievements</h3><ul>\n<li>Deep Blue defeated the reigning world chess champion Garry Kasparov in 1997</li>\n<li>Proved a mathematical conjecture (Robbins conjecture)unsolved for decades</li>\n<li>No hands across America (driving autonomously 98% of the time from Pittsburgh to San Diego)<ul>\n<li>Autonomous Land Vehicle In a Neural Network(ALVINN)<ul>\n<li>a perception system which learns to control the NAVLAB vehicles by watching a person drive.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>During the 1991 Gulf War, US forces deployed an AI logistics planning and scheduling program that involved up to 50,000 vehicles, cargo, and people</li>\n<li>NASA’s on-board autonomous planning program controlled the scheduling of operations for a spacecraft<ul>\n<li>Mars: Spirit, Opportunity</li>\n</ul>\n</li>\n<li>Proverb solves crossword puzzles better than most humans</li>\n<li>Stanley drove 132 miles to win the Grand Challenge<ul>\n<li>DARPA(美國國防遠景研究規劃局) give 1 million in 2004</li>\n<li>investment in competition is far better than in research of university</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Other-Usage-of-AI\"><a href=\"#Other-Usage-of-AI\" class=\"headerlink\" title=\"Other Usage of AI\"></a>Other Usage of AI</h3><ul>\n<li>on market<ul>\n<li>floor-cleaning</li>\n</ul>\n</li>\n<li>for fun<ul>\n<li>soccer</li>\n<li>pet</li>\n</ul>\n</li>\n<li>human-like<ul>\n<li>QRIO(sony)</li>\n<li>Asimo(Honda)</li>\n</ul>\n</li>\n<li>in art: “Aaron”<ul>\n<li>Inspired by the scribbling behavior of young children<ul>\n<li>construction of simple core-figures</li>\n<li>a simple strategy for tracing a path around them</li>\n</ul>\n</li>\n<li>Online auction for &gt; $2000 a piece</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Chap02-Agents\"><a href=\"#Chap02-Agents\" class=\"headerlink\" title=\"Chap02 Agents\"></a>Chap02 Agents</h2><p><img data-src=\"/img/AI/1-2.png\" alt=\"agent\">   </p>\n<ul>\n<li>take information from environment through sensors</li>\n<li>do reaction that would probably change the environment through actuators</li>\n<li>Human agent  <ul>\n<li>Sensors: eyes, ears, and other organs</li>\n<li>Actuators: hands, legs, mouth, and other body parts</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Agents-and-environments\"><a href=\"#Agents-and-environments\" class=\"headerlink\" title=\"Agents and environments\"></a>Agents and environments</h3><p>“do the right thing” is the one that will cause the agent to be most successful   </p>\n<ul>\n<li>Performance measure<ul>\n<li>An objective criterion for success of an agent’s behavior</li>\n<li>affects what agent behaves  </li>\n</ul>\n</li>\n<li>agent function<ul>\n<li>agent (function) = architecture + program</li>\n<li>in order to maximize the performance</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Rationality\"><a href=\"#Rationality\" class=\"headerlink\" title=\"Rationality\"></a>Rationality</h3><ul>\n<li>Rationality is distinct from omniscience (all knowing with infinite knowledge，全知)</li>\n<li>Rationality is distinct from clairvoyant(know every information)<ul>\n<li>Action outcomes may not be as expected</li>\n</ul>\n</li>\n<li>Rationality is exploration, learning, autonomy(自治)<ul>\n<li>perform actions to obtain useful information</li>\n<li>learn and adapt</li>\n<li><strong>actions are determined by its own experience</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Task-Environment-PEAS\"><a href=\"#Task-Environment-PEAS\" class=\"headerlink\" title=\"Task Environment: PEAS\"></a>Task Environment: PEAS</h3><ul>\n<li>High-Level Descriptions of AI Agents   <ul>\n<li>Including <strong>Performance measure, Environment, Actuators, Sensors</strong></li>\n</ul>\n</li>\n<li>specify the setting for intelligent agent design</li>\n</ul>\n<p>Ex. <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1GeTRRYU9sTmZjcw==\">CubeStormer3<i class=\"fa fa-external-link-alt\"></i></span>, which is a rubik cube solver:   </p>\n<ul>\n<li>Performance measure: Time(= number of steps that agent uses), correctness</li>\n<li>Environment: different patterns of rubik cube</li>\n<li>Actuators: various robotic arms, smart phone screen</li>\n<li>Sensors: camera</li>\n</ul>\n<h3 id=\"Environment-types\"><a href=\"#Environment-types\" class=\"headerlink\" title=\"Environment types\"></a>Environment types</h3><p>Fully observable (vs. partially observable): Sensors can access all environment at each point in time</p>\n<p>Deterministic (vs. stochastic): next environment is completely determined by the current state and agent’s action<br>If <strong>next environment is determined by actions of all agents</strong>, it’s called strategic(戰略的)</p>\n<p>Episodic (vs. sequential): choice of action in each episode depends only on the episode itself<br><strong>Sequential environments require memory</strong> of past actions to determine the next best action. Episodic environments are a series of one-shot actions    </p>\n<p>Static (vs. dynamic): The environment is unchanged while agent is thinking<br>The environment is semi-dynamic if the environment itself does not change with the passage of time but the agent’s performance score does<br>Ex. Taxi driver: Dynamic, Image analysis: Semi</p>\n<p>Discrete (vs. continuous): A limited number of distinct, clearly defined perception area<br>Ex. Driving: continuous, chess games: discrete</p>\n<p>Single agent (vs. multi-agent): An agent operating by itself in an environment</p>\n<p>The real world is <strong>partially observable, stochastic, sequential, dynamic, continuous, multi-agent</strong></p>\n<p><img data-src=\"/img/AI/2-1.png\" alt=\"chess and taxi environment\"></p>\n<h3 id=\"Agent-types\"><a href=\"#Agent-types\" class=\"headerlink\" title=\"Agent types\"></a>Agent types</h3><ul>\n<li>Table-Lookup Agent(reflex agent)<ul>\n<li>has many drawbacks</li>\n<li>huge table</li>\n<li>time-wasting to build the table</li>\n<li>no autonomy</li>\n</ul>\n</li>\n<li>Condition-Action Agent<ul>\n<li>four types(generality from low to high)</li>\n<li>Simple reflex agents <img data-src=\"/img/AI/2-2.png\" alt=\"\"><ul>\n<li>Always Infinite Loop</li>\n</ul>\n</li>\n<li>Model-based reflex agents <img data-src=\"/img/AI/2-3.png\" alt=\"\"><ul>\n<li>Know how world evolves</li>\n</ul>\n</li>\n<li>Goal-based agents <img data-src=\"/img/AI/2-4.png\" alt=\"\"><ul>\n<li>use knowledge about goal to achieve it</li>\n</ul>\n</li>\n<li>Utility-based agents <img data-src=\"/img/AI/2-5.png\" alt=\"\"><ul>\n<li>utility: value of happiness</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Learning agents <img data-src=\"/img/AI/2-6.png\" alt=\"\"><ul>\n<li>learning element modifies performance element base on feedback of critic<ul>\n<li>critic: how the agent is doing</li>\n<li>performance element select proper action</li>\n</ul>\n</li>\n<li>Problem generator<ul>\n<li>Tries to solve the problem differently instead of optimizing</li>\n</ul>\n</li>\n<li>Example<ul>\n<li>Knowledge Navigator (Apple, 1987)</li>\n<li>IBM Watson</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Chap03-Search\"><a href=\"#Chap03-Search\" class=\"headerlink\" title=\"Chap03 Search\"></a>Chap03 Search</h2><p>Search is a <strong>universal problem solving mechanism</strong> that     </p>\n<ul>\n<li><p>Systematically explores the alternatives</p>\n</li>\n<li><p>Finds the sequence of steps toward a solution</p>\n</li>\n<li><p><strong>Search in a problem space</strong> is claimed to be a <strong>completely general model of intelligence</strong></p>\n</li>\n<li><p>problem space: area that needs to be examined to solve a problem</p>\n<ul>\n<li>the number of the leaf nodes in search tree when there is solution</li>\n</ul>\n</li>\n<li><p>state space: the set of values which a process can take</p>\n<ul>\n<li>the number of the legal positions in a game</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Problem-solving-agents\"><a href=\"#Problem-solving-agents\" class=\"headerlink\" title=\"Problem-solving agents\"></a>Problem-solving agents</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* s is sequence of actions */</span></span><br><span class=\"line\">repeat &#123;</span><br><span class=\"line\">\tpercept = observeWorld();</span><br><span class=\"line\">\tstate = updateState(state, p);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> s is empty then &#123;</span><br><span class=\"line\">\t\tgoal = formulateGoal(state);</span><br><span class=\"line\">\t\tprob = formulateProblem(state, goal);</span><br><span class=\"line\">\t\ts = search(prob);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\taction = first(s);</span><br><span class=\"line\">\ts = remainder(s);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">until <span class=\"literal\">false</span>; <span class=\"comment\">/* i.e., forever */</span></span><br></pre></td></tr></table></figure>\n\n<p>Formulate goal → Formulate problem(state, action) → Find solution by search</p>\n<h3 id=\"Problem-types\"><a href=\"#Problem-types\" class=\"headerlink\" title=\"Problem types\"></a>Problem types</h3><ul>\n<li>single-state problem<ul>\n<li>Deterministic, fully observable</li>\n</ul>\n</li>\n<li>sensorless problem<ul>\n<li>Non-observable</li>\n</ul>\n</li>\n<li>contingency(可能性) problem<ul>\n<li>Nondeterministic and/or partially observable</li>\n<li>percepts provide new information about current state</li>\n</ul>\n</li>\n<li>exploration problem<ul>\n<li>Unknown state space</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Problem-formulation\"><a href=\"#Problem-formulation\" class=\"headerlink\" title=\"Problem formulation\"></a>Problem formulation</h3><p>A problem is defined by four items     </p>\n<ol>\n<li>initial state</li>\n<li>actions or successor function</li>\n<li>goal test function</li>\n<li>path cost (optional)</li>\n</ol>\n<p>A solution is a sequence of actions from initial state to  goal state</p>\n<h3 id=\"Problem-Domains\"><a href=\"#Problem-Domains\" class=\"headerlink\" title=\"Problem Domains\"></a>Problem Domains</h3><p>Real-world problems   </p>\n<ul>\n<li>Route-finding</li>\n<li>Touring: travelling<ul>\n<li>salesperson problem</li>\n</ul>\n</li>\n<li>VLSI layout</li>\n<li>Automatic assembly sequencing</li>\n<li>Scheduling &amp; planning</li>\n<li>Protein design</li>\n</ul>\n<h3 id=\"Implementation-States-vs-Nodes\"><a href=\"#Implementation-States-vs-Nodes\" class=\"headerlink\" title=\"Implementation: States vs. Nodes\"></a>Implementation: States vs. Nodes</h3><ul>\n<li>A state is physical configuration(座標，位置，盤面)</li>\n<li>A node is a data structure constituting part of a search tree<ul>\n<li>includes <strong>state</strong>, parent node, action, path cost g(x), depth</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Search-Property\"><a href=\"#Search-Property\" class=\"headerlink\" title=\"Search Property\"></a>Search Property</h3><p>Strategies are evaluated by  </p>\n<ul>\n<li>completeness: does it always find a solution if one exists?</li>\n<li>time complexity: number of nodes generated</li>\n<li>space complexity: maximum number of nodes in memory</li>\n<li>optimality: does it always find a least-cost solution?</li>\n</ul>\n<h3 id=\"Type-of-Search\"><a href=\"#Type-of-Search\" class=\"headerlink\" title=\"Type of Search\"></a>Type of Search</h3><p>可參考<a href=\"/computer-gaming/\">電腦對局理論</a>，兩者的complexity算法不同</p>\n<h4 id=\"Uninformed-search-blind-search\"><a href=\"#Uninformed-search-blind-search\" class=\"headerlink\" title=\"Uninformed search (blind search)\"></a>Uninformed search (blind search)</h4><p>use only the information available in the problem definition</p>\n<p><img data-src=\"/img/AI/3-2.png\" alt=\"\"></p>\n<ul>\n<li>Breadth-first search<ul>\n<li>Expand shallowest unexpanded node</li>\n<li><strong>fringe</strong> is a queue</li>\n</ul>\n</li>\n<li>Uniform-cost search<ul>\n<li>used when “cost != depth”</li>\n<li>Expand least cost(g(n), cost from start to this node) unexpanded node</li>\n<li>Time Complexity: # of nodes with g ≤ cost of optimal solution<ul>\n<li>$O(b^{ceiling(\\frac{C*}{ε})})$</li>\n<li>C* is the cost of the optimal solution</li>\n<li>ε is small constant</li>\n<li>How does it compare with $b^d$?</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Depth-first search<ul>\n<li>Expand deepest unexpanded node</li>\n<li><strong>frontier</strong> is a stack</li>\n<li><strong>not complete</strong> when there are loops or there are infinite nodes</li>\n</ul>\n</li>\n<li>Depth-limited search<ul>\n<li><strong>Preferred uninformed search method</strong></li>\n<li>Iterative deepening search<ul>\n<li>uses only linear space</li>\n<li>take a little more time</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Graph-Search\"><a href=\"#Graph-Search\" class=\"headerlink\" title=\"Graph Search\"></a>Graph Search</h4><p>Graph Search vs. Tree Search  </p>\n<ul>\n<li>Graph Search always need to record closed list to prevent loop</li>\n<li>Dijkstra’s Shortest Path Algorithm<ul>\n<li>find the shortest path between each pair of nodes</li>\n<li>Order nodes in priority queue to <strong>minimize actual distance from the start</strong></li>\n<li>Generalizes BFS that edges can have different lengths/weights</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Chap03b-Informed-Search\"><a href=\"#Chap03b-Informed-Search\" class=\"headerlink\" title=\"Chap03b Informed Search\"></a>Chap03b Informed Search</h2><p>Best-First Search  </p>\n<ul>\n<li>use evaluation function f(n) for each node</li>\n<li>Expand <strong>most desirable</strong>(lowest cost in total) unexpanded node</li>\n<li>Order nodes in priority queue to <strong>minimize estimated distance to the goal = h(n)</strong></li>\n<li>Special cases<ul>\n<li>greedy best-first search<ul>\n<li>expands the node that <strong>appears to be closest to goal</strong></li>\n</ul>\n</li>\n<li>A* search</li>\n</ul>\n</li>\n<li>Property<ul>\n<li>Complete? No – can get stuck in loops</li>\n<li>Time? O(bm), but a <strong>good heuristic can give a lot of improvement</strong></li>\n<li>Space? O(bm) – keeps all nodes in memory</li>\n<li>Optimal? No</li>\n<li>visits far fewer nodes, but may not provide optimal solution</li>\n</ul>\n</li>\n</ul>\n<p>A* Search  </p>\n<ul>\n<li><strong>avoid expanding paths that are already expensive</strong></li>\n<li>Evaluation function f(n) = g(n) + h(n)<ul>\n<li>f(n) = estimated total cost of path through n to goal</li>\n<li>g(n) = cost so far to reach n</li>\n<li>h(n) = estimated cost from n to goal</li>\n<li>expands nodes <strong>in order of increasing f value</strong></li>\n</ul>\n</li>\n<li><strong>Theorem: If h(n) is admissible, A* using TREESEARCH is optimal</strong><ul>\n<li>proof : <img data-src=\"/img/AI/3-3.png\" alt=\"PROOF1\"></li>\n<li><img data-src=\"/img/AI/3-4.png\" alt=\"PROOF2\"></li>\n</ul>\n</li>\n<li><strong>Theorem: The search space of A* grows exponentially unless the error in the heuristic function(real cost from n to goal - h(n)) grows no faster than the logarithm of the actual path cost</strong></li>\n<li>Property<ul>\n<li>Complete? Yes (unless there are infinitely many nodes with f ≤ f(G) )</li>\n<li>Time? Exponential</li>\n<li>Space? Keeps all nodes in memory</li>\n<li>Optimal? Yes</li>\n<li>Efficient? A* is <strong>optimally efficient</strong> for any heuristic function<ul>\n<li>no other optimal algorithm is guaranteed to expand fewer nodes than A*</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Iterative deepening A*(IDAstar)  </p>\n<ul>\n<li>Cutoff by f-cost<ul>\n<li>upper bound of f(n)</li>\n<li>If don’t find solution<ul>\n<li>Increase the bound to</li>\n<li>the minimum of the f-values that exceeded the previous bound</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>?? Not suitable for real-valued costs</li>\n<li>Advantage: Linear space</li>\n</ul>\n<p>Recursive best-first search(RBFS)  </p>\n<ul>\n<li><strong>only keep track of total cost of the best alternative path</strong></li>\n<li>if best node exceeds alternative f(n)<ul>\n<li>unwinds back to the alternative path</li>\n</ul>\n</li>\n<li>Back up value of dropped node to its parent<ul>\n<li>if all other paths are worse than it, we should use it again</li>\n</ul>\n</li>\n<li>Advantage: Linear space</li>\n</ul>\n<p>disadvantage of IDA* and RBFS  </p>\n<ul>\n<li>not good for graphs<ul>\n<li>can’t check for repeated states other than those on current path</li>\n</ul>\n</li>\n<li>use too little memory<ul>\n<li>can’t use full memory</li>\n</ul>\n</li>\n</ul>\n<p>Simplified Memory-bounded A*(SMA star)  </p>\n<ul>\n<li><strong>Expand</strong> the best <strong>leaf until memory is full</strong></li>\n<li>When memory full<ul>\n<li>Drop the worst(highest f-value) leaf node</li>\n</ul>\n</li>\n<li>Back up value of dropped node to its parent</li>\n<li>Property<ul>\n<li>use full of the memory usage</li>\n<li>complete when meory is enough to store the shallowest solution</li>\n<li>optimal when meory is enough to store the shallowest optimal solution</li>\n</ul>\n</li>\n</ul>\n<p>A heuristic is <strong>consistent</strong> if for every node n, f(n) is non-decreasing along all paths<br><strong>Theorem: If h(n) is consistent, A* using GRAPHSEARCH is optimal</strong><br>(every consistent function is admissible)</p>\n<h3 id=\"Inventing-Better-Heuristic-Functions\"><a href=\"#Inventing-Better-Heuristic-Functions\" class=\"headerlink\" title=\"Inventing Better Heuristic Functions\"></a>Inventing Better Heuristic Functions</h3><p>quality of heuristic: effective branching factor b*<br>If h2(n) ≥ h1(n) for all n (both admissible), then <strong>h2 dominates h1(far better than)</strong></p>\n<ul>\n<li>Relaxed problems<ul>\n<li>problem with fewer restrictions<ul>\n<li>admissible and consistent<ul>\n<li>exact cost of problem → consistent</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Original: move any tile to adjacent empty squares<ul>\n<li>Relaxed: Move from A to B, if A is adjacent to B → Manhattan distance</li>\n<li>Relaxed: Move from A to B, if B is empty → Gaschnig’s heuristic (1979)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Composite heuristics<ul>\n<li>h(n) = max (h1(n),…,hm(n))</li>\n</ul>\n</li>\n<li>Weighted evaluation function<ul>\n<li>fw(n) = (1-w)g(n) + w h(n)</li>\n</ul>\n</li>\n<li>Linear combination of features<ul>\n<li>h(n) = c1x1(n) + … + ckxk(n)</li>\n<li>no assure admissible or consistent</li>\n</ul>\n</li>\n<li>Statistical information</li>\n<li>Search cost<ul>\n<li>Good heuristic function should be computed efficiently</li>\n</ul>\n</li>\n<li>Sub-Problems<ul>\n<li>solution cost of a sub-problem of a given problem</li>\n</ul>\n</li>\n<li>Example<ul>\n<li>Linear Conflict Heuristic<ul>\n<li>Given two tiles in their goal row, but reversed in position, additional vertical moves can be added to Manhattan distance</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><a href=\"http://gitqwerty777.github.io/%E9%9B%BB%E8%85%A6%E5%B0%8D%E5%B1%80%E7%90%86%E8%AB%96/#disjoint-pattern\">Adding Pattern Database Heuristics</a>      </p>\n<ul>\n<li>pattern database<ul>\n<li>store exact solution costs of subproblems</li>\n</ul>\n</li>\n<li>How to make sure heuristic function can add with admissible? → do not affect each other <img data-src=\"/img/AI/3-add.png\" alt=\"7,8\"><ul>\n<li>disjoint pattern database</li>\n</ul>\n</li>\n<li>The 7-tile database contains 58 million entries<ul>\n<li>20 moves needed to solve red tiles</li>\n</ul>\n</li>\n<li>The 8-tile database contains 519 million entries<ul>\n<li>25 moves needed to solve blue tiles</li>\n</ul>\n</li>\n<li>Overall heuristic is 20+25=45 moves</li>\n<li>On 15 puzzle, IDA* with pattern database heuristics is about <strong>10 times faster than with Manhattan distance</strong>(Culberson and Schaeffer, 1996)</li>\n<li>can also be applied to Rubik’s Cube</li>\n</ul>\n<h3 id=\"Summary-all-informed-algorithms\"><a href=\"#Summary-all-informed-algorithms\" class=\"headerlink\" title=\"Summary: all informed algorithms\"></a>Summary: all informed algorithms</h3><p><img data-src=\"/img/AI/3-ex.png\" alt=\"\"></p>\n<h2 id=\"Chap04-Beyond-Classical-Search\"><a href=\"#Chap04-Beyond-Classical-Search\" class=\"headerlink\" title=\"Chap04 Beyond Classical Search\"></a>Chap04 Beyond Classical Search</h2><h3 id=\"Local-Search-Algorithms\"><a href=\"#Local-Search-Algorithms\" class=\"headerlink\" title=\"Local Search Algorithms\"></a>Local Search Algorithms</h3><p><strong>Used when the path to the goal does not matter</strong></p>\n<p>State space: the set of all <strong>states reachable from initial state</strong>  </p>\n<p>local search algorithms    </p>\n<ul>\n<li>iterative improvement<ul>\n<li>keep a single “current” state and try to improve it</li>\n</ul>\n</li>\n<li>advantage<ul>\n<li>use constant space</li>\n<li>useful to solve optimization problems(最佳化問題)</li>\n</ul>\n</li>\n</ul>\n<p>Example  </p>\n<ul>\n<li>Traveling Salesperson Problem  <ul>\n<li>use 1% additional cost than optimal solution</li>\n<li>solved very quickly with thousands of cities  </li>\n</ul>\n</li>\n<li>N-queen problem<ul>\n<li>can solve N = 1000000 quickly <img data-src=\"/img/AI/4-1.png\" alt=\"nqueen\"></li>\n</ul>\n</li>\n<li>Widely used in VLSI layout, airline scheduling, etc</li>\n</ul>\n<p>Three algorithms  </p>\n<ul>\n<li>hill climbing</li>\n<li>simulated annealing</li>\n<li>genetic algorithms</li>\n</ul>\n<h4 id=\"Hill-climbing-爬山\"><a href=\"#Hill-climbing-爬山\" class=\"headerlink\" title=\"Hill climbing(爬山)\"></a>Hill climbing(爬山)</h4><ul>\n<li>greedy local search<ul>\n<li>grab the best neighbor as successor</li>\n</ul>\n</li>\n<li>若所有鄰居的值都比現值小，則認為現值是最大值 <img data-src=\"/img/AI/4-hc.png\" alt=\"\"></li>\n<li>可能會走到Local maxima <img data-src=\"/img/AI/4-2.png\" alt=\"\">   </li>\n<li>走到平地的時候<ul>\n<li>限制走平地的步數</li>\n</ul>\n</li>\n</ul>\n<p>變形  </p>\n<ul>\n<li>Stochastic hill-climbing<ul>\n<li>choose uphill moves by 斜度 as probability</li>\n</ul>\n</li>\n<li>First-Choice hill-climbing<ul>\n<li>generating successor until it is better than parent</li>\n</ul>\n</li>\n<li>Random-restart hill-climbing<ul>\n<li>random generate initial state until goal is found</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Simulated-annealing\"><a href=\"#Simulated-annealing\" class=\"headerlink\" title=\"Simulated annealing\"></a>Simulated annealing</h4><ul>\n<li>escape local maxima<ul>\n<li><strong>allowing some “bad” moves</strong></li>\n<li>gradually decrease their frequency &amp; size <img data-src=\"/img/AI/4-sa.png\" alt=\"\"></li>\n<li>this probability reach Boltzman distribution<ul>\n<li>If T decreases slowly enough, then simulated annealing search will find a <strong>global optimum</strong> with probability approaching</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Local-Beam-Search\"><a href=\"#Local-Beam-Search\" class=\"headerlink\" title=\"Local Beam Search\"></a>Local Beam Search</h4><ul>\n<li>Keep track of <strong>(top) k states</strong> rather than just one</li>\n<li>useful information is passed among all parallel search threads</li>\n<li>Problem: all k states possibly end up on same local hill<ul>\n<li>Stochastic Local Beam Search<ul>\n<li><strong>choose k successors randomly, biased towards good ones(successor that has better score has more probability to be choosed)</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Genetic-algorithms\"><a href=\"#Genetic-algorithms\" class=\"headerlink\" title=\"Genetic algorithms\"></a><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5tZS5zanUuZWR1LnR3L2ppbXJvbmcvRnV6enlDb250cm9sL0IxLyVFNyVBQyVBQzklRTUlOTYlQUUlRTUlODUlODMlMjAlRTUlOUYlQkElRTUlOUIlQTAlRTYlQkMlOTQlRTclQUUlOTclRTYlQjMlOTUlRTclQjAlQTElRTQlQkIlOEIucGRm\">Genetic algorithms<i class=\"fa fa-external-link-alt\"></i></span></h4><ul>\n<li>Stochastic local beam search + generate successors from pairs</li>\n<li>Population<ul>\n<li>Start with k randomly individuals</li>\n</ul>\n</li>\n<li>Individual(state)<ul>\n<li><strong>represented as a string</strong> by finite symbols (often a string of 0s and 1s)</li>\n<li>substring must be meaningful</li>\n</ul>\n</li>\n<li>Fitness function: evaluation of the “goodness” of a given state<ul>\n<li>N-queen: number of non-attacking queens pairs (min = 0, max = 8 × 7 / 2 = 28)</li>\n</ul>\n</li>\n<li>Produce successors<ul>\n<li>selection, crossover(交配, combine two parents), and mutation(突變)</li>\n</ul>\n</li>\n<li>Schema<ul>\n<li>8-Queen: 2468xxxx → 24681357, 24681753 …</li>\n<li>if average fitness value of schema is better than mean, instances of schema will grow</li>\n</ul>\n</li>\n<li><img data-src=\"/img/AI/4-ga.png\" alt=\"\">   </li>\n</ul>\n<h3 id=\"Local-search-in-continuous-spaces\"><a href=\"#Local-search-in-continuous-spaces\" class=\"headerlink\" title=\"Local search in continuous spaces\"></a>Local search in continuous spaces</h3><ul>\n<li>Most of real-world environments are continuous</li>\n<li>Example: Airport Site Planning      <ul>\n<li>6-D state space (x1,y1),(x2,y2),(x3,y3)</li>\n<li>Objective function f(x1,y1,x2,y2,x3,y3) = sum of squared distances from each city to its nearest airport</li>\n</ul>\n</li>\n<li>Successor function would return infinitely many states    <ul>\n<li>Solution<ul>\n<li>Discretization(離散化)</li>\n<li>Gradient of the objective function <img data-src=\"/img/AI/4-gra.png\" alt=\"gradient\"><ul>\n<li>Empirical(經驗主義) gradient<ul>\n<li>take a little change in each coordinate to fit discretization</li>\n</ul>\n</li>\n<li>Line search<ul>\n<li>repeatly double the size of updating until the value descrease(下坡)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3poLndpa2lwZWRpYS5vcmcvd2lraS8lRTclODklOUIlRTklQTElQkYlRTYlQjMlOTU=\">Newton-Raphson method<i class=\"fa fa-external-link-alt\"></i></span><ul>\n<li>solve ∇f(x) = 0</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Searching-with-nondeterministic-actions\"><a href=\"#Searching-with-nondeterministic-actions\" class=\"headerlink\" title=\"Searching with nondeterministic actions\"></a>Searching with nondeterministic actions</h3><ul>\n<li>solution is not sequence, but a contingency plan(strategy)</li>\n<li>Unreliable Vacuum World<ul>\n<li>sometimes can not action will fail</li>\n</ul>\n</li>\n<li>Solutions(nested if-then-else statements)<ul>\n<li>AND-OR Search Tree <img data-src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/8/8a/Andortree.png/796px-Andortree.png\" alt=\"\"><ul>\n<li>P if ((Q&amp;R) | S)</li>\n<li>Q if (T | U)</li>\n<li>and → environment’s choice(fail or not)</li>\n<li>or → your own choice</li>\n</ul>\n</li>\n<li>returns a set of possible outcome states</li>\n</ul>\n</li>\n<li>Ex. Slippery Vacuum World<ul>\n<li>Movement actions sometimes fail</li>\n<li>use cyclic plans <img data-src=\"/img/AI/4-andor.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Searching-with-partial-observations\"><a href=\"#Searching-with-partial-observations\" class=\"headerlink\" title=\"Searching with partial observations\"></a>Searching with partial observations</h3><p>Slippery Vacuum World without global sensor   </p>\n<ul>\n<li>don’t know where it is</li>\n<li>use Belief-State Space (possible physical states) <img data-src=\"/img/AI/4-bss.png\" alt=\"\"></li>\n<li>$O(N)$ → $O(2^N)$</li>\n</ul>\n<p>Incremental Belief-State Search  </p>\n<ul>\n<li>find a solution that works for state 1</li>\n<li>check if it works for another state<ul>\n<li>If not, go back and find an alternative solution for state 1</li>\n</ul>\n</li>\n<li>similar to AND-OR search</li>\n</ul>\n<h3 id=\"Online-Search\"><a href=\"#Online-Search\" class=\"headerlink\" title=\"Online Search\"></a>Online Search</h3><ul>\n<li>combine computation and action</li>\n<li>Works good in<ul>\n<li>Dynamic or semi-dynamic domains</li>\n<li>Stochastic domains</li>\n<li>Exploration problem in unknown environments</li>\n</ul>\n</li>\n<li>impossible to take into account all possible contingencies(可能性，意外)</li>\n<li>The agent maintains a map of the environment    <ul>\n<li>Updated based on percept input</li>\n<li>use map to decide next action</li>\n<li>difference with e.g. A*<ul>\n<li>online search can only expand the node it is in local map</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Example: Maze   </p>\n<ul>\n<li>reach a goal with minimal cost</li>\n<li>Competitive ratio<ul>\n<li>compare the cost of the solution path if search space is known</li>\n</ul>\n</li>\n<li>Can be infinite<ul>\n<li>agent accidentally reaches dead ends</li>\n</ul>\n</li>\n<li>Assume Safely explorable<ul>\n<li>some goal state is reachable from every reachable state</li>\n</ul>\n</li>\n<li>No algorithm can avoid dead ends in all state spaces <img data-src=\"/img/AI/4-adversary.png\" alt=\"\"></li>\n</ul>\n<p>Online DFS <img data-src=\"/img/AI/4-online-dfs.png\" alt=\"\">  </p>\n<ul>\n<li>Untried: action not yet tried</li>\n<li>Unbacktracked: state not yet backtracked(尚未走回去過的state)  </li>\n<li>Worst case each node is visited twice<ul>\n<li>online iterative deepening approach solves this problem</li>\n</ul>\n</li>\n</ul>\n<p>Online Local Search  </p>\n<ul>\n<li>Hill-climbing is already online<ul>\n<li>only store one state</li>\n</ul>\n</li>\n<li>Bad performance due to local maxima<ul>\n<li>can not random restart in online version</li>\n</ul>\n</li>\n<li>Solution<ul>\n<li>Random walk introduces exploration<ul>\n<li>time complexity is exponential</li>\n</ul>\n</li>\n<li>Learning real-time A* (LRTA*) <img data-src=\"/img/AI/4-lrta-star.png\" alt=\"\"><ul>\n<li>Add memory to hill climbing</li>\n<li>Store current best estimate H(s) of cost to reach goal</li>\n<li>H(s) is initially = h(s), the least possible cost<ul>\n<li>updated with experience <img data-src=\"/img/AI/4-online-heu.png\" alt=\"\"></li>\n</ul>\n</li>\n<li>O(n^2)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Chap05-Adversarial-Search-game\"><a href=\"#Chap05-Adversarial-Search-game\" class=\"headerlink\" title=\"Chap05 Adversarial Search(game)\"></a>Chap05 Adversarial Search(game)</h2><ul>\n<li>In 1948, Turing met Donald Michie and competed with him in writing a simple chess-­playing algorithm</li>\n<li>The Historical Match in 1997<ul>\n<li>Kasparov vs. Deep Blue     </li>\n</ul>\n</li>\n<li><strong>Games are idealization of worlds</strong><ul>\n<li>the world state is fully accessible</li>\n<li>the (small number of) actions are well­‐defined</li>\n<li>uncertainty exists due to moves of the opponent</li>\n</ul>\n</li>\n<li>Minimax <img data-src=\"/img/AI/5-minimax.png\" alt=\"MiniMax\"></li>\n<li>MaxMax(negamax)<ul>\n<li>Advantage of over MiniMax   <ul>\n<li><strong>Consistent view</strong>: maximize scores</li>\n<li>Subroutine <strong>Min is not required</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Implementation of Pruning   </p>\n<ol>\n<li>Pass the current best score to child nodes</li>\n<li>Stop searching and return when a branch exceeds the score from the parent</li>\n</ol>\n<p>Alpha-Beta search <img data-src=\"/img/AI/5-ab.png\" alt=\"\">  </p>\n<ul>\n<li>only use about $O(b^(d/2))$ time</li>\n</ul>\n<p>Improvement of A-B search</p>\n<ul>\n<li>Search good move first<ul>\n<li>Heuristic move ordering<ul>\n<li>Checkmate</li>\n<li>Killer<ul>\n<li><strong>The move that results in beta pruning earlier</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Iterative deepening<ul>\n<li>good moves in the search depth = N are usually good in depth = N+1</li>\n</ul>\n</li>\n<li>Principle variation search<ul>\n<li>NegaScout</li>\n</ul>\n</li>\n<li>Zero‐window search<ul>\n<li>expect returned value = -3 with beta pruning</li>\n<li>if return -4, real value is between [4, ∞], search again</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Reuse scores for duplicate nodes<ul>\n<li>Transposition table<ul>\n<li>save board layout and score in hash table</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Risky estimation of best score<ul>\n<li>Null-move search<ul>\n<li>give up a move once</li>\n<li>returned score serves as an estimate value for pruning</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Extend the depth for some leaf nodes<ul>\n<li>Score may not be acccurate if the board situation is not quiescent(靜止，即交換棋子的過程告一段落)   <ul>\n<li>A series of recapture moves</li>\n<li>Checkmates</li>\n</ul>\n</li>\n<li>Horizon Effect<ul>\n<li>threat will be happened in the <strong>deep</strong> depth</li>\n</ul>\n</li>\n<li>Singular Extension<ul>\n<li>give more depth to some nodes</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>prune without further consideration<ul>\n<li>Forward Pruning</li>\n<li>Probabilistic Cut<ul>\n<li>pruning nodes which are merely possible to be good move</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>End Game<ul>\n<li>retrograde(倒推)<ul>\n<li>reverse the rules to chess to do unmoves</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Stochastic game  </p>\n<ul>\n<li>Chance Layer added to search tree<ul>\n<li>possible states after stochastic action</li>\n</ul>\n</li>\n<li>expect value<ul>\n<li>sum all values in chance layer with probability</li>\n<li>$(4 \\times 0.5 + 6 \\times 0.5) \\div 2 = 5$</li>\n</ul>\n</li>\n</ul>\n<p>Bridge  </p>\n<ul>\n<li>inperfect information<ul>\n<li>belief state</li>\n</ul>\n</li>\n<li>GIB program<ul>\n<li>monte-carlo(handle randomness well)</li>\n<li>explaination-based generalization<ul>\n<li>only consider high-card or low-card</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>evaluation function has error  </p>\n<ul>\n<li>error is not independent(probably all children)</li>\n<li>consider mean and variance</li>\n</ul>\n<p>Time-limited search  </p>\n<ul>\n<li>if utility of node expansion is not higher than their cost(time), do not expand</li>\n</ul>\n<h2 id=\"Chap06-Constraint-Satisfaction-Problems-CSP\"><a href=\"#Chap06-Constraint-Satisfaction-Problems-CSP\" class=\"headerlink\" title=\"Chap06 Constraint Satisfaction Problems(CSP)\"></a>Chap06 Constraint Satisfaction Problems(CSP)</h2><ul>\n<li><p>specialization of general search</p>\n</li>\n<li><p>state is defined by <strong>variables</strong> with values from <strong>domain</strong></p>\n</li>\n<li><p>Example: Map-Coloring</p>\n<ul>\n<li>Variables = set of regions</li>\n<li>Domains = {red,green,blue}</li>\n<li>Constraints: adjacent regions must have different colors</li>\n</ul>\n</li>\n<li><p>Solutions are <strong>complete and consistent</strong> assignments</p>\n<ul>\n<li>consistent: assignment that does not violate any constraint</li>\n</ul>\n</li>\n<li><p>Binary CSP: each constraint relates only two variables</p>\n<ul>\n<li>Constraint graph: vertexs are variables, edges are constraints</li>\n</ul>\n</li>\n</ul>\n<p>CSP types    </p>\n<ul>\n<li>Discrete variables<ul>\n<li>finite domains<ul>\n<li>n variables, domain size d → $O(d^n)$ complete assignments</li>\n<li>Ex. Boolean CSPs(NP-complete)</li>\n</ul>\n</li>\n<li>infinite domains(integers, strings, …)<ul>\n<li>use constraint language, e.g., x1 + 5 ≤ x3</li>\n<li>Ex. job scheduling, variables are start/end days for each job</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Continuous variables<ul>\n<li>linear constraints solvable in polynomial time by <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUJBJUJGJUU2JTgwJUE3JUU4JUE3JTg0JUU1JTg4JTky\">linear programming<i class=\"fa fa-external-link-alt\"></i></span><ul>\n<li>Ex. quadratic programming</li>\n</ul>\n</li>\n<li>Ex. start/end times for observations</li>\n</ul>\n</li>\n<li>No algorithm exist for solving general nonliear constraints</li>\n</ul>\n<p>constraint types  </p>\n<ul>\n<li>Unary constraints involve a single variable<ul>\n<li>SA ≠ red</li>\n</ul>\n</li>\n<li>Binary constraints involve pairs of variables,<ul>\n<li>SA ≠ WA</li>\n</ul>\n</li>\n<li>3 or more variables<ul>\n<li>cryptarithmetic(覆面算，用英文字母來取代0至9的數字) column constraints</li>\n</ul>\n</li>\n<li>Preferences (soft constraints)<ul>\n<li>green is better than red</li>\n</ul>\n</li>\n</ul>\n<p>Real-World CSPs  </p>\n<ul>\n<li>Assignment problems<ul>\n<li>who teaches what class</li>\n</ul>\n</li>\n<li>Timetabling problems<ul>\n<li>which class is offered when and where</li>\n</ul>\n</li>\n<li>Transportation scheduling</li>\n</ul>\n<p>Standard Search Formulation (Incrementally)</p>\n<ol>\n<li>Every solution will be found in depth n → prefer to use depth-first search</li>\n<li>Path is irrelevant, so can also use complete-state formulation of local search</li>\n<li>b = (n-l)d at depth = l, hence $n! \\times dn$ leaves</li>\n</ol>\n<h3 id=\"Backtracking-Search\"><a href=\"#Backtracking-Search\" class=\"headerlink\" title=\"Backtracking Search\"></a>Backtracking Search</h3><ul>\n<li><strong>depth-first search</strong> for CSPs with <strong>assigning one variable per action</strong></li>\n<li>basic uninformed algorithm for CSP</li>\n<li>by wiki: 回溯法採用試錯的思想，它嘗試分步的去解決一個問題。在分步解決問題的過程中，當它通過嘗試發現現有的分步答案不能得到有效的正確的解答的時候，它將取消上一步甚至是上幾步的計算，再通過其它的可能的分步解答再次嘗試尋找問題的答案 <img data-src=\"/img/AI/4-bt.png\" alt=\"\"></li>\n<li>Can solve n-queens for n ≈ 25</li>\n</ul>\n<p>Improve Backtracking  </p>\n<ul>\n<li>General-purpose methods can give huge gains in speed<ul>\n<li>variable assignment order<ul>\n<li>Most constrained variable(minimum remaining values (MRV) heuristic)<ul>\n<li>choose the variable with the <strong>fewest legal values</strong></li>\n</ul>\n</li>\n<li>Most constraining variable(degree heuristic)<ul>\n<li>choose the variable with <strong>the most constraints</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>value assignment order<ul>\n<li>Least Constraining Value<ul>\n<li>choose the value that <strong>make the fewest values be deleted in the remaining variables</strong></li>\n<li>give the most flexibility</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>detect inevitable failure early  <ul>\n<li>Forward Checking  <ul>\n<li>Keep track of <strong>legal values for unassigned variables</strong></li>\n<li>Terminate search when any variable has no legal value</li>\n<li>Only consider arc-consistency<ul>\n<li>the graph already has arc-consistency need not do this</li>\n</ul>\n</li>\n<li>Maintain Arc consistency (MAC)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Combining these heuristics can solve n-queens for n ≈ 1000</li>\n</ul>\n<p>Intelligent Backtracking  </p>\n<ul>\n<li>Chronological Backtracking<ul>\n<li>when the search fails, back up to the preceding <strong>decision point(多選題)</strong><ul>\n<li>the most recent decision point is revisited</li>\n</ul>\n</li>\n<li>equals to DFS</li>\n</ul>\n</li>\n<li>Backjumping<ul>\n<li>backtracks to the most recent variable in the <strong>conflict set(variables that caused the failure)</strong></li>\n</ul>\n</li>\n</ul>\n<p>Constraint Propagation(傳播限制)</p>\n<ul>\n<li>early detection for all failures</li>\n<li>local consistency(graph)<ul>\n<li>variable: node, binary constraint: arc</li>\n</ul>\n</li>\n<li>transform all n-ary constraints to binary one</li>\n<li>Node consistency(1-consistency)<ul>\n<li>all values in domain satisfy unary constraints</li>\n</ul>\n</li>\n<li>Arc consistency(2-consistency)<ul>\n<li>all values in domain satisfy binary constraints</li>\n<li>Algorithm: AC3</li>\n</ul>\n</li>\n<li>Path consistency<ul>\n<li>若xi, xj的domain，可以使第三個variable xk的domain滿足{xi, xk}和{xj, xk}的consistency</li>\n</ul>\n</li>\n<li>If variable X loses a value, <strong>neighbors of X</strong> need to be rechecked (detect inconsistency)<ul>\n<li>Ex. Arc Consistency</li>\n<li>REMOVE-INCONSISTENT-VALUE: 如果Xi的Domain中，有無法達成 Xi↔Xj 這個條件的值，則刪除　<img data-src=\"/img/AI/6-arc.png\" alt=\"arc algo\"></li>\n</ul>\n</li>\n</ul>\n<p>k-Consistency  </p>\n<ul>\n<li>for any set of k-1 variables and for any consistent assignment to those variables, a consistent value can always be assigned to the k-th variable</li>\n<li>只要有任何k-1個確定值的變數，必有一確定值可以放在第k個變數</li>\n<li>A graph is <strong>strongly k-consistent</strong> if it is k-consistent and is also (k-1)-consistent, (k-2)-consistent, … 1-consistent<ul>\n<li>guarantee to find solution in O(n^2d)</li>\n<li>but establishing strongly k-consistent graph take exponential time</li>\n</ul>\n</li>\n<li>commonly use 2 or 3 consistency in pratice</li>\n</ul>\n<p>Subproblem  </p>\n<ul>\n<li>suppose each subproblem has c variables, total n variables</li>\n<li>worst-case cost: $\\frac{n}{c}\\times d^{c}$</li>\n<li>cost is far better<ul>\n<li>n = 80, d = 2, c =20 → $2^80$ → $4 \\times 2^{20}$</li>\n</ul>\n</li>\n</ul>\n<p>Local Search for CSPs   </p>\n<ul>\n<li>allow unsatisfied states</li>\n<li>value selection by min-conflicts heuristic<ul>\n<li>h(n) = total number of violated constraints</li>\n</ul>\n</li>\n<li>Evaluation function of N-queen  <ul>\n<li>h = number of pairs of queens that are attacking each other</li>\n<li>can solve n-queens for n ≈ 10000000 (O(n) = constant) with high probability</li>\n</ul>\n</li>\n<li>variant<ul>\n<li>allow variable move to the same score</li>\n<li>prevent to select recently choosed variables</li>\n</ul>\n</li>\n<li>Critial Ratio of local search for CSP   <ul>\n<li>In certain ratio, it’s hard to solve CSP by local search <img data-src=\"/img/AI/6-ratio.png\" alt=\"\"></li>\n<li>剛剛好的限制條件(答案數過少)→數獨題目</li>\n</ul>\n</li>\n<li>Advantage<ul>\n<li>can easily change into online setting</li>\n</ul>\n</li>\n</ul>\n<!-- Waltz Labeling Algorithm    \n- used for Edge Labeling ![](/img/AI/6-waltz.png)\n- 4 ways to label a line, 16 labelings for two line intersects like 「L」 , 64 labelings for two line intersects like 「fork, arrow, or T」\n- there are some rules to make the labels possible\n\nEdge Labeling as CSP  \n- variable: vertexs\n- domain: label set of the corresponding junction\n- constraint: rules of label relationship\n\nWaltz’s Algorithm  \n1. Label each vertex with all possible labelings\n2. Pick a vertex V, for each neighboring vertex, N:  \n    1. If N and V agree on the label for the line between them, do nothing ; Otherwise, remove the inconsistent labelings\n    2. Propagate the constraint by repeating the process for all neighboring vertices\n3. Termination condition:\n    1. Every vertex has been visited at least once\n    2. There are no more constraints to propagate\n-->\n\n<p>Theorem of Tree-Structed CSP      </p>\n<ul>\n<li>if the constraint graph has no loops, CSP can be solve in $O(nd^2)$ time, which is far better than general CSP($O(d^n)$)<ol>\n<li>make problem arc-consistent O(n)</li>\n<li>assign value O(d^2)</li>\n</ol>\n</li>\n<li>Algorithm<ol>\n<li>transform problem to a tree</li>\n<li>for i = n to 2, do REMOVE-INCONSISTENT-VALUE(Parent(Xi), Xi)</li>\n<li>for i = 1 to n, assign Xi consistently</li>\n</ol>\n</li>\n</ul>\n<p>Graph reduced to tree  </p>\n<ul>\n<li>constraint graph<ul>\n<li>given fixed value for some of the nodes to make remaining a tree</li>\n<li>if small cut is found, it is efficient</li>\n</ul>\n</li>\n<li>tree decomposition<ul>\n<li>把一部分的圖形變成一個大的node，把這些大的node合成一顆樹</li>\n<li>規則<ol start=\"3\">\n<li>若兩個variables本來有相連，他們必須出現在同一個subgraph至少一次</li>\n<li>若一個variable出現多次，則那些subgraph要彼此相連</li>\n<li>每個variable至少要出現一次</li>\n</ol>\n</li>\n<li>make subgraph as small as possible<ul>\n<li>tree width: size of the largest subproblem</li>\n</ul>\n</li>\n<li>$O(nd^{w+1})$, w = tree width</li>\n</ul>\n</li>\n</ul>\n<p>Breaking symmetry  </p>\n<ul>\n<li>reduce search space by n! by breaking symmetry<ul>\n<li>A: red, B: blue ↔ A:blue, B:red</li>\n<li>set A &lt; B<ul>\n<li>only one solution A:blue, B:red \\</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Summary  </p>\n<ul>\n<li>CSPs are a special kind of problem<ul>\n<li>states defined by values of a fixed set of variables</li>\n<li>goal test defined by constraints on variable values</li>\n</ul>\n</li>\n<li>Variable ordering and value selection heuristics help significantly</li>\n<li><strong>Iterative min-conflicts</strong> is usually <strong>effective in practice</strong></li>\n</ul>\n<h2 id=\"Chap07-Logical-Agents\"><a href=\"#Chap07-Logical-Agents\" class=\"headerlink\" title=\"Chap07 Logical Agents\"></a>Chap07 Logical Agents</h2><p>Can agent prove theorems?</p>\n<p>David Hilbert (1862-1943)   </p>\n<ul>\n<li>“Hilbert’s Program” [1920]<ul>\n<li><strong>mechanize mathematics</strong></li>\n<li><strong>The consistency of more complicated systems, such as real analysis, could be proven by simpler systems</strong></li>\n<li>consistency of all of mathematics could be reduced to basic arithmetic</li>\n<li>所有數學應用一種統一的嚴格形式化的語言，並且按照一套嚴格的規則來使用</li>\n</ul>\n</li>\n<li>Gödel showed that this is <strong>impossible</strong></li>\n<li>Automatic theorem proving simply tries to mechanize what can be mechanized</li>\n</ul>\n<h3 id=\"Godel’s-Incompleteness-Theorem-Kurt-Godel-1931\"><a href=\"#Godel’s-Incompleteness-Theorem-Kurt-Godel-1931\" class=\"headerlink\" title=\"Gödel’s Incompleteness Theorem (Kurt Gödel, 1931)\"></a>Gödel’s Incompleteness Theorem (Kurt Gödel, 1931)</h3><ol>\n<li>In any consistent formalization of mathematics that is sufficiently strong to define the concept of <strong>natural numbers</strong>, one can construct a statement that can be <strong>neither proved nor disproved</strong> within that system(任何相容的形式系統，只要蘊涵皮亞諾算術公理，就可以在其中構造在體系中不能被證明的真命題，因此通過推演不能得到所有真命題（即體系是不完備的）。)</li>\n<li>No consistent system can be used to prove its own consistency (can not simultaneously be true and false) 任何相容的形式系統，只要蘊涵皮亞諾算術公理，它就不能用於證明它本身的相容性</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2VwaXN0ZS5tYXRoLm50dS5lZHUudHcvYXJ0aWNsZXMvbW0vbW1fMTVfNF8xMS9pbmRleC5odG1s\">《戈德爾不完備定理》，董世平<i class=\"fa fa-external-link-alt\"></i></span><br>任一個證明，都必須從某一個公設系統出發。對於自然數我們最常用的公設系統就是皮亞諾公設 (Peano Axioms)， 這些公設中最複雜而且困難的，（不僅對一般的高中，大學生如此，對邏輯學家亦如此），就是大名鼎鼎的「數學歸納法」。藉著數學歸納法及其他的公設， 我們可證明「質數有無窮多個」，問題是「是否所有有關自然數的敘述，只要是對的，就可由皮亞諾公設出發，而得到證明呢？」也就是「皮亞諾公設是否完備?」 若皮亞諾公設具有完備性，那麼所有有關自然數的敘述，若是對的， 就可由皮亞諾公設證明。<br>由戈德爾不完備定理而得的一個結論，就是「皮亞諾公設是不完備的！」有些關於自然數的敘述是對的，但皮亞諾公設無法證明它，戈德爾的證明也的確告訴我們如何找到這個敘述。事實上，由戈德爾的證明，我們可得一個算則，給我們一個公設系統，我們就可按此算則，而得到一個算術句型，再經過適當的編譯 (compile)，即可成為此系統內的一個句型，而此句型在此系統內為真，卻無法在此系統內被證明，所以也許我們會覺得皮亞諾公設不具有完備性，這是它的缺點，我們應當找另一個具有完備性的公設系統來代替它，但不完備定理告訴我們，「任何一個具有一致性的公設化系統皆是不完備的！」這也就是為什麼雖然大家明知皮亞諾公設是不完備的，但這個公設系統仍是被普遍的使用，因為任何其他系統，也都是不完備的。也許我們再退一步，皮亞諾公設固然不具有完備性，我們至少可要求它具有一致性吧！也就是皮亞諾公設所證明的，一定是真的，可惜，這一點也做不到，由不完備定理可得另一個結論就是「在皮亞諾公設系統內將無法證明它的一致性！」從某一方面來說，你須要假設比「皮亞諾公設是一致的」更強或相等的假設，你才能證明皮亞諾公設的一致性，當然我們若須要更強的假設，也就須要更大的信心去相信它是對的。同樣的，皮亞諾公設也沒那麼特殊，就像不完備性的結果一樣，由戈德爾不完備定理，任一個足夠強的公設系統，皆無法證明它本身的一致性。</p>\n<ul>\n<li>第一不完備定理<ul>\n<li>任何一個足夠強的一致公設系統，必定是不完備的</li>\n<li>即除非這個系統很簡單，(所以能敘述的不多)，或是包含矛盾的， 否則必有一真的敘述不能被證明</li>\n</ul>\n</li>\n<li>第二不完備定理<ul>\n<li>任何一個足夠強的一致公設系統，必無法證明本身的一致性</li>\n<li>所以除非這個系統很簡單，否則你若在此系統性，證明了本身的一致性，反而已顯出它是不一致的</li>\n</ul>\n</li>\n</ul>\n<p>哥德爾證明：任何無矛盾的公理體系，只要包含初等算術的陳述，則必定存在一個不可判定命題，用這組公理不能判定其真假。也就是說，「無矛盾」和「完備」是不能同時滿足的！這便是聞名於世的哥德爾不完全性定理。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3Byb2dyYW1tZXJtYWdhemluZS5naXRodWIuaW8vMjAxNDAzL2h0bS9mb2N1czQuaHRtbCPlvp7nqIvlvI/kurrnmoTop5LluqborYnmmI7lk6XlvrfniL7kuI3lrozlgpnlrprnkIY=\">從程式人的角度證明「哥德爾不完備定理」<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h3 id=\"knowledge-based-agents\"><a href=\"#knowledge-based-agents\" class=\"headerlink\" title=\"knowledge-based agents\"></a>knowledge-based agents</h3><p>use logical sentences(邏緝式) to infer conclusions about the world</p>\n<p>KnowledgeBase Agent  </p>\n<ul>\n<li>processes of reasoning that operate on representation of knowledge</li>\n<li>knowledge base<ul>\n<li>set of sentences (axioms)<ul>\n<li>given without derived from other sentences</li>\n</ul>\n</li>\n<li>tell agent how to operate in this environment</li>\n</ul>\n</li>\n<li>inference<ul>\n<li>derive new sentences from old</li>\n</ul>\n</li>\n</ul>\n<!-- Declarative Description of Knowledge-Based Agent    \n- Knowledge level\n    - Specify what the agent knows\n        - The golden gate bridge connects San Francisco with Marin County\n- Logical level\n    - Specify **sentences encoding** that the agent knows\n        - Links(GGBridge, SF, Marin)\n- Implementation level\n    - Specify **physical representation** of the sentences at the logical level\n        - ''Links(GGBridge, SF, Marin)''\n-->\n\n<h3 id=\"Terminology\"><a href=\"#Terminology\" class=\"headerlink\" title=\"Terminology\"></a>Terminology</h3><ul>\n<li>α ╞ β: α entails β<ul>\n<li>if there is a model that α is true, β is also true</li>\n<li>α is a stronger assertion than β</li>\n<li>x = 0 ╞ xy = 0   </li>\n</ul>\n</li>\n<li>An interpretation is a model for a theory if it assigns true to each formula in the set</li>\n<li>A formula is satisfiable if it is true in at least one model<ul>\n<li>m satisfies α → m is a model of α</li>\n</ul>\n</li>\n<li>A formula is valid if<ul>\n<li>it is true under all possible interpretations</li>\n<li>Its negation is not satisfiable</li>\n</ul>\n</li>\n</ul>\n<p>Validity and Satisfiability    </p>\n<ul>\n<li><img data-src=\"/img/AI/7-validansatis.png\" alt=\"\"></li>\n<li>演繹定理聲稱如果公式 F 演繹自 E，則蘊涵 E → F 是可證明的(就是或它可以自空集推導出來)。用符號表示，如果  $E \\vdash F$ ，則  $\\vdash E \\rightarrow F $<ul>\n<li>KB ╞ α if and only if (KB → α) is valid</li>\n</ul>\n</li>\n<li>Relation to Inference<ul>\n<li>KB ╞ α if and only if (KB → ~α) is unsatisfiable</li>\n</ul>\n</li>\n</ul>\n<p>Inference Rules    </p>\n<ul>\n<li>modus ponenes(推論法則) <img data-src=\"/img/AI/7-modusponens.png\" alt=\"\"></li>\n<li>and-elimination <img data-src=\"/img/AI/7-andemi.png\" alt=\"\"></li>\n<li>Propositional Rule of Inference <img data-src=\"/img/AI/7-propositionalInference.png\" alt=\"\"></li>\n</ul>\n<h3 id=\"Propositional-Logic\"><a href=\"#Propositional-Logic\" class=\"headerlink\" title=\"Propositional Logic\"></a>Propositional Logic</h3><p>Syntax and Semantics  </p>\n<ul>\n<li>symbol<ul>\n<li>assigned by true or false</li>\n<li>literal: symbol or ~symbol</li>\n<li>constants: True(always true), False(always false)</li>\n</ul>\n</li>\n<li>connectives<ul>\n<li>or(disjunction), and(conjunction)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Proof-Methods\"><a href=\"#Proof-Methods\" class=\"headerlink\" title=\"Proof Methods\"></a>Proof Methods</h3><ul>\n<li>Application of inference rules<ul>\n<li>generation proof sentence by inference</li>\n<li>Proof = a sequence of inference rule applications<ul>\n<li>Can use inference rules as operators in a standard search algorithm</li>\n</ul>\n</li>\n<li>Typically require transformation</li>\n</ul>\n</li>\n<li>Model checking<ul>\n<li>truth table enumeration<ul>\n<li>exponential time</li>\n</ul>\n</li>\n<li>improved backtracking<ul>\n<li>e.g., Davis-Putnam-Logemann-Loveland (DPLL)</li>\n</ul>\n</li>\n<li>heuristic search in model space (sound but incomplete)<ul>\n<li>e.g., min-conflicts-like hill-climbing algorithms</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Conjunctive Normal Form  </p>\n<ul>\n<li>any propositional formula can be transform to conjunctive normal form</li>\n<li>(or or …) and (or or …) and (or or …) …</li>\n<li>each () is a clause</li>\n<li>Convert normal formula to CNF<ul>\n<li><img data-src=\"/img/AI/7-cnf-convert.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<p>Example: <span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvSHVudF90aGVfV3VtcHVz\">Wumpus<i class=\"fa fa-external-link-alt\"></i></span>  </p>\n<ul>\n<li>Using Resolution(歸結) inference rule<ul>\n<li>$\\frac{\\Gamma_1 \\cup\\left{ \\ell\\right} ,,,, \\Gamma_2 \\cup\\left{ \\overline{\\ell}\\right} }{\\Gamma_1 \\cup\\Gamma_2}|\\ell|$</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Testing-Validity\"><a href=\"#Testing-Validity\" class=\"headerlink\" title=\"Testing Validity\"></a>Testing Validity</h3><ul>\n<li>truth tables<ul>\n<li>exponential time</li>\n</ul>\n</li>\n<li>Resolution</li>\n<li>Forward &amp; backward chaining</li>\n<li>DPLL</li>\n<li>Local Search Methods<ul>\n<li>Complete backtracking search algorithms<ul>\n<li>DPLL algorithm (Davis, Putnam, Logemann, Loveland)</li>\n</ul>\n</li>\n<li>Incomplete local search algorithms<ul>\n<li>WalkSAT algorithm</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Resolution\"><a href=\"#Resolution\" class=\"headerlink\" title=\"Resolution\"></a>Resolution</h3><ul>\n<li>Sound<ul>\n<li>inference that derives only entailed sentences</li>\n<li>if KB is true, then any sentence α derived from KB by sound inference is also true</li>\n</ul>\n</li>\n<li>Completeness<ul>\n<li>if it can derive any sentence that is entailed</li>\n</ul>\n</li>\n</ul>\n<p>Resolution refutation is sound(可靠) and refutation complete(完備) for propositional logic  </p>\n<ul>\n<li><p>If we derive a contradiction, then the conclusion follows from the axioms</p>\n</li>\n<li><p>If we can’t apply any more, then the conclusion cannot be proved from the axioms</p>\n</li>\n<li><p>A formal system S is refutation-complete if it is able to derive false from every unsatisfiable set of formulas</p>\n</li>\n<li><p>KB ╞ α if and only if (KB → ~α) is unsatisfiable</p>\n<ul>\n<li>proof KB ╞ α by showing (KB ^ ~α) is unsatisfiable</li>\n</ul>\n</li>\n</ul>\n<p>Binary Resolution Step<br>For any two clauses C1 and C2  </p>\n<ul>\n<li>Find a literal L1 in C1 that is complementary to a literal L2 in C2</li>\n<li>Delete L1 and L2 from C1 and C2 respectively</li>\n<li>Construct the disjunction of the remaining clauses</li>\n<li>The constructed clause is a resolvent of C1 and C</li>\n<li>Ex. $\\frac{a \\vee b, \\quad \\neg a \\vee c}{b \\vee c}$</li>\n<li>put P1,2 into clause set to check whether “~P1,2 is in KB” <img data-src=\"/img/AI/7-resolution.png\" alt=\"\"><ul>\n<li>Proof by contradiction：The derivation of [] indicates that the database of clauses is inconsistent<ul>\n<li>P1,2 <strong>is</strong> in KB</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Resolution algorithm <img data-src=\"/img/AI/7-resolution-algo.png\" alt=\"\"></p>\n<h3 id=\"Propositional-Horn-Clauses\"><a href=\"#Propositional-Horn-Clauses\" class=\"headerlink\" title=\"Propositional Horn Clauses\"></a>Propositional Horn Clauses</h3><ul>\n<li>At most one positive literal</li>\n<li>Satisfiability can be tested in linear time</li>\n<li>Resolution is fast for Horn clauses, and very slow in non-Horn clauses<ul>\n<li>resolve two horns → one horn</li>\n</ul>\n</li>\n<li>Basis of Prolog<ul>\n<li>Head:-body</li>\n</ul>\n</li>\n<li>inference done by forward and backward chaining</li>\n</ul>\n<h4 id=\"Forward-and-Backward-Chaining\"><a href=\"#Forward-and-Backward-Chaining\" class=\"headerlink\" title=\"Forward and Backward Chaining\"></a>Forward and Backward Chaining</h4><ul>\n<li><p>Horn Form (restricted)</p>\n<ul>\n<li>KB = conjunction of Horn clauses</li>\n</ul>\n</li>\n<li><p>Horn clause =</p>\n<ul>\n<li>proposition symbol, or</li>\n<li>(conjunction of symbols) =&gt; symbol</li>\n</ul>\n</li>\n<li><p>Modus Ponens(肯定前件)(for Horn Form): complete for Horn KBs</p>\n<ul>\n<li>used with forward chaining or backward chaining</li>\n<li>run in linear time</li>\n</ul>\n</li>\n<li><p>Forward Chaining</p>\n<ul>\n<li>fire any rule whose premises are satisfied in the KB, add its conclusion to the KB, until query is found</li>\n<li><img data-src=\"/img/AI/7-forward-chaining.png\" alt=\"\"></li>\n</ul>\n</li>\n<li><p>Backward chaining    </p>\n<ul>\n<li>work backwards from the query q to prove q by BC, check if q is known already, or prove all premises of q</li>\n<li>Avoid loops<ul>\n<li>check if new subgoal is already on the goal stack</li>\n</ul>\n</li>\n<li>Avoid repeated work<ul>\n<li>check new subgoal</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Forward vs. backward chaining  </p>\n<ul>\n<li>both sound and complete for Horn KB</li>\n<li>FC is data-driven, automatic, unconscious processing<ul>\n<li>e.g., object recognition, routine decisions</li>\n<li>May do <strong>lots of work that is irrelevant to the goal</strong></li>\n</ul>\n</li>\n<li>BC is goal-driven, appropriate for problem-solving,<ul>\n<li>e.g., Where are my keys? How do I get into a PhD program?</li>\n<li>Complexity of BC can be much less than linear in size of KB</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Davis-Putnam-Procedure-DPLL\"><a href=\"#Davis-Putnam-Procedure-DPLL\" class=\"headerlink\" title=\"Davis-Putnam Procedure(DPLL)\"></a>Davis-Putnam Procedure(DPLL)</h3><ul>\n<li>Introduced by Davis &amp; Putnam in 1960</li>\n<li>Modified by Davis, Logemann &amp; Loveland in 1962 [DPLL]<ul>\n<li>Resolution rule replaced by splitting rule</li>\n<li>Trades space for time</li>\n</ul>\n</li>\n</ul>\n<p>DPLL</p>\n<ul>\n<li>recursive, depth-first enumeration of possible models<ul>\n<li>determine if an input CNF is satisfiable with the following</li>\n</ul>\n</li>\n</ul>\n<p>Improvements  </p>\n<ul>\n<li>Early termination<ul>\n<li>A clause is true if any literal is true(用or相連)</li>\n<li>A sentence is false if any clause is false(因為用and相連)</li>\n</ul>\n</li>\n<li>Unit clause heuristic<ul>\n<li>only one non-false literal in the clause<ul>\n<li>The only literal in a unit clause must be true</li>\n</ul>\n</li>\n<li>a clause with just one literal (i.e. all other literals are assigned false)</li>\n</ul>\n</li>\n<li>Pure symbol heuristic<ul>\n<li>a symbol that always appears with the same sign in all clauses</li>\n<li>Ex. A and ~A would not both appear in a sentence if A  is pure</li>\n<li>Make a pure symbol literal true<ul>\n<li>在全設成true時, KB自然是true</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>DPLL(continue)</p>\n<ul>\n<li>Unit propagation</li>\n<li>Example <img data-src=\"/img/AI/7-dpll.png\" alt=\"\"></li>\n<li><img data-src=\"/img/AI/7-dpll-algo.png\" alt=\"\"></li>\n<li><strong>backtracking search</strong> for a model of the formula</li>\n<li>Interpretations are examined in a <strong>sequential</strong> manner<ul>\n<li>DPLL(KB, p←TRUE) is testing interpretations if p is TRUE</li>\n<li>DPLL(KB, p←FALSE) is testing interpretations if p is FALSE</li>\n</ul>\n</li>\n<li>For each interpretation, a reason is found that the formula is false in it<br>•Such a sequential search of interpretations is very fast<br>–DPLL is much faster than propositional resolution for non-Horn clauses<br>•Very fast data structures developed<br>•Popular for hardware verification</li>\n</ul>\n<h2 id=\"Chap08-First-Order-Logic\"><a href=\"#Chap08-First-Order-Logic\" class=\"headerlink\" title=\"Chap08 First-Order Logic\"></a>Chap08 First-Order Logic</h2><p>How Do Humans Process Knowledge?  </p>\n<ul>\n<li>people process the words to form some kind of nonverbal representation, which we call <strong>memory</strong></li>\n<li>Logic as a representation of the World <img data-src=\"/img/AI/8-logic-representation.png\" alt=\"\"></li>\n</ul>\n<p>Sapir-Whorf Hypothesis  </p>\n<ul>\n<li>The language we speak profoundly influences the way in which we think and make decisions<ul>\n<li>setting up the category structure by which we divide up the world into different sorts of objects<ul>\n<li>Eskimos have many words for snow and thus experience snow in a different way</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Two way to think(??)<ul>\n<li>aware of the distinctions only by learning the words</li>\n<li>distinctions emerge from individual experience and become matched with the words<br><img data-src=\"/img/AI/8-inference-procedure.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<p>Logics  </p>\n<ul>\n<li>A logic consists of the following:<ul>\n<li>A formal system describing states of affairs<ul>\n<li>Syntax</li>\n<li>Semantics</li>\n</ul>\n</li>\n<li>proof theory – a set of rules for deducing the entailments of a set of sentences</li>\n</ul>\n</li>\n<li>Ontological commitments<ul>\n<li>FOL: facts, objects, relations</li>\n<li>Probability theory: facts</li>\n</ul>\n</li>\n<li>Epistemological commitments<ul>\n<li>What an agent believes about facts, e.g. FOL: true/false/unknown probability theory: degree of belief [0..1]</li>\n</ul>\n</li>\n</ul>\n<p>Logical Truth and Belief</p>\n<ul>\n<li>Ontological Commitment: What exists in the world — TRUTH</li>\n<li>Epistemoligical Commitment: What an agent believes about facts — BELIEF</li>\n<li><img data-src=\"/img/AI/8-logic-table.png\" alt=\"\"></li>\n</ul>\n<p>(重複？)<br>Terminology  </p>\n<ul>\n<li>Propositional constants: true, false</li>\n<li>Interpretation<ul>\n<li>Truth assignments to propositional symbols</li>\n<li>Truth-functional meaning of logical connectives</li>\n</ul>\n</li>\n<li>Theory: a set of formulas in logic</li>\n<li>An interpretation is a model for a theory if it assigns true to each formula in the set.<ul>\n<li>A formula is satisfiable if it has (at least) a model</li>\n<li>A formula is valid if</li>\n<li>It is true under all possible interpretations<br>– Its negation is not satisfiable.</li>\n</ul>\n</li>\n</ul>\n<p>Propositional Logic  </p>\n<ul>\n<li>Propositional logic is declarative</li>\n<li>Propositional logic allows partial/disjunctive/negated information<ul>\n<li>(unlike most data structures and databases)</li>\n</ul>\n</li>\n<li>Propositional logic is compositional:<ul>\n<li>meaning of B1,1 ∧ P1,2 is derived from meaning of B1,1 and of P1,2</li>\n</ul>\n</li>\n<li>Meaning in propositional logic is context-independent<ul>\n<li>(unlike natural language, where meaning depends on context)</li>\n</ul>\n</li>\n<li><strong>Propositional logic has very limited expressive power</strong><ul>\n<li>unlike natural language</li>\n<li>E.g., cannot say “pits cause breezes in adjacent squares“<ul>\n<li>except by writing one sentence for each square</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>wumpus-world agent using propositional logic<br>→ 64 distinct proposition symbols, 155 sentences<br>contains “physics” sentences for every single square<br>a lot of clauses</p>\n<p>First-Order Logic</p>\n<ul>\n<li>propositional logic assumes the world contains facts</li>\n<li>first-order logic assumes the world contains<ul>\n<li>Objects: people, houses, numbers, colors, baseball games, wars, …</li>\n<li>Relations: red, round, prime, brother of, bigger than, part of, comes between, …</li>\n<li>Functions: father of, best friend, one more than, plus, …</li>\n</ul>\n</li>\n</ul>\n<p>Syntax of FOL: Basic elements</p>\n<ul>\n<li>Constants<ul>\n<li>KingJohn, 2, NUS,…</li>\n</ul>\n</li>\n<li>Predicates<ul>\n<li>Brother, &gt;,…</li>\n</ul>\n</li>\n<li>Functions<ul>\n<li>Sqrt, LeftLegOf,…</li>\n</ul>\n</li>\n<li>Variables<ul>\n<li>x, y, a, b,…</li>\n</ul>\n</li>\n<li>Connectives<ul>\n<li>¬, ⇒, ∧, ∨, ⇔</li>\n</ul>\n</li>\n<li>Equality<ul>\n<li>=</li>\n</ul>\n</li>\n<li>Quantifiers<ul>\n<li>∀, ∃</li>\n</ul>\n</li>\n</ul>\n<p>Atomic sentences  </p>\n<ul>\n<li>Atomic sentence = predicate (term1,…,termn) or term1 = term2</li>\n<li>Term = function (term1,…,termn) or constant or variable</li>\n<li>Examples<ul>\n<li>King John is the brother of Richard the Lion Heart<ul>\n<li>Brother(KingJohn,RichardTheLionheart)</li>\n</ul>\n</li>\n<li>Richard’s left leg is longer than King John’s<ul>\n<li>Greater-than(Length(LeftLegOf(Richard)),Length(LeftLegOf(KingJohn)))</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>Complex sentences</p>\n<ul>\n<li>Complex sentences are made from atomic sentences using connectives<ul>\n<li>¬S,S1 ∧ S2,S1 ∨ S2,S1 ⇒ S2,S1 ⇔ S2</li>\n</ul>\n</li>\n<li>Examples<ul>\n<li>Sibling(KingJohn,Richard) ⇒ Sibling(Richard,KingJohn)</li>\n</ul>\n</li>\n</ul>\n<p>Truth in First-Order Logic(??)  </p>\n<ul>\n<li>Sentences are true with respect to a model and an interpretation</li>\n<li>Model<ul>\n<li>objects (domain elements)</li>\n<li>relations among objects</li>\n</ul>\n</li>\n<li>Interpretation specifies referents for<ul>\n<li>constant symbols → objects</li>\n<li>predicate symbols → relations</li>\n<li>function symbols → functional relations</li>\n</ul>\n</li>\n<li>An atomic sentence predicate(term1,…,termn) is true iff the objects referred to by term1,…,termn are in the relation referred to by predicate</li>\n</ul>\n<p>Models for FOL</p>\n<ul>\n<li>We can enumerate the models for a given KB vocabulary<ul>\n<li>For each number of domain elements n from 1 to ∞</li>\n</ul>\n</li>\n<li>Computing entailment by enumerating the models is not easy</li>\n<li><img data-src=\"/img/AI/8-fol-model.png\" alt=\"\"></li>\n</ul>\n<p>Knowledge Engineering in FOL  </p>\n<ol>\n<li>Identify the task</li>\n<li>Assemble the relevant knowledge</li>\n<li>Decide on a vocabulary of predicates, functions, and constants</li>\n<li>Encode general knowledge about the domain</li>\n<li>Encode a description of the specific problem instance</li>\n<li>Pose queries to the inference procedure and get answers</li>\n<li>Debug the knowledge base</li>\n</ol>\n<p>Domain: Electronic Circuits(Adder)  </p>\n<ul>\n<li>Identify the task<ul>\n<li>Does the circuit actually add properly?</li>\n</ul>\n</li>\n<li>Assemble the relevant knowledge<ul>\n<li>Composed of wires and gates</li>\n<li>Types of gates (AND, OR, XOR, NOT)</li>\n<li>Connections between terminals</li>\n<li>Irrelevant: size, shape, color, cost of gates</li>\n</ul>\n</li>\n<li>Decide on a vocabulary<ul>\n<li>Alternatives<ul>\n<li>Type(X1) = XOR</li>\n<li>Type(X1, XOR)</li>\n<li>XOR(X1)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>General Domain Knowledge<ul>\n<li>∀t1,t2 Connected(t1, t2) ⇒ Signal(t1) = Signal(t2)</li>\n<li>∀t Signal(t) = 1 ∨ Signal(t) = 0</li>\n<li>1 ≠ 0</li>\n<li>∀t1,t2 Connected(t1, t2) ⇒ Connected(t2, t1)</li>\n<li>∀g Type(g) = OR ⇒ Signal(Out(1,g)) = 1 ⇔ ∃n Signal(In(n,g)) = 1</li>\n<li>∀g Type(g) = AND ⇒ Signal(Out(1,g)) = 0 ⇔ ∃n Signal(In(n,g)) = 0</li>\n<li>g Type(g) = XOR ⇒ Signal(Out(1,g)) = 1 ⇔ Signal(In(1,g)) ≠ Signal(In2,g))</li>\n<li>∀g Type(g) = NOT ⇒ Signal(Out(1,g)) ≠ Signal(In(1,g))</li>\n</ul>\n</li>\n<li>Specific Problem Instance<ul>\n<li>Type(X1) = XOR Type(X2) = XOR</li>\n<li>Type(A1) = AND Type(A2) = AND</li>\n<li>Type(O1) = OR</li>\n<li>Connected(Out(1,X1),In(1,X2)) Connected(In(1,C1),In(1,X1))</li>\n<li>Connected(Out(1,X1),In(2,A2)) Connected(In(1,C1),In(1,A1))</li>\n<li>Connected(Out(1,A2),In(1,O1)) Connected(In(2,C1),In(2,X1))</li>\n<li>Connected(Out(1,A1),In(2,O1)) Connected(In(2,C1),In(2,A1))</li>\n<li>Connected(Out(1,X2),Out(1,C1)) Connected(In(3,C1),In(2,X2))</li>\n<li>Connected(Out(1,O1),Out(2,C1)) Connected(In(3,C1),In(1,A2))</li>\n</ul>\n</li>\n<li>Query<ul>\n<li>What are the possible sets of values of all the terminals for the adder circuit?</li>\n<li>∃i1,i2,i3,o1,o2 Signal(In(1,C_1)) = i1 ∧ Signal(In(2,C1)) = i2 ∧ Signal(In(3,C1)) = i3 ∧ Signal(Out(1,C1)) = o1 ∧ Signal(Out(2,C1)) = o2</li>\n</ul>\n</li>\n</ul>\n<p>Domain: Kinship(親屬關係)  </p>\n<ul>\n<li>Brothers are siblings<ul>\n<li>∀x,y Brother(x,y) ⇔ Sibling(x,y)</li>\n</ul>\n</li>\n<li>One’s mother is one’s female parent<ul>\n<li>∀m,c Mother(c) = m ⇔ (Female(m) ∧ Parent(m,c))</li>\n</ul>\n</li>\n<li>“Sibling” is symmetric<ul>\n<li>∀x,y Sibling(x,y) ⇔ Sibling(y,x)</li>\n</ul>\n</li>\n<li>A first cousin is a child of a parent’s sibling<ul>\n<li>∀x,y FirstCousin(x,y) ⇔ ∃p,ps Parent(p,x) ∧ Sibling(ps,p) ∧ Parent(ps,y)</li>\n</ul>\n</li>\n</ul>\n<p>Domain: Set   </p>\n<ul>\n<li>∀s Set(s) ⇔ (s = {} ) ∨ (∃x,s2 Set(s2) ∧ s = {x|s2})</li>\n<li>¬∃x,s {x|s} = {}</li>\n<li>∀x,s x ∈ s ⇔ s = {x|s}</li>\n<li>∀x,s x ∈ s ⇔ [ ∃y,s2} (s = {y|s2} ∧ (x = y ∨ x ∈ s2))]</li>\n<li>∀s1,s2 s1 ⊆ s2 ⇔ (∀x x ∈ s1 ⇒ x ∈ s2)</li>\n<li>∀s1,s2 (s1 = s2) ⇔ (s1 ⊆ s2 ∧ s2 ⊆ s1)</li>\n<li>∀x,s1,s2 x ∈ (s1 ∩ s2) ⇔ (x ∈ s1 ∧ x ∈ s2)</li>\n<li>∀x,s1,s2 x ∈ (s1 ∪ s2) ⇔ (x ∈ s1 ∨ x ∈ s2)</li>\n</ul>\n<p>Universal Qantification  </p>\n<ul>\n<li>∀<variables> <sentence><ul>\n<li>Everyone at NTU is smart<ul>\n<li>∀x At(x,NTU) ⇒ Smart(x)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>equivalent to the conjunction of instantiations(例證來源) of P<ul>\n<li>At(KingJohn,NTU) ⇒ Smart(KingJohn) ∧ At(Richard,NTU) ⇒ Smart(Richard) ∧ At(Mary,NTU) ⇒ Smart(Mary) …</li>\n</ul>\n</li>\n<li>Common Mistake<ul>\n<li>Typically, ⇒ is the main connective with ∀</li>\n<li>Wrong: using ∧ as the main connective with ∀</li>\n<li>∀x At(x,NTU) ∧ Smart(x) means “Everyone is at NTU and everyone is smart”</li>\n</ul>\n</li>\n</ul>\n<p>Existential Quantification</p>\n<ul>\n<li>∃<variables> <sentence><ul>\n<li>Someone at NTU is smart<ul>\n<li>∃x At(x,NTU) ∧ Smart(x)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>equivalent to the disjunction of instantiations of P<ul>\n<li>At(KingJohn,NTU) ∧ Smart(KingJohn) ∨ At(Richard,NTU) ∧ Smart(Richard) ∨ At(Mary,NTU) ∧ Smart(Mary) ∨ …</li>\n</ul>\n</li>\n<li>Typically, ∧ is the main connective with ∃<ul>\n<li>Common mistake: using ⇒ as the main connective with ∃</li>\n<li>∃x At(x,NTU) ⇒ Smart(x) <strong>is true if there is anyone who is not at NTU!</strong></li>\n</ul>\n</li>\n</ul>\n<p>Properties of Quantifiers  </p>\n<ul>\n<li>∀x ∀y = ∀y ∀x</li>\n<li>∃x ∃y = ∃y ∃x</li>\n<li>∃x ∀y ≠ ∀y ∃x<ul>\n<li>∃x ∀y Loves(x,y)<ul>\n<li>“There is a person who loves everyone in the world”</li>\n</ul>\n</li>\n<li>∀y ∃x Loves(x,y)<ul>\n<li>“Everyone in the world is loved by at least one person”</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Quantifier duality<ul>\n<li>each can be expressed using the other</li>\n<li>∀x Likes(x,IceCream) ↔ ¬∃x ¬Likes(x,IceCream)</li>\n<li>∃x Likes(x,Broccoli) ↔ ¬∀x ¬Likes(x,Broccoli)</li>\n</ul>\n</li>\n</ul>\n<p>Unification</p>\n<ul>\n<li>To unify Knows(John,x) and Knows(y,z)<ul>\n<li>MGU = { y/John, x/z }</li>\n</ul>\n</li>\n<li>There is a single most general unifier (MGU) that is unique up to renaming of variables</li>\n<li>We can get the inference immediately if we can find a substitution θ such that King(x) and Greedy(x) match King(John) and Greedy(y)</li>\n<li>Unify(α,β) = θ if αθ = βθ</li>\n<li><img data-src=\"/img/AI/8-unification.png\" alt=\"\"></li>\n<li><img data-src=\"/img/AI/8-unify-algo.png\" alt=\"\"></li>\n<li>Standardizing apart eliminates overlap of variables<ul>\n<li>Knows(z17,OJ)</li>\n</ul>\n</li>\n</ul>\n<p>Conversion to CNF  </p>\n<ul>\n<li>Everyone who loves all animals is loved by someone</li>\n<li>∀x [∀y Animal(y) ⇒ Loves(x,y)] ⇒ [∃y Loves(y,x)]</li>\n</ul>\n<ol>\n<li>Eliminate biconditionals and implications<br>∀x [¬∀y ¬Animal(y) ∨ Loves(x,y)] ∨ [∃y Loves(y,x)]</li>\n<li>Move ¬ inwards: ¬∀x p ≡ ∃x ¬p, ¬ ∃x p ≡ ∀x ¬p<br>∀x [∃y ¬(¬Animal(y) ∨ Loves(x,y))] ∨ [∃y Loves(y,x)]<br>∀x [∃y ¬¬Animal(y) ∧ ¬Loves(x,y)] ∨ [∃y Loves(y,x)]<br>∀x [∃y Animal(y) ∧ ¬Loves(x,y)] ∨ [∃y Loves(y,x)]</li>\n<li>Standardize variables: each quantifier should use a different one<br>∀x [∃y Animal(y) ∧ ¬Loves(x,y)] ∨ [∃z Loves(z,x)]</li>\n<li></li>\n<li>Skolemize: a more general form of existential instantiation<br>Each existential variable is replaced by a Skolem function of the enclosing universally quantified variables<br>∀x [Animal(F(x)) ∧ ¬Loves(x,F(x))] ∨ Loves(G(x),x)</li>\n<li>Drop universal quantifiers<br>[Animal(F(x)) ∧ ¬Loves(x,F(x))] ∨ Loves(G(x),x)</li>\n<li>Distribute ∨ over ∧<br>[Animal(F(x)) ∨ Loves(G(x),x)] ∧ [¬Loves(x,F(x)) ∨ Loves(G(x),x)]</li>\n</ol>\n<p>First-order logic   </p>\n<ul>\n<li>objects and relations are semantic</li>\n<li>syntax: constants, functions, predicates, equality, quantifiers</li>\n<li>Increased expressive power: sufficient to define wumpus world</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li>Jane Hsu 上課講義</li>\n<li>Artificial Intelligence: A Modern Approach</li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2FpbWEuY3MuYmVya2VsZXkuZWR1L2luc3RydWN0b3JzLmh0bWw=\">http://aima.cs.berkeley.edu/instructors.html<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jcy51YmMuY2EvfmhraG9zcmF2L2FpLzMxMC0yMDExLmh0bWw=\">http://www.cs.ubc.ca/~hkhosrav/ai/310-2011.html<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvQXJ0aWZpY2lhbF9JbnRlbGxpZ2VuY2U=\">https://en.wikibooks.org/wiki/Artificial_Intelligence<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n",
            "tags": [
                "artificial intelligence",
                "search",
                "First-Order Logic"
            ]
        }
    ]
}