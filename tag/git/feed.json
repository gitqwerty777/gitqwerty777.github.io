{
    "version": "https://jsonfeed.org/version/1",
    "title": "QWERTY • All posts by \"git\" tag",
    "description": "Programming | Computer Science | Thought",
    "home_page_url": "http://gitqwerty777.github.io",
    "items": [
        {
            "id": "http://gitqwerty777.github.io/git-introduction/",
            "url": "http://gitqwerty777.github.io/git-introduction/",
            "title": "Git觀念",
            "date_published": "2015-07-19T06:03:11.000Z",
            "content_html": "<h2 id=\"Git的特點\"><a href=\"#Git的特點\" class=\"headerlink\" title=\"Git的特點\"></a>Git的特點</h2><ul>\n<li>分散式開發<ul>\n<li>每個人都有完整的容器，各自獨立</li>\n<li>不需要中央管理</li>\n</ul>\n</li>\n<li>非擠壓合併<ul>\n<li>合併後仍包含所有被合併分支的記錄</li>\n<li><code>git merge/pull --squash</code> 強迫擠壓</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n\n<p><img data-src=\"https://image.slidesharecdn.com/git-getreadytouseit-140228043813-phpapp02/95/git-get-ready-to-use-it-5-638.jpg?cb=1393562489\" alt=\"\"></p>\n<h2 id=\"Git安裝\"><a href=\"#Git安裝\" class=\"headerlink\" title=\"Git安裝\"></a>Git安裝</h2><ul>\n<li>Debian/Ubuntu: 主要: <code>git-core</code> 和 <code>git-doc</code><ul>\n<li>選擇性: <code>git-gui</code>, <code>gitk</code>(圖形化), <code>gitweb</code> …</li>\n</ul>\n</li>\n<li>Windows: <code>Cygwin</code>, <code>msysGit</code>, <code>github on windows</code></li>\n</ul>\n<h2 id=\"Git常用名稱\"><a href=\"#Git常用名稱\" class=\"headerlink\" title=\"Git常用名稱\"></a>Git常用名稱</h2><ul>\n<li>origin： 遠端(remote) Repository 的別稱，預設即為origin/master分支<ul>\n<li><code>git clone</code>的時候會自動設定origin</li>\n</ul>\n</li>\n<li>master： 本地(local) Repository 的 master分支<ul>\n<li>名為master的分支通常是專案中的主要分支</li>\n</ul>\n</li>\n<li>HEAD<ul>\n<li>目前分支的最新一個提交</li>\n</ul>\n</li>\n<li>相對名稱<ul>\n<li>HEAD/HEAD^/HEAD^^/HEAD~4<ul>\n<li>代表目前版本/前一版/前二版/前四版的提交</li>\n</ul>\n</li>\n<li>HEAD^1/HEAD^2/ …<ul>\n<li>代表第一個父提交，第二個父提交 ……</li>\n</ul>\n</li>\n<li>A…B<ul>\n<li>A和B的相對差異</li>\n<li>列出A和B的祖先，直到A和B的分歧點</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>git rev-parse HEAD</code>: 取得代稱(HEAD^, HEAD~1, tag)的辨識碼</li>\n</ul>\n<ul>\n<li>ORIG_HEAD：合併或重設前的HEAD</li>\n<li>FETCH_HEAD：fetch所抓取的HEAD</li>\n<li>MERGE_HEAD：合併時，另一個分支的HEAD</li>\n</ul>\n<h2 id=\"設定檔\"><a href=\"#設定檔\" class=\"headerlink\" title=\"設定檔\"></a>設定檔</h2><ol>\n<li>容器的設定檔 <code>.git/config</code></li>\n<li>使用者的設定檔 <code>~/.gitconfig</code></li>\n<li>全系統的設定檔 <code>/etc/gitconfig</code></li>\n</ol>\n<p>優先級： 1 &gt; 2 &gt; 3</p>\n<h2 id=\"Git資料結構\"><a href=\"#Git資料結構\" class=\"headerlink\" title=\"Git資料結構\"></a>Git資料結構</h2><p>Index 和 Data:[Blobs, Tree, Commits, Tags]</p>\n<ul>\n<li>Data<ul>\n<li>Blob(binary large object): 檔案本身<ul>\n<li>新增檔案時，看的是檔案的sha1，而不是檔名<ul>\n<li>若有兩個檔案sha1相同，則git只會有一份blob</li>\n</ul>\n</li>\n<li>打包機制(pack file)：找內容相似的檔案，只儲存一份+差異的部分</li>\n</ul>\n</li>\n<li>Tree: 目錄資訊，指向Blobs<ul>\n<li>記錄Blob的辨識碼，檔案的資訊(如檔名)，子Tree(子資料夾)等</li>\n<li>Git可以用Tree快速產生兩個版本間的差異</li>\n</ul>\n</li>\n<li>Commit: 更動資訊，新的Commit會指向前一個Commit<ul>\n<li>包含作者，時間，commit對應的目錄(Tree)，commit message</li>\n</ul>\n</li>\n<li>Tag: 記錄commit的別名<ul>\n<li>lightweight tag<ul>\n<li>容器私有的</li>\n</ul>\n</li>\n<li>annotated tag<ul>\n<li>正式的tag，以物件方向儲存</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Index<ul>\n<li>即為Staging area(暫存區)</li>\n<li>可視為一顆Tree，在<code>git add</code>之後就將新檔案加入Tree中</li>\n<li>commit時，commit的Tree就是目前的index</li>\n</ul>\n</li>\n</ul>\n<p>版本和Tag都是指標，指向某個commit <img data-src=\"/img/Other/artist-test.png\" alt=\"\"></p>\n<h2 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h2><ul>\n<li>可視為指向某個commit的指標</li>\n<li>切換的時候工作目錄(容器所在的資料夾)會被改變</li>\n<li>用途<ul>\n<li>分隔 測試、開發、穩定的版本<pre><code>- debug分支\n- feature分支</code></pre></li>\n</ul>\n</li>\n<li>命名時可以分層<ul>\n<li><code>bug/...</code></li>\n<li><code>release/...</code></li>\n</ul>\n</li>\n<li>開發時用branch(pointer)，完成後可用tag取代(const pointer)</li>\n<li>分支是local的資訊<ul>\n<li>平常上傳只會將目前的HEAD和遠端分支的HEAD同步</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分支種類\"><a href=\"#分支種類\" class=\"headerlink\" title=\"分支種類\"></a>分支種類</h3><ul>\n<li>唯讀<ul>\n<li>遠端追蹤分支：蒐集遠端每個分支的變更</li>\n<li>本地追蹤分支：蒐集本地分支和遠端追蹤分支的變更</li>\n</ul>\n</li>\n<li>本地分支：即平常使用的分支</li>\n<li>遠端分支</li>\n</ul>\n<h2 id=\"合併\"><a href=\"#合併\" class=\"headerlink\" title=\"合併\"></a>合併</h2><p>每次提交和合併的時間間隔愈短，每次的衝突愈少，愈容易實作。</p>\n<p>同一條線上的合併  </p>\n<ul>\n<li>不會有新提交，只會移動branch指標</li>\n<li>目前版本比被合併版本新 → Already up to date</li>\n<li>目前版本比被合併版本舊 → fast-forward(快轉)<ul>\n<li>將目前版本移動到被合併版本的HEAD</li>\n<li><strong>git只允許fast-forward的push</strong></li>\n</ul>\n</li>\n</ul>\n<p>正常的合併</p>\n<ol>\n<li>Resolve(直觀的方法)<ul>\n<li>只能用在兩個分支的合併</li>\n<li>以共同的祖先為基礎，套用被合併版本的變更到目前版本</li>\n</ul>\n</li>\n<li>Recursive(預設方法)<ul>\n<li>只能用在兩個分支的合併</li>\n<li>兩個版本有多個共同祖先的時候，先將所有祖先合併成一個暫時性的版本，再以此版本為基礎用Resolve方法<ul>\n<li>在多個祖先合併時可能也有相同的問題，此時用同方法遞迴</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Octopus<ul>\n<li>多次呼叫Recursive，每次處理一個分支</li>\n<li>可用在多分支的合併</li>\n</ul>\n</li>\n</ol>\n<p>特殊合併 <!-- investigate further --></p>\n<ul>\n<li>Ours<ul>\n<li>合併時只採用現在版本的變更<pre><code>- 但留下歷史記錄(即其他版本的樹仍存在於父節點)</code></pre>  <img data-src=\"https://image.slidesharecdn.com/paolucci-git-power-routines-150722082712-lva1-app6891/95/git-power-routines-30-638.jpg?cb=1437553811\" alt=\"\"></li>\n<li>通常用於<ul>\n<li>已經有其他版本的變更時</li>\n<li>只想要別人的歷史記錄，不想要其他人的變更</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"修改提交\"><a href=\"#修改提交\" class=\"headerlink\" title=\"修改提交\"></a>修改提交</h2><p>理由</p>\n<ul>\n<li>大小適當<ul>\n<li>將大範圍的提交拆解成小的，有主題的變更</li>\n<li>結合相似的變更成為一個大的提交</li>\n</ul>\n</li>\n<li>步驟分明<ul>\n<li>排序使其更合理</li>\n<li>移除不必要的提交</li>\n</ul>\n</li>\n<li>註：需要在其他開發者取得你的repository之前(git push之前)，以避免歷史不同步</li>\n</ul>\n<p>方法  </p>\n<ul>\n<li><code>git rebase</code></li>\n</ul>\n<h3 id=\"回復-git-reset\"><a href=\"#回復-git-reset\" class=\"headerlink\" title=\"回復(git reset)\"></a>回復(git reset)</h3><ul>\n<li>–soft: 將HEAD還原至指定commit</li>\n<li>–mixed: 將HEAD和Index(staging area)還原至指定commit，工作目錄不變</li>\n<li>–hard: 將HEAD和Index和工作目錄還原至指定commit</li>\n<li>被取代的HEAD會放在ORIG_HEAD</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git reset [--soft/mixed/hard] [commit] <span class=\"comment\"># default is mixed</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 變更上一次的提交</span></span><br><span class=\"line\">git reset HEAD^ <span class=\"comment\"># 此時上一次的提交已經不存在，但是工作目錄中的資料相同</span></span><br><span class=\"line\"><span class=\"comment\"># do some modification</span></span><br><span class=\"line\">git commit <span class=\"comment\"># 會覆蓋上一次的commit</span></span><br></pre></td></tr></table></figure>\n<p>通常用於清除錯誤</p>\n<ul>\n<li>cherry-pick<ul>\n<li>拿取指定commit到目前分支</li>\n<li><code>git cherry-pick [commit]</code></li>\n<li>使用時機<ul>\n<li>若有多個branch都找到相同的bug，可以在每個branch都cherry-pick debug的commit<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git checkout release</span><br><span class=\"line\">git cherry-pick develop~2 <span class=\"comment\"># get debug commit from develop branch</span></span><br></pre></td></tr></table></figure></li>\n<li>將某個分支的commit移植到另一個branch<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># in develop: W → X → Y → Z</span></span><br><span class=\"line\">git checkout master</span><br><span class=\"line\">git cherry-pick develop^ <span class=\"comment\"># Y</span></span><br><span class=\"line\">git cherry-pick develop~3 <span class=\"comment\"># W</span></span><br><span class=\"line\">git cherry-pick develop~2 <span class=\"comment\"># X</span></span><br><span class=\"line\">git cherry-pick develop <span class=\"comment\"># Z</span></span><br><span class=\"line\"><span class=\"comment\"># alternative</span></span><br><span class=\"line\">git cherry-pick develop^3..develop</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>如果要合併多個，可以加上 -n 指令就不會先幫你 commit，這樣可以多選幾個要合併的commit，最後再 git commit即可 <!-- ??? --></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><ul>\n<li>裸容器(bare)<ul>\n<li>沒有工作目錄、目前分支</li>\n<li>其他人可以用clone及fetch取得資料，push更新</li>\n<li>如github</li>\n<li>產生: <code>git init --bare</code></li>\n</ul>\n</li>\n<li>開發容器</li>\n</ul>\n<h2 id=\"建立備份\"><a href=\"#建立備份\" class=\"headerlink\" title=\"建立備份\"></a>建立備份</h2><p>自行建立裸容器，並加入remote，即可push, pull了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># assume mygitrepository is already a git repository</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /tmp/Backup <span class=\"comment\"># for example, you may want to put on server</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> --bare mygitrepository mygitrepository.git <span class=\"comment\"># create bare repository</span></span><br><span class=\"line\"><span class=\"comment\"># backup repository often use .git suffix</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> mygitrepository</span><br><span class=\"line\">git remote add origin /tmp/Backup/mygitrepository</span><br><span class=\"line\"><span class=\"comment\"># can use other name to replace \"origin\"</span></span><br><span class=\"line\">git remote update <span class=\"comment\"># 建立遠端追蹤分支(update remote information)</span></span><br></pre></td></tr></table></figure>\n<!--try it at workstation-->\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh myhost.com <span class=\"comment\"># build it on server</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /git</span><br><span class=\"line\">mkdir newrepo.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> newrepo.git</span><br><span class=\"line\">git init --shared --bare</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Git-tag\"><a href=\"#Git-tag\" class=\"headerlink\" title=\"Git tag\"></a>Git tag</h2><ul>\n<li>輕量級(lightweight)<ul>\n<li>像是沒有更動的分支</li>\n<li>指到特定commit的指標</li>\n<li>臨時加註標籤</li>\n<li><code>git tag [tagname] [commit]</code></li>\n</ul>\n</li>\n<li>含附註(annotated)<ul>\n<li>實際存在Git資料庫上的完整物件</li>\n<li>具備檢查碼、e-mail和日期，也包含標籤訊息</li>\n<li>可以被GNU Privacy Guard (GPG)簽署和驗證</li>\n<li><code>git tag -a [tagname] -m [tag message]</code></li>\n<li><code>git tag -a [tagname] [commit]</code></li>\n</ul>\n</li>\n<li>顯示詳細資訊: <code>git show [tagname]</code></li>\n<li><code>git push</code>指令並不會將標籤傳到遠端伺服器上。必須透過<code>git push origin [tagname]</code>指令<ul>\n<li>push 所有標籤: <code>git push origin --tags</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Git-Submodule\"><a href=\"#Git-Submodule\" class=\"headerlink\" title=\"Git Submodule\"></a>Git Submodule</h2><ul>\n<li>新增 submodule<ul>\n<li><code>git submodule add [repository path] [local path]</code></li>\n<li>產生 <code>.gitmodules</code> 文件。這是一個設定檔，保存了專案 URL 和你拉取到的本地子目錄</li>\n</ul>\n</li>\n<li><code>git clone</code>後，submodule並不會一起下載，需要自己更新</li>\n<li><code>git submodule init</code><ul>\n<li>根據 <code>.gitmodules</code> 的名稱和 URL，將這些資訊註冊到 <code>.git/config</code> 內</li>\n</ul>\n</li>\n<li>更新submodule <ul>\n<li><code>git submodule update</code></li>\n<li>根據已註冊（也就是 <code>.git/config</code> ）的 submodule 進行更新，例如 clone 遺失的 submodule，所以執行這個指令前最好加上 –init</li>\n<li>update並不一定是submodule的最新版，而是在主repository的目前版本中，submodule所在的版本</li>\n</ul>\n</li>\n<li>將submodule更新到最新版<ul>\n<li><code>git submodule foreach --recursive git pull origin master</code></li>\n</ul>\n</li>\n<li><code>git submodule sync</code><ul>\n<li>如果 submodule 的 remote URL 有變動，可以在 <code>.gitmodules</code> 修正 URL，然後執行這個指令，便會將 submodule 的 remote URL 更正。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Git-Server-Hosting\"><a href=\"#Git-Server-Hosting\" class=\"headerlink\" title=\"Git Server Hosting\"></a>Git Server Hosting</h2><ul>\n<li>gitlab<ul>\n<li>功能齊全</li>\n<li>需要登入</li>\n</ul>\n</li>\n<li>cgit<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXQuengyYzQuY29tL2NnaXQvYWJvdXQv\">cgit主網站<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li>需開啟cgi功能<ul>\n<li><code>./cgit.cgi</code> 可觀看產生的html</li>\n</ul>\n</li>\n<li>安裝成功後在<code>/etc/cgitrc</code>中修改設定，否則404</li>\n<li>參考<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2xhbnR3NDQvY29uZmlnZmlsZS9ibG9iL21hc3Rlci9jZ2l0L2NnaXRyYw==\">lantw44的設定檔<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vYXJ0aWNsZXMvZHVwbGljYXRpbmctYS1yZXBvc2l0b3J5Lw==\">複製git裸容器<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jaHJpc2Rvd24ubmFtZS8yMDEzLzA3LzA1L3NldHRpbmctdXAtbG9jYWwtZ2l0aHViLW1pcnJvci13aXRoLWNnaXQtZ2l0LWRhZW1vbi5odG1s\">快速複製github中的repository<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2xpbnV4LmRpZS5uZXQvbWFuLzUvY2dpdHJj\">cgitrc詳細設定<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"其他工具\"><a href=\"#其他工具\" class=\"headerlink\" title=\"其他工具\"></a>其他工具</h2><ul>\n<li>gitstats<ul>\n<li>產生容器的分析資料</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poLXR3L3YxL0dpdC3ln7rnpI4t5qiZ57Gk\">Git-基礎-標籤<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ib29rcy5jb20udHcvcHJvZHVjdHMvMDAxMDU3NDA5MA==\">版本控制：使用Git<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9paG93ZXIudHcvYmxvZy9hcmNoaXZlcy81NDM2\">git 設定集<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb3RibG9ncy5jb20udHcvaGF0ZWxvdmUvYXJjaGl2ZS8yMDExLzEyLzI1L2ludHJvZHVjaW5nLWNvbnRpbnVvdXMtaW50ZWdyYXRpb24uYXNweA==\">https://dotblogs.com.tw/hatelove/archive/2011/12/25/introducing-continuous-integration.aspx<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvb3JpZ2FtaWFkZGljdC9naXQtZ2V0LXJlYWR5LXRvLXVzZS1pdA==\">git: get ready to use it<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cuY2hoLnR3L3Bvc3RzL2dpdC1zdWJtb2R1bGUv\">Git Submodule 用法筆記<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poLXR3L3YxL0dpdC0lRTUlQjclQTUlRTUlODUlQjctJUU1JUFEJTkwJUU2JUE4JUExJUU3JUI1JTg0LVN1Ym1vZHVsZXM=\">Git 工具 - 子模組 (Submodules)<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n",
            "tags": [
                "git"
            ]
        },
        {
            "id": "http://gitqwerty777.github.io/git-commands/",
            "url": "http://gitqwerty777.github.io/git-commands/",
            "title": "Git常用指令",
            "date_published": "2014-09-16T09:14:44.000Z",
            "content_html": "<p>主要參考此書：<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ib29rcy5jb20udHcvcHJvZHVjdHMvMDAxMDU3NDA5MA==\">版本控制：使用Git<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>建議初學者先看<a href=\"/git-introduction\">git觀念</a>及此篇的第一段</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Git基本觀念\"><a href=\"#Git基本觀念\" class=\"headerlink\" title=\"Git基本觀念\"></a>Git基本觀念</h2><table>\n<thead>\n<tr>\n<th>檔案階段</th>\n<th>檔案所在位置</th>\n<th>說明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>已修改</td>\n<td>Working Directory(工作目錄)</td>\n<td>經過修改的檔案</td>\n</tr>\n<tr>\n<td>已暫存</td>\n<td>Staging area(暫存區)</td>\n<td>要提交的變動清單</td>\n</tr>\n<tr>\n<td>已提交</td>\n<td>Repository(容器)</td>\n<td>已提交的檔案及變動記錄</td>\n</tr>\n</tbody></table>\n<p><img data-src=\"https://image.slidesharecdn.com/git-getreadytouseit-140228043813-phpapp02/95/git-get-ready-to-use-it-5-638.jpg?cb=1393562489\" alt=\"\"></p>\n<p>其他檔案階段</p>\n<ul>\n<li>被忽略：在名為<code>.gitignore</code>的檔案中修改想忽略的檔案，如暫存檔、log、或編譯後的object file、筆記<ul>\n<li>每個目錄都可以有自己的<code>.gitignore</code>檔，以較接近檔案的目錄為準</li>\n<li>可以用<code>git add -f</code>強制將被忽略的檔案加入暫存區</li>\n</ul>\n</li>\n</ul>\n<p>觀看檔案的狀態: <code>git status</code></p>\n<ul>\n<li>已修改: <code>Changes not staged for commit</code></li>\n<li>已暫存: <code>Changes to be committed</code></li>\n<li>已提交: 不顯示</li>\n</ul>\n<p>基本流程: 修改檔案 → 將修改的檔案加入 Staging area (<code>git add</code>) → 提交變更 (<code>git commit</code>) → 繼續修改檔案(循環)</p>\n<p>若要和他人共用，要在線上容器和本機容器間進行同步(<code>git push</code>, <code>git pull</code>)</p>\n<p>提交(commit，也稱送交)</p>\n<ul>\n<li>版本和容器變動的最小單位<ul>\n<li><strong>一個commit = 一個版本</strong></li>\n<li>git 中的 <code>HEAD</code> 等於目前所在的版本</li>\n</ul>\n</li>\n<li>不一定所有檔案都要提交<ul>\n<li>只有加入Staging area的檔案會被提交</li>\n</ul>\n</li>\n<li>提交時機<ul>\n<li>程式處於穩定狀態<ul>\n<li>可以正確執行</li>\n<li>測試完成</li>\n</ul>\n</li>\n<li>以時間為單位<ul>\n<li>結束一天的工作前</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>辨識碼</p>\n<ul>\n<li>所有物件都有一個獨特的辨識碼<ul>\n<li>包含commit, tag, 文件…都有辨識碼<ul>\n<li>其值為物件的SHA1 hash</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>下述指令的<code>[commit]</code>即為識別碼<ul>\n<li>在沒有重覆的情況下，可取前幾碼代表該物件</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"設定\"><a href=\"#設定\" class=\"headerlink\" title=\"設定\"></a>設定</h3><p>先設定自己的名字與信箱，因為git用名字與信箱來分辨作者</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 若不加 --global 則設定只會在該容器生效</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 設定使用者名稱(加上引號)</span></span><br><span class=\"line\">git config --global user.name <span class=\"string\">\"First Last\"</span></span><br><span class=\"line\"><span class=\"comment\"># 設定使用者電子郵件(加上引號)</span></span><br><span class=\"line\">git config --global user.email <span class=\"string\">\"user@example.com\"</span></span><br><span class=\"line\"><span class=\"comment\"># 開啟顏色，使git內容不會只有單一白色</span></span><br><span class=\"line\">git config --global color.ui <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 設定預設編輯器(提交時會用到)</span></span><br><span class=\"line\">git config --global core.editor <span class=\"string\">\"emacs\"</span></span><br><span class=\"line\"><span class=\"comment\"># 設定指令的縮寫(將git st設為git status的簡寫)</span></span><br><span class=\"line\">git config --global alias.st status</span><br><span class=\"line\"><span class=\"comment\"># 列出所有設定值</span></span><br><span class=\"line\">git config -l</span><br></pre></td></tr></table></figure>\n\n<p>設定預設提交格式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 方法1. 直接設定</span></span><br><span class=\"line\">git config --global commit.template <span class=\"variable\">$HOME</span>/.git-template</span><br><span class=\"line\"><span class=\"comment\"># 方法2. 在 .gitconfig 中設定</span></span><br><span class=\"line\">[commit]</span><br><span class=\"line\">template = /home/frank/.git-template</span><br></pre></td></tr></table></figure>\n<h3 id=\"實作範例\"><a href=\"#實作範例\" class=\"headerlink\" title=\"實作範例\"></a>實作範例</h3><p>初始化一個專案</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git init <span class=\"comment\"># 初始化，使當前目錄成為git的容器</span></span><br><span class=\"line\">touch README.md <span class=\"comment\"># 加上專案的說明文件(非必要)</span></span><br><span class=\"line\">git add README.md <span class=\"comment\"># 將說明文件加入暫存區</span></span><br><span class=\"line\">git commit -m <span class=\"string\">\"initial commit\"</span> <span class=\"comment\"># 提交變更</span></span><br></pre></td></tr></table></figure>\n\n<p>將本地的容器上傳到遠端(如github)的容器</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git remote add origin &lt;URL&gt; <span class=\"comment\"># 將遠端容器命名為origin</span></span><br><span class=\"line\">git push -u origin master <span class=\"comment\"># 從本地端的master branch上傳到origin的master branch</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"本篇：Git常用指令\"><a href=\"#本篇：Git常用指令\" class=\"headerlink\" title=\"本篇：Git常用指令\"></a>本篇：Git常用指令</h2><h3 id=\"Git檔案操作\"><a href=\"#Git檔案操作\" class=\"headerlink\" title=\"Git檔案操作\"></a>Git檔案操作</h3><h4 id=\"加入暫存區-add\"><a href=\"#加入暫存區-add\" class=\"headerlink\" title=\"加入暫存區: add\"></a>加入暫存區: add</h4><p><code>git add</code>：將檔案加入暫存區(staging area)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git add -i <span class=\"comment\"># 進入互動模式(推薦)</span></span><br><span class=\"line\"></span><br><span class=\"line\">git add [filename] <span class=\"comment\"># 將檔案加入staging area</span></span><br><span class=\"line\">git add -u <span class=\"comment\"># 只把「修改/刪除」的檔案加入staging area，「新增」的檔案不加入</span></span><br><span class=\"line\">git add -p <span class=\"comment\"># 部分暫存：git會詢問哪些檔，然後逐個顯示被選中檔案的每一個差異部分，</span></span><br><span class=\"line\"><span class=\"comment\"># 並詢問你是否希望暫存他們。(= git add --patch)</span></span><br><span class=\"line\">git add -A <span class=\"comment\"># stages All</span></span><br><span class=\"line\">git add .  <span class=\"comment\"># stages new and modified, without deleted</span></span><br></pre></td></tr></table></figure>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NzI1NDkvZGlmZmVyZW5jZS1iZXR3ZWVuLWdpdC1hZGQtYS1hbmQtZ2l0LWFkZA==\">參考資料<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>直接刪除/移動不會影響容器中的檔案，因為這項變動沒有告知git<br>若要在下一個版本刪除或移動檔案，需要用<code>git rm</code>或<code>git mv</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git rm [filename] <span class=\"comment\"># 在下一個版本移除，並實際刪除檔案</span></span><br><span class=\"line\">git rm --cache [filename] <span class=\"comment\"># 在下一個版本移除，但不實際刪除檔案</span></span><br><span class=\"line\">git mv [filename] [new-filename] <span class=\"comment\"># 改名、搬移檔案，並將變動加入staging area</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"checkout\"><a href=\"#checkout\" class=\"headerlink\" title=\"checkout\"></a>checkout</h4><p><strong>使檔案還原到指定提交時的版本</strong></p>\n<ul>\n<li>發現檔案改錯，用<code>git checkout filename</code>把檔案還原到最近的版本</li>\n<li><code>git checkout [commit] filename</code> 檔案會被還原到指定的commit時的版本</li>\n</ul>\n<h3 id=\"Git更新版本\"><a href=\"#Git更新版本\" class=\"headerlink\" title=\"Git更新版本\"></a>Git更新版本</h3><h4 id=\"提交新版本-commit\"><a href=\"#提交新版本-commit\" class=\"headerlink\" title=\"提交新版本(commit)\"></a>提交新版本(commit)</h4><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git commit <span class=\"comment\"># 會跳出編輯器，此時可編輯提交訊息</span></span><br><span class=\"line\">git commit -m <span class=\"string\">'commit message'</span> <span class=\"comment\"># 直接提交並指定提交訊息</span></span><br><span class=\"line\">git commit -a <span class=\"comment\"># 將所有修改過的檔案直接 commit(跳過add步驟), 不包含新增的檔案</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"存取遠端容器-push-pull\"><a href=\"#存取遠端容器-push-pull\" class=\"headerlink\" title=\"存取遠端容器: push, pull\"></a>存取遠端容器: push, pull</h4><p>遠端的repository名稱通常取名為<code>origin</code><br><code>push</code>: 上傳, <code>pull</code>: 下載</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git remote show <span class=\"comment\"># 顯示設定的遠端容器及其名稱、網址</span></span><br><span class=\"line\">git remote add origin [url] <span class=\"comment\"># 設定遠端容器連結並命名為origin</span></span><br><span class=\"line\">git push origin master <span class=\"comment\">#  從本地目前的branch上傳至遠端master</span></span><br><span class=\"line\">git pull origin master <span class=\"comment\">#  從遠端master更新到本地目前的branch</span></span><br><span class=\"line\">git pull origin/[branchB] [branchA] <span class=\"comment\"># 從遠端branchB更新到本地branchA</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> [url] [localRepositoryPath] <span class=\"comment\"># 複製遠端容器至本地</span></span><br><span class=\"line\">git fetch origin <span class=\"comment\"># 下載origin的branch到本地</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>push時，如果和遠端容器有衝突，需要先pull，在本地merge(處理衝突)後再push</li>\n<li>pull的機制：先 fetch 遠端的 branch，然後與本地端的 branch 做 merge<ul>\n<li>若有衝突，<strong>會多產生一個 merge commit</strong>來取代遠端有衝突的所有commit</li>\n<li>用<code>git pull --rebase origin master</code>可以保留雙方的commit</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Git分支-branch\"><a href=\"#Git分支-branch\" class=\"headerlink\" title=\"Git分支(branch)\"></a>Git分支(branch)</h3><p>分支(branch): 將特定版本(commit)命名</p>\n<p><code>git branch</code><br><code>git checkout</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git branch <span class=\"comment\"># 列出本地分支(前方有星號的為目前所在分支)</span></span><br><span class=\"line\">git branch -r <span class=\"comment\"># 列出遠端分支</span></span><br><span class=\"line\">git branch -a <span class=\"comment\"># 列出所有分支(本地+遠端)</span></span><br><span class=\"line\">git show-branch <span class=\"comment\"># 列出本地分支樹狀圖</span></span><br><span class=\"line\">git branch [branchname] [commit] <span class=\"comment\"># 在指定commit上建立分支</span></span><br><span class=\"line\">git branch -d [branchname] <span class=\"comment\"># 刪除指定分支</span></span><br><span class=\"line\">git branch -m [old-name] [new-name] <span class=\"comment\"># 重新命名分支</span></span><br><span class=\"line\">git branch [new-branch] [old-branch] <span class=\"comment\"># 由分支old-branch複製出新分支new-branch</span></span><br><span class=\"line\"></span><br><span class=\"line\">git checkout [branch] <span class=\"comment\"># 切換到指定分支</span></span><br><span class=\"line\">git checkout [commit] <span class=\"comment\"># 也可以切換到任何commit</span></span><br><span class=\"line\"><span class=\"comment\"># 若commit不在任何branch上，用 git branch 查看時，會顯示 (no branch)</span></span><br><span class=\"line\">git checkout -b [new-branch] <span class=\"comment\"># 建立並切換到新分支new-branch(從目前所在的分支複製)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>git checkout -m [branch]</code> # 將工作目錄的變動和分支合併，並切換到該分支</li>\n<li>git checkout 時，若已修改的檔案和checkout的版本產生衝突，則checkout不會執行<ul>\n<li>衝突時先<code>git stash</code>(暫時清空已修改的檔案)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Git-標籤-tag\"><a href=\"#Git-標籤-tag\" class=\"headerlink\" title=\"Git 標籤(tag)\"></a>Git 標籤(tag)</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git tag [tagname] [commit] <span class=\"comment\"># 在指定commit新增tag</span></span><br><span class=\"line\">git tag -d [tagname] <span class=\"comment\"># 刪除tag</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Git合併-merge\"><a href=\"#Git合併-merge\" class=\"headerlink\" title=\"Git合併(merge)\"></a>Git合併(merge)</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git merge [branch/commit] <span class=\"comment\"># 將指定的版本合併到目前所在的分支</span></span><br></pre></td></tr></table></figure>\n\n<p>產生衝突時：先用<code>git diff</code> <code>git status</code>查看<br>衝突的地方為如下格式</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">//version1 code</span></span><br><span class=\"line\">...</span><br><span class=\"line\">========</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">//version2 code</span></span><br><span class=\"line\">...</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>分別是兩個版本的差異。<br>將其修改後即可提交</p>\n<ul>\n<li><code>git diff --ours/--theirs</code> 可以查看原版本和衝突版本的差異(ours→合併的, theirs→被合併的)</li>\n<li><code>git diff</code> 用在衝突檔案時只會顯示衝突的部分，而不會顯示只有一邊修改的部分</li>\n</ul>\n<h3 id=\"Git-修改版本\"><a href=\"#Git-修改版本\" class=\"headerlink\" title=\"Git 修改版本\"></a>Git 修改版本</h3><h4 id=\"修改版本-rebase\"><a href=\"#修改版本-rebase\" class=\"headerlink\" title=\"修改版本: rebase\"></a>修改版本: rebase</h4><p><code>rebase</code>可以重新排序、編輯、移除、合併、拆分提交</p>\n<ul>\n<li>優點<ul>\n<li>可以不產生分支線和額外的merge commit</li>\n</ul>\n</li>\n<li>缺點<ul>\n<li><strong>等於改變提交記錄，僅適合還沒上傳的commit</strong></li>\n<li>commit被移動，所以特徵碼會改變(也就是<strong>原本的commit會被取代</strong>)</li>\n<li>commit的形狀會被改變(變成一條直線)<ul>\n<li>可用<code>--preserve-merge</code>參數保留形狀</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>麻煩<ul>\n<li>移動的commit若屬於多個分支，則每個分支都要重新指定位置</li>\n</ul>\n</li>\n</ul>\n<p>使用時機：想保留額外commit資訊時，可替代merge</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; debug rebase on master</span><br><span class=\"line\">git checkout debug</span><br><span class=\"line\">git rebase master</span><br><span class=\"line\"></span><br><span class=\"line\">Original:</span><br><span class=\"line\">master A → B→C→D→E</span><br><span class=\"line\">  |      ↘</span><br><span class=\"line\">debug      F→G→H</span><br><span class=\"line\"></span><br><span class=\"line\">After rebase:</span><br><span class=\"line\">master A → B→C→D→E</span><br><span class=\"line\">  |               ↘</span><br><span class=\"line\">debug               F→G→H</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git rebase -i [commit] <span class=\"comment\"># rebase互動模式(推薦)</span></span><br><span class=\"line\"><span class=\"comment\"># 互動模式指令：pick: commit, squash: 擠壓到前一個commit, edit: 停在此commit提交前的情形以修改(可以拆成多次commit) …</span></span><br><span class=\"line\"><span class=\"comment\"># 在rebase時遇到衝突的話，會提示使用者手動解決衝突(merge)</span></span><br><span class=\"line\">git rebase --<span class=\"built_in\">continue</span> <span class=\"comment\"># (解決衝突後)繼續rebase</span></span><br><span class=\"line\">git rebase --skip <span class=\"comment\"># 忽略一個原本要rebase的commit</span></span><br><span class=\"line\">git rebase --abort <span class=\"comment\"># 取消rebase</span></span><br><span class=\"line\"></span><br><span class=\"line\">git rebase --onto master [commitA] [commitB] <span class=\"comment\">#  使用onto可以將從A到B的提交移植到完全不同的分支(master)上</span></span><br></pre></td></tr></table></figure>\n<p>參考資料：<span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNjI2NjQyL2dpdC1yZXdyaXRlLWhpc3RvcnktcmVvcmRlci1hbmQtbWVyZ2UtY29tbWl0cw==\">修改一個分支的歷史–使用rebase<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"merge還是rebase\"><a href=\"#merge還是rebase\" class=\"headerlink\" title=\"merge還是rebase?\"></a>merge還是rebase?</h4><p>需要保留樹狀記錄就用merge，反之用rebase<br>個人較愛用rebase，理由是保留樹狀記錄只會造成日後版本維護的麻煩</p>\n<h4 id=\"修正版本-amend\"><a href=\"#修正版本-amend\" class=\"headerlink\" title=\"修正版本: amend\"></a>修正版本: amend</h4><ul>\n<li>修改<strong>最近一次</strong>的commit<ul>\n<li>staging area的修改會<strong>合併到最近的提交</strong></li>\n</ul>\n</li>\n<li>使用時機<ul>\n<li>提交訊息的修改</li>\n<li>發現一些<strong>小錯誤</strong><ul>\n<li>忘記add/多add檔案/找到小bug 的時候</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git add [filename] <span class=\"comment\"># 修改錯誤後加入暫存區</span></span><br><span class=\"line\">git commit --amend <span class=\"comment\"># 將此修改加入最近的提交</span></span><br><span class=\"line\"><span class=\"comment\">#==========</span></span><br><span class=\"line\">git commit --amend [file1] [file2] ... <span class=\"comment\">#  直接將指定檔案的變更加入最近的commit</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"回到指定版本-reset\"><a href=\"#回到指定版本-reset\" class=\"headerlink\" title=\"回到指定版本: reset\"></a>回到指定版本: reset</h4><!--將HEAD視為指標，平常branch的HEAD是指向最新的一次提交。但git reset可以移動HEAD到指定的提交版本\n(checkout, commit 等指令都會改變HEAD指標的位置)\n-->\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git reset [commit] [--soft/--mixed/--hard] <span class=\"comment\"># 還原到指定提交</span></span><br><span class=\"line\">git reset HEAD [filepath] <span class=\"comment\"># 將檔案從staging area移除 (= git checkout filepath)</span></span><br></pre></td></tr></table></figure>\n\n<pre><code>--mixed 暫存區也被改變，但工作目錄不變 (預設值，暫存區清空)\n--hard 暫存區和工作目錄都被改變(目前的目錄中，所有檔案的修改會消失)</code></pre><ul>\n<li><code>--soft</code><ul>\n<li>只有版本改變，檔案不改變</li>\n<li>版本改變造成的所有變更都會放在staging area<ul>\n<li>若你<code>reset --soft</code>到五天前的版本，那這五天內的commit變更都會在staging area</li>\n<li>若<code>reset --soft</code>後直接<code>git commit</code>，則最新的版本會和reset前的版本一模一樣</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>--mixed</code><ul>\n<li>只有版本改變，檔案不改變</li>\n<li>變更不會放在staging area, 要自己手動add</li>\n</ul>\n</li>\n<li><code>--hard</code><ul>\n<li>檔案會回到指定commit的狀態</li>\n<li>通常是出了嚴重問題後的解決方法</li>\n<li>若有檔案不在版本中(沒有被<code>add</code>,<code>commit</code>過)，<code>reset --hard</code>後檔案依舊存在</li>\n</ul>\n</li>\n</ul>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTI4MjQ1L3doYXRzLXRoZS1kaWZmZXJlbmNlLWJldHdlZW4tZ2l0LXJlc2V0LW1peGVkLXNvZnQtYW5kLWhhcmQ=\">Whats the difference between git reset –mixed, –soft, and –hard?<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h4 id=\"提交-revert\"><a href=\"#提交-revert\" class=\"headerlink\" title=\"提交: revert\"></a>提交: revert</h4><p><code>git revert [commit]</code></p>\n<ul>\n<li><strong>新增</strong>一筆commit，此commit會抵消之前的變更，使檔案像是回到指定版本<ul>\n<li>若最近的變更是寫一頁作文，revert會<strong>加上</strong>一個塗一頁立可白的變更<br>使用時機: 你的commit已經上傳，別人已下載，所以不適合用<code>git rebase</code>, <code>git reset</code>, <code>git commit --amend</code>等方法隨便修改版本記錄</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Git比較\"><a href=\"#Git比較\" class=\"headerlink\" title=\"Git比較\"></a>Git比較</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git diff <span class=\"comment\"># 比較實際檔案與目前版本的不同</span></span><br><span class=\"line\">git diff --cached <span class=\"comment\"># 比較staging area與目前版本的不同</span></span><br><span class=\"line\">         --<span class=\"built_in\">stat</span> <span class=\"comment\"># 只顯示檔名和不同的行數</span></span><br><span class=\"line\">git diff [commit] [commit] <span class=\"comment\"># 比較兩個版本的不同</span></span><br><span class=\"line\">git diff -S[string] <span class=\"comment\"># 只列出變更中，有包含string字串的差異</span></span><br><span class=\"line\">git diff -w <span class=\"comment\"># 不將空白視為變更</span></span><br><span class=\"line\">git diff [commit1]:[file1] [commit2]:[file2] <span class=\"comment\"># 比較兩個版本的指定檔案</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Git記錄-log-show\"><a href=\"#Git記錄-log-show\" class=\"headerlink\" title=\"Git記錄: log, show\"></a>Git記錄: log, show</h3><p><code>git log</code> 用來查詢提交記錄，有很多參數可以用<br>建議可以直接用GUI(<code>gitk</code>, <code>git gui</code>, <code>git instaweb</code>)來看</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> [commit] <span class=\"comment\"># 列出指定版本的記錄(也就是找其之前的記錄)</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> [commitA]..[commitB] <span class=\"comment\"># 列出從A到B的提交(不含A, 含B)</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> ^[commitA] <span class=\"comment\"># 顯示指定版本之後的提交</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> -[num] <span class=\"comment\"># 最近[num]筆的提交紀錄</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --no-merges <span class=\"comment\"># 不顯示合併的提交</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --graph <span class=\"comment\"># 顯示樹狀結構圖</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --<span class=\"built_in\">stat</span> <span class=\"comment\"># 顯示修改行數</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --author [username] <span class=\"comment\"># 指定使用者的提交</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --since=<span class=\"string\">\"2 weeks ago\"</span> <span class=\"comment\"># 近2週內的提交</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --follow [filename] <span class=\"comment\"># 列出包含該檔案變動的提交</span></span><br><span class=\"line\"></span><br><span class=\"line\">git show [commit] <span class=\"comment\"># 列出指定版本的最新提交的詳細修改內容</span></span><br><span class=\"line\">git show [commit]:[filename] <span class=\"comment\"># 顯示該提交的指定檔案</span></span><br></pre></td></tr></table></figure>\n\n<p>可以將版本記錄視為一顆樹，前一個版本為其父節點</p>\n<ul>\n<li>列出指定版本的記錄 = 找其祖先</li>\n<li><code>git diff foo..bar</code> = <code>git diff foo bar</code></li>\n<li><code>git diff foo...bar</code>: foo和bar的”merge base”(最近的共同祖先)和bar的差異</li>\n<li><code>git log foo bar</code>: 顯示所有foo和bar的提交(其中一方有即可)</li>\n<li><code>git log foo..bar</code>: 不屬於foo，屬於bar的提交</li>\n<li><code>git log foo...bar</code>: 只有其中一方才有的提交</li>\n</ul>\n<p>參考資料：<span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MjUxNDc3L3doYXQtYXJlLXRoZS1kaWZmZXJlbmNlcy1iZXR3ZWVuLWRvdWJsZS1kb3QtYW5kLXRyaXBsZS1kb3QtaW4tZ2l0LWRpZg==\">What are the differences between double-dot 「..」 and triple-dot 「…」 in Git diff commit ranges?<i class=\"fa fa-external-link-alt\"></i></span></p>\n<p>調整記錄的格式</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">log</span> --pretty=oneline <span class=\"comment\"># 一個commit一行</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --pretty=short <span class=\"comment\"># 簡短</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> --pretty=format:<span class=\"string\">'%h was %an, %ar, message: %s'</span></span><br><span class=\"line\"><span class=\"comment\"># %s: 提交訊息, %h: 辨識碼(hash), %an: 作者, %ar: 時間</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Git尋找提交-bisect-blame\"><a href=\"#Git尋找提交-bisect-blame\" class=\"headerlink\" title=\"Git尋找提交: bisect, blame\"></a>Git尋找提交: bisect, blame</h3><p><code>git bisect</code> 用二分搜尋法找尋有bug的提交</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git bisect start         <span class=\"comment\"># git會依照你提供的資訊改變目前的工作目錄，以方便測試</span></span><br><span class=\"line\">git bisect good [commitA] <span class=\"comment\"># 告知到此commit之前是好的</span></span><br><span class=\"line\">git bisect bad [commitB]  <span class=\"comment\"># 告知此commit仍有錯誤(通常用HEAD)</span></span><br><span class=\"line\"><span class=\"comment\"># git 會自動切換版本，若切換的版本是好的，則輸入git bisect good，反之則輸入git bisect bad</span></span><br><span class=\"line\"><span class=\"comment\"># 最後會找出第一個壞掉的提交</span></span><br><span class=\"line\">git bisect <span class=\"built_in\">log</span>           <span class=\"comment\"># 顯示之前提供的good, bad記錄</span></span><br><span class=\"line\">git bisect visualize     <span class=\"comment\"># 顯示在搜尋範圍的commit</span></span><br><span class=\"line\">git bisect reset         <span class=\"comment\"># 找到錯誤的提交後，還原至bisect前的版本</span></span><br></pre></td></tr></table></figure>\n\n<p>用檔案尋找提交</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git blame [filename] <span class=\"comment\"># 顯示檔案的每一行最後是被哪個commit修改的</span></span><br><span class=\"line\">git <span class=\"built_in\">log</span> -S [string] [filename] <span class=\"comment\"># 顯示變動包含string字串的commit</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git reflog [Reference] <span class=\"comment\"># 參照(Reference, 預設為HEAD)改變的歷史</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>checkout</code>, <code>commit</code>, <code>reset</code>, <code>rebase</code> … 都會修改HEAD</li>\n<li>可做為<code>reset</code>的參考</li>\n</ul>\n<h3 id=\"Git藏匿變更-stash\"><a href=\"#Git藏匿變更-stash\" class=\"headerlink\" title=\"Git藏匿變更: stash\"></a>Git藏匿變更: stash</h3><p><code>git stash</code>: 把目前工作目錄(working directory)的變更丟到一個stack中，之後再回來拿</p>\n<p>保持工作目錄的乾淨</p>\n<p>使用時機</p>\n<ol>\n<li>你不得不修改一個緊急bug，你可以先把目前工作目錄的變更丟到stash，這時候你的工作目錄和上次剛提交內容的狀況一樣，等到修完bug後再把stash中剛剛做到一半的東西還原以繼續</li>\n<li>今天的工作時間結束後，還有未完成的部分，可以先stash後執行測試，確認最新版本是正確的</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git stash                <span class=\"comment\"># 把目前工作區的修改丟到stash裡</span></span><br><span class=\"line\">git stash save [stashName] <span class=\"comment\"># 把目前工作區的修改丟到stash裡，並加上命名</span></span><br><span class=\"line\">git stash pop            <span class=\"comment\"># 從stash取出最新放入的一筆修改,並從stash中移除(若發生衝突時會保留)</span></span><br><span class=\"line\">git stash apply          <span class=\"comment\"># 將最新放入的一筆修改套用在工作目錄上</span></span><br><span class=\"line\">git stash drop           <span class=\"comment\"># 移除最新放入的stash</span></span><br><span class=\"line\">git stash show [stashName] <span class=\"comment\"># 列出某一筆stash的修改內容</span></span><br><span class=\"line\">                           <span class=\"comment\"># 命名：最新放入的為 stash@&#123;0&#125;, 再來是 stash@&#123;1&#125; 以此類推</span></span><br><span class=\"line\">git stash show -p [stashName] <span class=\"comment\"># 列出某一筆stash的修改統計</span></span><br><span class=\"line\">git stash list              <span class=\"comment\"># 列出所有在stash的變更</span></span><br><span class=\"line\">git stash [file]            <span class=\"comment\"># 將檔案丟進stash</span></span><br><span class=\"line\">git stash clear             <span class=\"comment\"># 清空stash</span></span><br><span class=\"line\">git stash branch [branchName] <span class=\"comment\"># 用最新放入的stash做為新的branch</span></span><br><span class=\"line\">git stash -p                <span class=\"comment\"># 挑選要暫存的變更</span></span><br><span class=\"line\">git stash --includev        <span class=\"comment\"># 同時暫存尚未在版本控制中的檔案(即從來沒被add過的檔案)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"不常用的指令\"><a href=\"#不常用的指令\" class=\"headerlink\" title=\"不常用的指令\"></a>不常用的指令</h2><h3 id=\"Git遠端容器管理-remote\"><a href=\"#Git遠端容器管理-remote\" class=\"headerlink\" title=\"Git遠端容器管理: remote\"></a>Git遠端容器管理: remote</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git remote <span class=\"comment\"># 列出預設遠端容器的名稱</span></span><br><span class=\"line\">git remote show <span class=\"comment\"># 顯示預設遠端容器的詳細資料</span></span><br><span class=\"line\">git remote add [remote-name] [remote-url] <span class=\"comment\"># 加入一個遠端容器，並命名為[remote-name]</span></span><br><span class=\"line\">git remote update <span class=\"comment\"># 更新Repository的所有branch</span></span><br><span class=\"line\">git remote rm [branch] <span class=\"comment\"># 刪除遠端分支</span></span><br><span class=\"line\"></span><br><span class=\"line\">git push --tags <span class=\"comment\"># 上傳標籤資訊(git push不會上傳標籤)</span></span><br><span class=\"line\">git push [remote] [branch] <span class=\"comment\"># 上傳分支</span></span><br><span class=\"line\">git push [remote] [branch]:[uploadbranch] <span class=\"comment\"># 上傳分支並在遠端容器中重新命名</span></span><br><span class=\"line\">git push [remote] --delete [branch] <span class=\"comment\">#  刪除遠端分支</span></span><br><span class=\"line\"></span><br><span class=\"line\">git branch --<span class=\"built_in\">set</span>-upstream [branch] [remote] <span class=\"comment\"># 連結一個本地分支和遠端分支</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Git-clean\"><a href=\"#Git-clean\" class=\"headerlink\" title=\"Git clean\"></a>Git clean</h3><p>清除不包含在版本控制中的檔案(被<code>.gitignore</code>忽略的檔案不會被清除)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git clean -n <span class=\"comment\">#  列出會被清掉的檔案</span></span><br><span class=\"line\">git clean -f <span class=\"comment\">#  執行清除</span></span><br><span class=\"line\">git clean -d <span class=\"comment\">#  清除資料夾</span></span><br><span class=\"line\">git clean -x <span class=\"comment\">#  連 .gitignore 裡列的檔案也清掉</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Git垃圾回收-gc\"><a href=\"#Git垃圾回收-gc\" class=\"headerlink\" title=\"Git垃圾回收: gc\"></a>Git垃圾回收: gc</h3><p>git儲存的記錄很多: stash, reflog, log …</p>\n<p>gc(garbage collection)：刪除所有沒有被指到(reference)且已存在一段時間的物件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 整理前和整理後的差異, 可由: git count-objects 看出</span></span><br><span class=\"line\">git count-objects</span><br><span class=\"line\">git gc</span><br><span class=\"line\">git count-objects</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ib29rcy5jb20udHcvcHJvZHVjdHMvMDAxMDU3NDA5MA==\">版本控制：使用Git<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2dpdC1zY20uY29tL2Jvb2svemgtdHcvdjE=\">Git scm<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2dvZ29qaW1teS5uZXQvMjAxMi8wMi8yOS9naXQtc2NlbmFyaW8v\">Git情境劇系列<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2Jsb2cubG9uZ3dpbi5jb20udHcvMjAwOS8wNS9naXQtbGVhcm4taW5pdGlhbC1jb21tYW5kLTIwMDkv\">Git初學筆記<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9paG93ZXIudHcvZ2l0L3JlYmFzZS5odG1s\">ihower: 還沒push前可以做的(壞)事<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc2xpZGVzaGFyZS5uZXQvb3JpZ2FtaWFkZGljdC9naXQtZ2V0LXJlYWR5LXRvLXVzZS1pdA==\">git: get ready to use it<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n",
            "tags": [
                "指令",
                "git"
            ]
        }
    ]
}