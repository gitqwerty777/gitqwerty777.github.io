{
    "version": "https://jsonfeed.org/version/1",
    "title": "QWERTY • All posts by \"轉載\" category",
    "description": "Programming | Computer Science | Thought",
    "home_page_url": "http://gitqwerty777.github.io",
    "items": [
        {
            "id": "http://gitqwerty777.github.io/CSharp-codeconvension/",
            "url": "http://gitqwerty777.github.io/CSharp-codeconvension/",
            "title": "C# 程式碼風格指南",
            "date_published": "2020-10-22T07:00:00.000Z",
            "content_html": "<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvZG90bmV0L2MjL3Byb2dyYW1taW5nLWd1aWRlL2luc2lkZS1hLXByb2dyYW0vY29kaW5nLWNvbnZlbnRpb25z\">原文：C# Coding Conventions (C# Programming Guide)<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"Naming-Conventions\"><a href=\"#Naming-Conventions\" class=\"headerlink\" title=\"Naming Conventions\"></a>Naming Conventions</h2><p>若句子太長，可以分段，結尾需為<code>.</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var currentPerformanceCounterCategory &#x3D; new System.Diagnostics.</span><br><span class=\"line\">        PerformanceCounterCategory();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Layout-Conventions\"><a href=\"#Layout-Conventions\" class=\"headerlink\" title=\"Layout Conventions\"></a>Layout Conventions</h2><ul>\n<li>四空格縮排, tabs 需要存為空格</li>\n<li>一行一個Statement/Declaration</li>\n<li>連續的行中，第二行需要多一個縮排</li>\n<li>方法的宣告和屬性的宣告中至少需要隔一行</li>\n<li>在判斷式中加上括號<ul>\n<li><code>if ((val1 &gt; val2) &amp;&amp; (val1 &gt; val3))</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Commenting-Conventions\"><a href=\"#Commenting-Conventions\" class=\"headerlink\" title=\"Commenting Conventions\"></a>Commenting Conventions</h2><ul>\n<li>將程式和註解放在不同行</li>\n<li>註解需以大寫開頭，逗號結尾，與<code>//</code>間隔一個空格<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; The following declaration creates a query. It does not run</span><br><span class=\"line\">&#x2F;&#x2F; the query.</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"Language-Guidelines\"><a href=\"#Language-Guidelines\" class=\"headerlink\" title=\"Language Guidelines\"></a>Language Guidelines</h2><ul>\n<li>使用字串插補(String interpolation)來連接短的字串<ul>\n<li><code>string displayName = $&quot;{nameList[n].LastName}, {nameList[n].FirstName}&quot;;</code></li>\n</ul>\n</li>\n<li>若要在迴圈中使用字串，使用<code>StringBuilder</code><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var phrase &#x3D; &quot;la&quot;;</span><br><span class=\"line\">var manyPhrases &#x3D; new StringBuilder();</span><br><span class=\"line\">for (var i &#x3D; 0; i &lt; 10000; i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    manyPhrases.Append(phrase);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"Implicitly-Typed-Local-Variables\"><a href=\"#Implicitly-Typed-Local-Variables\" class=\"headerlink\" title=\"Implicitly Typed Local Variables\"></a>Implicitly Typed Local Variables</h2><ul>\n<li>若變數的型別很明顯，使用隱式宣告<ul>\n<li><code>New</code>, 型別轉換, 基本型別等<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var var1 &#x3D; &quot;This is clearly a string.&quot;;</span><br><span class=\"line\">var var2 &#x3D; 27;</span><br><span class=\"line\">&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\">int var3 &#x3D; Convert.ToInt32(Console.ReadLine());</span><br><span class=\"line\">int var4 &#x3D; ExampleClass.ResultSoFar();</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>可以在for中使用隱式宣告，但不要在foreach中使用隱式宣告</li>\n</ul>\n<h2 id=\"Arrays\"><a href=\"#Arrays\" class=\"headerlink\" title=\"Arrays\"></a>Arrays</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Preferred syntax. Note that you cannot use var here instead of string[].</span><br><span class=\"line\">string[] vowels1 &#x3D; &#123; &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; &#125;;</span><br><span class=\"line\">&#x2F;&#x2F; If you use explicit instantiation, you can use var.</span><br><span class=\"line\">var vowels2 &#x3D; new string[] &#123; &quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot; &#125;;</span><br><span class=\"line\">&#x2F;&#x2F; If you specify an array size, you must initialize the elements one at a time.</span><br><span class=\"line\">var vowels3 &#x3D; new string[5];</span><br><span class=\"line\">vowels3[0] &#x3D; &quot;a&quot;;</span><br><span class=\"line\">vowels3[1] &#x3D; &quot;e&quot;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Delegates-委託\"><a href=\"#Delegates-委託\" class=\"headerlink\" title=\"Delegates(委託)\"></a>Delegates(委託)</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Define the type.</span><br><span class=\"line\">public delegate void Del(string message);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Define a method that has a matching signature.</span><br><span class=\"line\">public static void DelMethod(string str)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(&quot;DelMethod argument: &#123;0&#125;&quot;, str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; In the Main method, create an instance of Del.</span><br><span class=\"line\">&#x2F;&#x2F; Preferred: Create an instance of Del by using condensed syntax.</span><br><span class=\"line\">Del exampleDel2 &#x3D; DelMethod;</span><br><span class=\"line\">&#x2F;&#x2F; The following declaration uses the full syntax.</span><br><span class=\"line\">Del exampleDel1 &#x3D; new Del(DelMethod);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Using\"><a href=\"#Using\" class=\"headerlink\" title=\"Using\"></a>Using</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Method1: try-finally statement with Dispose</span><br><span class=\"line\">Font font1 &#x3D; new Font(&quot;Arial&quot;, 10.0f);</span><br><span class=\"line\">try</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    byte charset &#x3D; font1.GdiCharSet;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">finally</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (font1 !&#x3D; null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ((IDisposable)font1).Dispose();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Method2: Using statement.</span><br><span class=\"line\">using (Font font2 &#x3D; new Font(&quot;Arial&quot;, 10.0f))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    byte charset &#x3D; font2.GdiCharSet;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"amp-amp-and\"><a href=\"#amp-amp-and\" class=\"headerlink\" title=\"&amp;&amp; and ||\"></a>&amp;&amp; and ||</h2><ul>\n<li>用 <code>&amp;&amp;</code> 取代 <code>&amp;</code>, 用 <code>||</code> 取代 <code>|</code><ul>\n<li><code>&amp;&amp;</code> 會 short-circult (即不可能是True時直接return False)</li>\n<li><code>&amp;</code> 會判斷所有條件</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if ((divisor !&#x3D; 0) &amp;&amp; (dividend &#x2F; divisor &gt; 0))</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(&quot;Quotient: &#123;0&#125;&quot;, dividend &#x2F; divisor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">else</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Console.WriteLine(&quot;Attempted division by 0 ends up here.&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"New\"><a href=\"#New\" class=\"headerlink\" title=\"New\"></a>New</h2><ul>\n<li>使用new的時候，使用var <code>var instance1 = new ExampleClass();</code></li>\n<li>簡化Initialize<ul>\n<li><code>var instance3 = new ExampleClass { Name = &quot;Desktop&quot;, ID = 37414, Location = &quot;Redmond&quot;, Age = 2.3 };</code></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h2><ul>\n<li>使用lambda expression來產生一次性的event<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public Form2()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; You can use a lambda expression to define an event handler.</span><br><span class=\"line\">    this.Click +&#x3D; (s, e) &#x3D;&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            MessageBox.Show(</span><br><span class=\"line\">                ((MouseEventArgs)e).Location.ToString());</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Using a lambda expression shortens the following traditional definition.</span><br><span class=\"line\">public Form1()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    this.Click +&#x3D; new EventHandler(Form1_Click);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Form1_Click(object sender, EventArgs e)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    MessageBox.Show(((MouseEventArgs)e).Location.ToString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h2 id=\"Static\"><a href=\"#Static\" class=\"headerlink\" title=\"Static\"></a>Static</h2><ul>\n<li>用類別名取得static成員 <code>ClassName.StaticMember</code><ul>\n<li>不要用繼承的類別名，直接用定義static成員的類別</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"LINQ-Queries\"><a href=\"#LINQ-Queries\" class=\"headerlink\" title=\"LINQ Queries\"></a>LINQ Queries</h2><p>使用有意義的變數名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var seattleCustomers &#x3D; from customer in customers</span><br><span class=\"line\">                       where customer.City &#x3D;&#x3D; &quot;Seattle&quot;</span><br><span class=\"line\">                       select customer.Name;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>排列在<code>from</code>下方</li>\n<li>使用多個<code>from</code>取代<code>join</code><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Use a compound from to access the inner sequence within each element.</span><br><span class=\"line\">var scoreQuery &#x3D; from student in students</span><br><span class=\"line\">                 from score in student.Scores</span><br><span class=\"line\">                 where score &gt; 90</span><br><span class=\"line\">                 select new &#123; Last &#x3D; student.LastName, score &#125;;</span><br></pre></td></tr></table></figure></li>\n</ul>\n",
            "tags": [
                "C#",
                "CodingStyle"
            ]
        },
        {
            "id": "http://gitqwerty777.github.io/art-of-readme/",
            "url": "http://gitqwerty777.github.io/art-of-readme/",
            "title": "README 寫法",
            "date_published": "2020-09-06T17:11:22.000Z",
            "content_html": "<p>此篇文章大多參考自 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25vZmZsZS9hcnQtb2YtcmVhZG1lL2Jsb2IvbWFzdGVyL1JFQURNRS16aC5tZA==\">art-of-readme<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"基本的-README-組成\"><a href=\"#基本的-README-組成\" class=\"headerlink\" title=\"基本的 README 組成\"></a>基本的 README 組成</h2><p>建議順序</p>\n<ul>\n<li>一句話解釋模組的目的</li>\n<li>簡潔可運行的範例</li>\n<li>詳細的API文件</li>\n<li>安裝說明</li>\n<li>注意事項和限制</li>\n<li>授權條款(license)</li>\n<li>必要的背景資料或連結</li>\n<li>專業術語解譯</li>\n</ul>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>README 的目的：<strong>這是進行下一步之前的重要資訊</strong></p>\n<p>README 是寫給模組使用者的。</p>\n<p>README 也是寫給模組建立者的。一個沒有文件的模組，往往時隔 6 個月後，就連作者自己都會覺得陌生。每個模組的作者同時也是該模組的使用者。</p>\n<p><strong>README 是使用者首先（或唯一）審視你作品的入口。</strong></p>\n<p>編寫優秀的文件可以讓使用者不用閱讀原始碼就能理解你模組的精妙之處。<br>沒有 README 意味著開發者需要閱讀原始碼才能理解你的模組。<br>使用者希望模組能滿足他們的需要，所以你要清楚的說明你的模組的主要作用和優勢。</p>\n<blockquote>\n<p>只要你的文件是完備的，使用者就可以直接使用你的模組而無需去閱讀原始碼。透過文件可以在很大程度上將你的模組的外部介面和內部實現進行分離。這樣就可以在保持介面不變的情況下，靈活的修改內部實現。<br>定義模組的是文件而不是程式碼。 ——<span class=\"exturl\" data-url=\"aHR0cDovL21hdGhmb3J1bS5vcmcva2VuL3BlcmxfbW9kdWxlcy5odG1sI2RvY3VtZW50\">Ken Williams<i class=\"fa fa-external-link-alt\"></i></span></p>\n</blockquote>\n<h2 id=\"目標\"><a href=\"#目標\" class=\"headerlink\" title=\"目標\"></a>目標</h2><p>讓讀者了解</p>\n<ol>\n<li>這是什麼</li>\n<li>使用情境</li>\n<li>如何使用</li>\n<li>實作及相關細節</li>\n</ol>\n<h2 id=\"原則\"><a href=\"#原則\" class=\"headerlink\" title=\"原則\"></a>原則</h2><h3 id=\"簡潔\"><a href=\"#簡潔\" class=\"headerlink\" title=\"簡潔\"></a>簡潔</h3><p>理想的 README 應該儘可能的短。詳細的文件可以在單獨的頁面裡描述</p>\n<h3 id=\"快速理解\"><a href=\"#快速理解\" class=\"headerlink\" title=\"快速理解\"></a>快速理解</h3><ul>\n<li>這些關鍵要素的排序應該<strong>讓人儘快放棄你的模組</strong></li>\n<li>當你用利他主義思想來做的時候，不是為了銷售給別人，而是為了讓人們儘可能客觀公正的評估你的作品，並判斷是否滿足他們的需要。而不是讓你的下載量和使用者數最大化</li>\n</ul>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><h3 id=\"使用模版\"><a href=\"#使用模版\" class=\"headerlink\" title=\"使用模版\"></a>使用模版</h3><p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25vZmZsZS9jb21tb24tcmVhZG1l\">common-readme<i class=\"fa fa-external-link-alt\"></i></span>用的文件格式，一個README寫作指南和方便的command-line生成器。<br>你也可以在<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3JpY2hhcmRsaXR0L3N0YW5kYXJkLXJlYWRtZQ==\">標準Readme(standard readme)<i class=\"fa fa-external-link-alt\"></i></span>中領略下更具結構化的通用Readme格式。</p>\n<h3 id=\"以史為鑑\"><a href=\"#以史為鑑\" class=\"headerlink\" title=\"以史為鑑\"></a>以史為鑑</h3><p>古人云：以史為鑑，可以知興替。<br>開發者編寫文件已經有多年的歷史了。值得我們花時間去看看之前人們是怎麼正確寫文件的。</p>\n<p><del>註：就是抄別人的</del></p>\n<h3 id=\"順序：以使用者的角度分析\"><a href=\"#順序：以使用者的角度分析\" class=\"headerlink\" title=\"順序：以使用者的角度分析\"></a>順序：以使用者的角度分析</h3><p>當我想要一個 2D 碰撞檢測模組時我找到了<a href=\"https://github.com/noffle/collide-2d-aabb-aabb\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\"><code>collide-2d-aabb-aabb</code></a>。</p>\n<p>我開始從頭開始檢查這個模組：</p>\n<ol>\n<li><strong>取名</strong>：名字要能做到“其義自見”。<code>collide-2d-aabb-aabb</code> 聽起來是個不錯的匹配，儘管它假設我知道”aabb”是什麼意思。</li>\n<li><strong>簡介</strong>：透過一句話簡明扼要的說明了這個模組是做什麼的。<ol>\n<li><code>collide-2d-aabb-aabb</code> 的描述是：<blockquote>\n<p>Determines whether a moving axis-aligned bounding box (AABB) collides with other AABBs.<br>太棒了 —— 描述了 AABB 的定義是什麼，並且說明了這個模組是做什麼的。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><strong>用法</strong>：在開始探究 API 文件之前，最好看看這個模組在實際應用中是什麼樣子。我可以快速決定用js寫的範例程式是否符合我的程式碼樣式和我要解決的問題。</li>\n<li><strong>API</strong>：模組的名字，描述和使用方法都符合我的胃口。在這一點上我很樂意使用這個模組。我需要瀏覽API來確定這就是我需要的，並且很容易整合到我的程式碼中。API 部分應該詳述模組的物件和函式，以及它們的定義、回傳值和事件。</li>\n<li><strong>安裝</strong>：如果不是通用的安裝說明，就需要在這兒進行描述。即使是一句簡單的<code>npm install</code>也好。 對於使用Node的新使用者來說，放一個指向npmjs.org的連結和安裝命令，可以讓使用者快速上手使用模組。</li>\n<li><strong>授權</strong>：大多數模組把這個放在最末尾，但是最好還是往前放一些；非常有可能在把這個模組整合完後才發現授權協議不合適。我通常使用 MIT/BSD/X11/ISC。如果你的協議不是很寬容，最好是放到最前面。</li>\n</ol>\n<h3 id=\"順序：認知漏斗\"><a href=\"#順序：認知漏斗\" class=\"headerlink\" title=\"順序：認知漏斗\"></a>順序：認知漏斗</h3><p>可以想象成是一個直立的漏斗，越往下移動細節越具體，最寬的部分相關細節最寬泛，只有對你的作品足夠感興趣的人才會關注這部分內容。最後，底部可以放一些作品背景的細節</p>\n<blockquote>\n<p>Perl模組的文件對於細節的描述是從少到多的。<br>你的簡介部分應該包含一個小的例子程式<br>（或許只有一行程式碼，省略掉不常用的用例或大多數使用者用不到的功能）<br>描述部分應該從總體上描述你的模組，<br>通常只需要幾個段落；在隨後的章節中再詳細描述模組的例程或方法，長的程式碼示例，或其它的資料。<br>理想情況下，在點“下一頁”之前就能讓人大體上了解你的模組。<br>隨著使用者繼續閱讀文件，他們能夠漸進的獲得更多的知識。<br> —— <code>perlmodstyle</code></p>\n</blockquote>\n<h2 id=\"實作\"><a href=\"#實作\" class=\"headerlink\" title=\"實作\"></a>實作</h2><p><mark>API改的越多，越要努力的去更新文件</mark></p>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>如果你的模組依賴於重要但是不為人所熟知的抽象或生態系統，考慮包含一個 <strong>背景知識</strong> 部分 (background)。</p>\n<p><a href=\"https://github.com/noffle/bisecting-between\" target=\"_blank\" rel=\"noopener external nofollow noreferrer\"><code>bisecting-between</code></a>的函式從它的名字上看不是特別明顯，所以在背景部分會描述定義，並且給出具體概念和抽象的連結，以便需要的人去使用和獲取。如果已經有相似的模組在npm上存在了，這兒也是一個非常適合描述建立模組的動機的地方</p>\n<h3 id=\"連結\"><a href=\"#連結\" class=\"headerlink\" title=\"連結\"></a>連結</h3><p>如果你談及其它的模組，想法，或者其他人的時候，在相關的引用內容上加上連結，這樣訪客就可以很容易的得到你的模組背後的想法。極少有模組是憑空誕生的：所有的作品來源於其它作品，因此很有必要讓使用者追溯你的模組的歷史和靈感</p>\n<h3 id=\"範例檔案\"><a href=\"#範例檔案\" class=\"headerlink\" title=\"範例檔案\"></a>範例檔案</h3><p>範例程式碼在repo中以檔案的形式體現 – 例如<code>example.js</code>。這樣當用戶clone專案後，就可以直接執行README中提及的程式碼</p>\n<h3 id=\"徽章-badge\"><a href=\"#徽章-badge\" class=\"headerlink\" title=\"徽章(badge)\"></a>徽章(badge)</h3><p>使用徽章要慎重。經常會被濫用。它們會容易引起爭論。它們在你的README中加入了視覺噪聲，並且只有當用戶在聯網的瀏覽器裡閱讀你的markdown時才能看到徽章，因為圖片是存放在網際網路上的其它地方。對於每一個徽章，需要考慮：README中的徽章提供給典型讀者的真實含義是什麼？用一個CI徽章來顯示build/test狀態？這個訊號更應該發郵件給維護者，或者自動建立一個issue – 永遠要考慮你的README中的資料的受眾並且自問一下是否有一個流程能夠讓資料更好的送達到目標受眾。</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><p>API 文件格式沒有局限。使用任何你認為是清晰的格式，但是要包含重要的細節：</p>\n<ol>\n<li>引數是否可選，以及預設值</li>\n<li>包含型別資訊，如果型別不能清楚的根據約定進行體現</li>\n<li>對於 <code>opts</code> 物件引數，描述它所接受的所有的 keys 和 values</li>\n<li>為每個API提供一個小的呼叫示例，如果它們的用法不明顯或是在用法部分沒有體現。<ol>\n<li>不過，也有可能是函式太複雜了，需要進行重構，劃分成更細粒度的函式，或者整體刪除。</li>\n</ol>\n</li>\n<li>為特殊術語建立連結! 在markdown中你可以把<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kYXJpbmdmaXJlYmFsbC5uZXQvcHJvamVjdHMvbWFya2Rvd24vc3ludGF4I2xpbms=\">腳註<i class=\"fa fa-external-link-alt\"></i></span> 放在文件的末尾，可以很方便的多次引用它們。</li>\n</ol>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL25vZmZsZS9jb21tb24tcmVhZG1lL2Jsb2IvbWFzdGVyL2FwaV9mb3JtYXR0aW5nLm1k\">這兒<i class=\"fa fa-external-link-alt\"></i></span>有一些我的API文件格式的個人偏好。</p>\n<ul>\n<li>放一些呼叫和返回值的範例<ul>\n<li>如果你的模組提供了 CLI (command line interface)而不是 API，用命令呼叫的方式展示呼叫示例和輸出。如果你建立了或更改了一個檔案，<code>cat</code> 它來展示更改前後的變化。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"關鍵字\"><a href=\"#關鍵字\" class=\"headerlink\" title=\"關鍵字\"></a>關鍵字</h3><p>github 和 npm 皆有提供手動填寫關鍵字(tag)</p>\n<h3 id=\"內嵌圖片\"><a href=\"#內嵌圖片\" class=\"headerlink\" title=\"內嵌圖片\"></a>內嵌圖片</h3><p>最後，請記住你的程式碼倉庫和其中的README存在的時間要比你的<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29t\">程式碼倉庫託管主機<i class=\"fa fa-external-link-alt\"></i></span>和你連結到的其它任何東西–特別是圖片–的時間都要長久。所以<strong>內嵌任何對將來要獲取你的作品的使用者來說是重要的東西</strong>。</p>\n<p>註：還是可以上傳到圖床或Youtube等，但是要將這些圖片、影片等額外的資源也放在版本控制中</p>\n<h2 id=\"心得\"><a href=\"#心得\" class=\"headerlink\" title=\"心得\"></a>心得</h2><p>我個人使用Repo的順序</p>\n<ol>\n<li>觀察<ol>\n<li>會看主要使用的程式語言、支援的OS</li>\n<li>Description: 一句話形容Repo的作用</li>\n<li>指令、圖片、影片或是線上的使用範例</li>\n</ol>\n</li>\n<li>決定試用<ol>\n<li>安裝方法、或是Release可直接下載</li>\n<li>實際使用<ol>\n<li>使用失敗：回去看Document或README</li>\n</ol>\n</li>\n<li>覺得好用：Star</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"實例評價\"><a href=\"#實例評價\" class=\"headerlink\" title=\"實例評價\"></a>實例評價</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0dhbGl0eTM2OS9DUy1Mb2FkZXI=\">CS-Loader<i class=\"fa fa-external-link-alt\"></i></span><ul>\n<li>About欄位：CS免殺<ul>\n<li>Google後才知道是繞過掃毒軟體的方法</li>\n</ul>\n</li>\n<li>❌沒有對專有名詞的說明</li>\n<li>❌沒有使用方法</li>\n<li>只看README的話我是完全不會用的</li>\n</ul>\n</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL251bXRpZGUvZGV2c2hlbGw=\">devshell<i class=\"fa fa-external-link-alt\"></i></span><ul>\n<li>副標題: ⭕like virtualenv, but for all the languages<ul>\n<li>有用過Python的virtualenv的人可以馬上理解</li>\n</ul>\n</li>\n<li>About欄位: ➖Per project developer environments</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9udW10aWRlLmdpdGh1Yi5pby9kZXZzaGVsbC9pbnRyby5odG1s\">文件<i class=\"fa fa-external-link-alt\"></i></span>: ❌沒有簡短的設定教學<!-- - TODO: --></li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "readme",
                "文件",
                "github"
            ]
        },
        {
            "id": "http://gitqwerty777.github.io/zen-of-python/",
            "url": "http://gitqwerty777.github.io/zen-of-python/",
            "title": "Python 之禪",
            "date_published": "2020-08-17T16:45:00.000Z",
            "content_html": "<h2 id=\"import-this\"><a href=\"#import-this\" class=\"headerlink\" title=\"import this\"></a>import this</h2><blockquote>\n<p>The Zen of Python, by Tim Peters</p>\n</blockquote>\n<blockquote>\n<p>Beautiful is better than ugly.<br>Explicit is better than implicit.<br>Simple is better than complex.<br>Complex is better than complicated.<br>Flat is better than nested.<br>Sparse is better than dense.<br>Readability counts.<br>Special cases aren’t special enough to break the rules.<br>Although practicality beats purity.<br>Errors should never pass silently.<br>Unless explicitly silenced.<br>In the face of ambiguity, refuse the temptation to guess.<br>There should be one– and preferably only one –obvious way to do it.<br>Although that way may not be obvious at first unless you’re Dutch.<br>Now is better than never.<br>Although never is often better than <em>right</em> now.<br>If the implementation is hard to explain, it’s a bad idea.<br>If the implementation is easy to explain, it may be a good idea.<br>Namespaces are one honking great idea – let’s do more of those!</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h2 id=\"翻譯和解釋\"><a href=\"#翻譯和解釋\" class=\"headerlink\" title=\"翻譯和解釋\"></a>翻譯和解釋</h2><p>基本上在解釋 clean code 的做法</p>\n<p>優美優於醜陋，</p>\n<p>明瞭優於隱晦；</p>\n<p>簡單優於複雜，</p>\n<p>複雜優於凌亂，</p>\n<blockquote>\n<p>如果復雜不可避免，那代碼間也不能有難懂的關係，要保持接口簡潔</p>\n</blockquote>\n<p>扁平優於嵌套，</p>\n<p>稀疏優於稠密，</p>\n<p>可讀性很重要！</p>\n<p>即使實用比純粹更優，</p>\n<p>特例亦不可違背原則。</p>\n<p>錯誤絕不能悄悄忽略，</p>\n<p>除非它明確需要如此。</p>\n<p>面對不確定性，</p>\n<p>拒絕妄加猜測。</p>\n<p>任何問題應有一種，</p>\n<p>且最好只有一種，</p>\n<p>顯而易見的解決方法。</p>\n<p>儘管這方法一開始並非如此直觀，</p>\n<p>除非你是荷蘭人。</p>\n<blockquote>\n<p>解決一個問題的方法可能會有很多種，但在Python中，只選擇最明顯的那一個</p>\n</blockquote>\n<p>做優於不做，</p>\n<p>然而不假思索還不如不做。</p>\n<p>很難解釋的，必然是壞方法。</p>\n<p>很好解釋的，可能是好方法。</p>\n<p>命名空間是個絕妙的主意，</p>\n<p>我們應好好利用它。</p>\n<h2 id=\"reference\"><a href=\"#reference\" class=\"headerlink\" title=\"reference\"></a>reference</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cud2lraXdhbmQuY29tL3poLXR3L1B5dGhvbiVFNCVCOSU4QiVFNyVBNiU4NQ==\">wiki<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucHl0aG9uLm9yZy9kZXYvcGVwcy9wZXAtMDAyMC8=\">PEP-20<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "http://gitqwerty777.github.io/competitive-strategy/",
            "url": "http://gitqwerty777.github.io/competitive-strategy/",
            "title": "競爭策略",
            "date_published": "2015-08-31T07:38:00.000Z",
            "content_html": "<!-- RENEW: -->\n\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY291cnNlcmEub3JnL2xlYXJuL2NvbXBldGl0aXZlc3RyYXRlZ3l6aC9ob21lL3dlbGNvbWU=\">原課程網址 – 競爭策略<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY291cnNlcmEub3JnL2xlYXJuL2FkdmFuY2VkLWNvbXBldGl0aXZlLXN0cmF0ZWd5LXpoL2hvbWUvd2VsY29tZQ==\">原課程網址 – 高階競爭策略<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li>原作者標題 - Competitive Strategy競爭策略——課程要點彙編 (By Daniel.Tao)<ul>\n<li>鏈結已失效</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"競爭策略\"><a href=\"#競爭策略\" class=\"headerlink\" title=\"競爭策略\"></a>競爭策略</h1><p>同時決策:主要是指一方在對另一方改採取的行動不知情的情況下做出決定</p>\n<ul>\n<li>最佳策略(Optimal Strategy): 最優策略常常使我們自己的收益最大化</li>\n<li>劣勢策略(Dominated Strategy): 是一個始終比其他情況都糟糕的策略，你永遠可以找到另一個比它更佳的策略</li>\n<li>優勢策略(Dominant Stratedy): 指無論其他企業或參與者選擇什麼策略，該策略都將勝於其他策略</li>\n<li>納什均衡(Nash Equilibrium): 納什均衡是一組<strong>策略集</strong>其中沒有任何一方可以單方面地悖離自身的策略<ul>\n<li>一旦我們發現一個納什均衡 我們就找到了博弈中的一個自然靜止點，堅持自身策略的情況下 沒有博弈者想改變自己的選擇</li>\n<li>在納什均衡裡，沒有博弈參與者能通過採取其它策略獲得更高收益，我們能夠預測兩個理性的對手會選擇，最終能使自己達到納什均衡的策略</li>\n<li>優勢策略針對的是單人博弈，而納什均衡 就像我們從其定義所看到的那樣是策略的合集 是對於博弈中每一個參與者的策略</li>\n<li>每一個博弈在純策略 (Pure Strategy, 只能選一個策略) 中都會有納什均衡嗎<ul>\n<li>不一定。例如足球射門，這個博弈沒有自然靜止點</li>\n<li>企業選擇標準的時候，就可能存在兩個納什均衡狀態。例如 A選A，B最好選A， B選擇B，A最好也選擇B</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>囚徒困境<ul>\n<li>存在著一個能使雙方都得到更大效益的情況，但就個體而言每一方都不想一直維持在這種局面</li>\n<li>因為是同時決策，所以他們不能弄清楚對手的決策。這種困境來源於雙方行為上的利己性，因為他們都想使自己的利潤得到最大化</li>\n</ul>\n</li>\n</ul>\n<p>序列博弈 (Sequential Game, Dynamic Game)</p>\n<ul>\n<li>序列博弈就是在博弈中加入時間因素，一家企業在另一家之前行動，第二家企業能夠在知道第一家企業行動的情況下進行博弈，那麼就能相應地調整自己的行動；另一方面 第一家企業必須在沒有後者信息的情況下，不知道第二個博弈者會做什麼，但是，第一家企業知道在自己之後會有一個跟隨者 並且這個跟隨者會理性地作出反應</li>\n<li>畫出博弈樹 (Game Tree)</li>\n<li>逆向歸納法 (Backward Induction)<ul>\n<li>倒推法：忽略掉所有不可能發生的方案，比如劣勢策略。據此選擇最高利益的策略</li>\n</ul>\n</li>\n<li>最先作出決定的參與者是否擁有某種策略優勢<ul>\n<li>可信的威脅<ul>\n<li>以一個特定的方式做出承諾，可以改變博弈中的策略，可以避免參與他們不想要的博弈，提升自己的回報</li>\n<li>英航進入漢莎壟斷的德國航空市場，漢莎承諾如果英航進入會展開價格戰<ul>\n<li>可能需要透過增加投資、向第三方承諾等方法，才能成功，否則會被視為不可信威脅(因為價格戰可能不是最佳決策)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>子博弈 (Sub-game)<ul>\n<li>企業在面對囚徒困境或者一個協調博弈時 如果他們能合作 或者能協調他們的行動那他們就能獲得更好的收益</li>\n<li>理論上這看起來很簡單，但它實際上很難維持 因為企業是自私、獨立並尋求利益最大化的</li>\n<li>如果博弈能重複進行或者博弈者能採用特定的策略 這樣就能幫助實現合作</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>重複博弈<ul>\n<li>重複博弈基本上就是在兩個或者多個博弈者之間能夠重複出現多次的互動</li>\n<li>有限次重複<ul>\n<li>也就是在一開始就清楚博弈會以怎樣的頻率重複 也知道博弈會在什麼時候結束我們清楚知道博弈的結果或者結束點</li>\n<li>如承包商和企業的驗收</li>\n<li>結局效應 (Endgame Effect)<ul>\n<li>進行非常長時間的博弈 越接近這個博弈的結尾，合作就越有可能會直接崩潰。可採用逆向歸納進行推演</li>\n<li>理論上會和同時決策的結果相同<ul>\n<li>我知道最後一次決策絕對不會合作 → 最後第二次不要合作，以此類推</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>無限次重複<ul>\n<li>沒有明確的結束點</li>\n<li>企業/同事間的合作</li>\n<li>較有可能合作(不合作可以明確的報復)</li>\n</ul>\n</li>\n<li>觸發策略<ul>\n<li>每家企業都將先開出壟斷價格 一旦其中一方，在某一年開出低價 另一方則將在未來持續開出低價 所以一旦有人違反規則，以後將再也不會有合作可言</li>\n</ul>\n</li>\n<li>影響博弈繼續的因素<ul>\n<li>p是博弈繼續的概率，愈高愈可能合作</li>\n<li>競爭者的數量，數量越多，分到的利潤越少，減少了合作的可能性</li>\n<li>利率，利率越高，合作可能性越小，利率越低合作可能性越高</li>\n<li>較輕的懲罰 或者寬容的懲罰，也會給合作增添更多阻力</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>積極承諾 (Aggressive Commitment)<ul>\n<li>積極承諾試圖減少那些可能引發劣性均衡的行為，也就是說 當你做出積極承諾 其實是減少了你的選擇而不是將其增多，在博弈論中這通常意味著，將一個同時博弈 (Simultaneous Game)轉變為一個序貫博弈 (Sequential Game) 。如：波音和空客考慮生產大型客機額博弈，空客在新飛機還沒有研發出來前，已經在位於漢堡和圖盧茲的中心建立了加工廠，加工廠只能用於生產A380</li>\n<li>產生子博弈精煉納什均衡 (Subgame Perfect Nash Equilibrium)<ul>\n<li>組成精煉納什均衡的策略在每一個子博弈中都是最優的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>合作承諾 (Cooperative Commitment)也叫軟承諾 (Soft Commitment)<ul>\n<li>建立口碑，成為一個可靠的競爭者或合作者。表明兩點：1.首先 你的競爭對手將更容易預測你的行為；2. 如果你建立了口碑，如果你不跟別人好好合作，代價就會特別大，因為你很容易就會失去口碑</li>\n<li>客戶最愛條款。你承諾如果該商品降價，顧客將可以申請賠償差價，通常來說客戶最愛條款都有個期限 通常是六個月或一年。一方面，客戶不用等價格下跌，如到半年後價格下的，它可以得到補償。另一方面，你也對競爭者發出了信號，那就是對你來說，競爭某些顧客的代價會變高，因為降低價格不僅僅意味著 降低未來利潤，你還要給之前的顧客補償差價</li>\n</ul>\n</li>\n<li>積極承諾與軟承諾區別<ul>\n<li>積極承諾在於先發制人 消除可能引發劣性均衡的行為</li>\n<li>合作承諾則是告訴其他博弈者,你是個好人</li>\n</ul>\n</li>\n<li>自我束縛承諾(self-binding commitment): 投入資源，讓潛在合作者相信會合作</li>\n</ul>\n<p>互補品(Complements)    </p>\n<ul>\n<li>使用產品B能提高產品A的使用效能，反之亦然</li>\n<li>同時使用A和B兩個產品的效用，更高於單獨使用產品A加上單獨使用產品B的效用<ul>\n<li>效用就是當你使用一個特定產品時所得到的滿足程度</li>\n</ul>\n</li>\n<li>負交叉價格彈性<ul>\n<li>降低產品A的價格，使產品B的需求量提升</li>\n</ul>\n</li>\n</ul>\n<p>替代品 (Substitute Good)  </p>\n<ul>\n<li>替代品的降價可能會減少市場份額，但是，同時也能增加市場規模 因此將有積極的最終結果和淨效應</li>\n<li>替代品所扮演的角色就是當市場上存在許多相似的替代品，它將會提高價格彈性，也就是消費者的價格敏感度，就就意味著當你試圖增加你的利潤時，消費者則將會另選其他產品</li>\n<li>正交叉價格彈性<ul>\n<li>降低產品A的價格，使產品B的需求量下降</li>\n</ul>\n</li>\n</ul>\n<p>交叉價格彈性為正: 商品A的價格上漲，將導致商品B的需求量上升，兩件商品互為替代品<br>交叉價格彈性為負: 商品A的價格上漲，將導致商品B的需求量下降，兩件商品互為互補品</p>\n<p>企業為什麼會支持互補方   </p>\n<ul>\n<li>為什麼你會想要支持一家因為你不在其中而無法直接獲利的企業，或許能通過使供給方提供質量更好的互補品，從而提高銷售量，互補品越好。對你自身產品的需求也越高，互補品賣得越多，對你自身產品的需求也越高，基礎品變得更有用了<ul>\n<li>蘋果免費送給編寫mac程序的學生</li>\n</ul>\n</li>\n<li>自己生產互補品<ul>\n<li>問題    <ol>\n<li>可能僅僅是互補品市場不具有吸引力</li>\n<li>沒有足夠的能力生產互補品</li>\n<li>潛在消費者無法接受一個企業既生產基礎產品又生產互補品</li>\n</ol>\n</li>\n<li>優勢<ol>\n<li>可以為自己的產品量身定製互補品</li>\n<li>可以對互補品進行質量監管</li>\n<li>可賺更多錢</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>交叉補貼 (Cross Subsidy) <ul>\n<li>為了增加利潤很高的產品B的銷售，生產利潤很小，甚至虧本的產品A<ul>\n<li>剃鬚刀與刀片，打印機與墨盒</li>\n</ul>\n</li>\n<li>風險<ol>\n<li>消費者最終可能不會購買產品B，可能只會對基礎產品感興趣而並不對互補品感興趣，你只獲得了產品A的低價所帶來的利潤</li>\n<li>消費者可能從另一個製造商那裡買產品B</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>捆綁銷售 (Bundle)      <ul>\n<li>企業只出售的產品A和互補品B的組合<ol>\n<li>在市場A中你面臨的競爭非常小，甚至是沒有因為你除了產品A外，還附加了其他產品</li>\n<li>減少了B市場的競爭，因為只要有人對互補品B感興趣，他也會得到產品A</li>\n</ol>\n</li>\n<li>風險<ol>\n<li>可能有只對A或B感興趣的消費者，只對基礎產品或互補品感興趣，對他們進行捆綁銷售 你將失去這些消費者</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>轉換成本 (Switching Costs)    <ul>\n<li>當用戶從產品A轉換到一個替代品時，通常會產生轉換成本，轉換成本越高，就意味著他們已購買的互補品就越多。如果你使某人買了很多互補品，那他就很難從基礎產品A轉換到任何其它產品</li>\n<li>好處<ol>\n<li>你使某人買了很多互補品，那他就很難從基礎產品A轉換到任何其它產品</li>\n<li>這意味著顧客對企業有著更高的價值，如果一個消費者發現很難能夠轉而使用其它產品，你就可以向他收取更高價格</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<p>可能同時是競爭對手，也是合作關係   </p>\n<ul>\n<li>Apple &amp; Sony<ul>\n<li>Apple ipod 和 Sony mp3</li>\n<li>Apple itunes 賣出 Sony音樂</li>\n</ul>\n</li>\n</ul>\n<p>戰略合作夥伴關係 (Strategic Partnership)     </p>\n<ul>\n<li>是企業之間的長期合作關係</li>\n<li>戰略合作夥伴一個重要特點：他們是互補產品的生產者，但他們不能合併為一個公司<ol>\n<li>分享決策/共同決策 (Shared Decision Making)</li>\n<li>建立某種組織或某種機制（組織整合，organisational integration）——跨企業團隊，建立跨企業的匯報、決策規則、進行大量信息交換），依賴信息交流以及信息交流的程序化過程</li>\n<li>交叉持股或建新的合資企業（經濟整合 economic integration)</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>互補品廠商有很高的動機互相合作並獲益，並不一定需要經濟整合才會合作</p>\n</blockquote>\n<h2 id=\"進入市場\"><a href=\"#進入市場\" class=\"headerlink\" title=\"進入市場\"></a>進入市場</h2><p>市場吸引力 → 選擇市場 → 進入方式 → 策略</p>\n<h3 id=\"市場吸引力\"><a href=\"#市場吸引力\" class=\"headerlink\" title=\"市場吸引力\"></a>市場吸引力</h3><ol>\n<li>由波特五力決定<ol>\n<li>競爭程度</li>\n<li>對供應商的議價能力</li>\n<li>對買家的議價能力</li>\n<li>潛在新廠商的威脅</li>\n<li>替代品的威脅</li>\n</ol>\n</li>\n<li>政府角色（政府的監管和徵稅）</li>\n</ol>\n<h3 id=\"選擇市場\"><a href=\"#選擇市場\" class=\"headerlink\" title=\"選擇市場\"></a>選擇市場</h3><p>進入壁壘 (Entry Barrier)<br>進入壁壘是一些因素，能使現有企業獲得正利潤，而該行業新入者卻無法獲利  </p>\n<ul>\n<li>結構性進入壁壘<ul>\n<li>與行業內現有企業的定位相關</li>\n<li>超市位置、政府許可（申請牌照）、生產規模(半導體)、關鍵專利、經驗積累、成本優勢、專屬供應合約等</li>\n</ul>\n</li>\n<li>戰略性進入壁壘<ul>\n<li>由現有企業有意識採取的特別戰略行為，阻止行業內後來者進入的意向</li>\n</ul>\n</li>\n<li>營銷優勢<ul>\n<li>品牌忠誠度，轉換成本</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"進入方式\"><a href=\"#進入方式\" class=\"headerlink\" title=\"進入方式\"></a>進入方式</h3><p>承諾戰略       </p>\n<ul>\n<li>承諾戰略是某個後來者為了表明要留在市場中作出的可信承諾，以此來防止現有企業的報復</li>\n<li>付出高沉沒成本(退出成本高)<ul>\n<li>投資</li>\n<li>研發</li>\n<li>廣告</li>\n</ul>\n</li>\n<li>也可用於遏制策略</li>\n</ul>\n<p>價值鏈重構    </p>\n<ul>\n<li>提供一種更便宜的產品<ul>\n<li>吸引的是對價格更敏感的買家，而不是購買現有企業產品的買家，所以主流顧客群不會被這個新產品吸引，因為它相對劣質</li>\n<li>對於現有企業來說，這個舉動不太算威脅</li>\n</ul>\n</li>\n<li>隨著時間的推移，這個創新者帶著價格便宜的產品進入市場後，會改良產品，並從現有企業那裡佔去大量的市場份額，而現有企業，會感到應對困難，因為他們不能複製這個廉價商業模式</li>\n</ul>\n<p>柔道經濟策略  </p>\n<ul>\n<li>將對手的力量轉變為自己的優勢</li>\n<li>低價進入市場 → 迫使現在企業損失 </li>\n<li>Ph = 原價格, Pl = 新廠商價格, X = 原廠商規模, XE = 新廠商規模<ul>\n<li>同意進入的代價： Ph XE, 以降價遏制的代價： (Ph - Pl) X</li>\n<li>對新入者有利的因素：市場規模↑, 新入者市場規模↑, 價格差距↑<ul>\n<li>對手愈大，愈不可能攻擊</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>利基市場（細分市場）  </p>\n<ul>\n<li>後來者只在利基市場開拓業務，使現有企業不能在其市場外進行反擊</li>\n<li>在原廠商可以差別取價時會失敗(電信公司不行限定某城市降價，但航班可分航線計價)</li>\n</ul>\n<h3 id=\"遏制策略\"><a href=\"#遏制策略\" class=\"headerlink\" title=\"遏制策略\"></a>遏制策略</h3><p>進入遏制策略   </p>\n<ul>\n<li>改變後來者對於與現有企業競爭性質的預期</li>\n<li>對於後來者，這些可以使得進入市場變得更難，吸引力變小</li>\n<li>需付出一定的代價</li>\n<li>遏制策略的種類：提高進入壁壘、掌握關鍵資源、提高技術領先性、提高轉換成本、承諾戰略</li>\n</ul>\n<ul>\n<li>提高進入壁壘<ul>\n<li>如提高技術領先性</li>\n</ul>\n</li>\n<li>承諾策略<ul>\n<li>承諾會打價格戰</li>\n</ul>\n</li>\n<li>積極定價策略<ul>\n<li>限制性定價<ul>\n<li>在他人<strong>進入市場前</strong>即維持低價</li>\n<li>告訴潛在競爭者，「這是個低利潤市場」的假象，或是「我是低成本廠商(競爭強)」</li>\n<li>只在信息不完全時發揮作用(不可能維持低價太久)</li>\n</ul>\n</li>\n<li>掠奪定價<ul>\n<li>對手<strong>進入市場後</strong>，逼退後來者</li>\n<li>在競爭中削減價格，甚至使定價低於邊際成本，目的仍是誘使競爭對手退出市場，或遏制將來的進入</li>\n</ul>\n</li>\n<li>先佔策略<ul>\n<li>通過代價高昂的行為，你可以阻止潛在競爭者進入市場<ul>\n<li>過度投資，使生產成本非常低</li>\n<li>大量生產小差異產品(水平差異)，使潛在市場變小</li>\n<li>過度展店，增加競爭強度</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"研究與創新\"><a href=\"#研究與創新\" class=\"headerlink\" title=\"研究與創新\"></a>研究與創新</h2><p>三種研究  </p>\n<ul>\n<li><p>基礎研究(basic research)</p>\n<ul>\n<li>知識外溢 (Knowledge Spillover): 因為無法申請專利</li>\n<li>導致了一個囚徒困境：但即使一個企業進行投資也可以獲益。基本研究主要由大學、公共實驗室以及企業網路進行，以此避免或解決囚徒困境的問題</li>\n</ul>\n</li>\n<li><p>應用研究(applied research)</p>\n<ul>\n<li>可申請專利的研究</li>\n</ul>\n</li>\n<li><p>產品生產(product development)</p>\n</li>\n<li><p>產品創新 (Product Innovation)</p>\n<ul>\n<li>對現有產品 (Existing Product) 的改進，或是開發一項全新的產品，增加產品價值以提高用戶的支付意願</li>\n</ul>\n</li>\n<li><p>過程創新 (Process Innovation)</p>\n<ul>\n<li>為現有產品開發新生產過程，以減少生產成本</li>\n</ul>\n</li>\n<li><p>突破性創新 (Drastic Innovation)</p>\n<ul>\n<li>突破性創新是指當企業創造了突破性的新產品時，可對市場進行壟斷。對於突破式創新，我們可以預見到市場情況，及結構都會完全改變</li>\n</ul>\n</li>\n<li><p>漸進式創新 (Incremental Innovation)</p>\n<ul>\n<li>輕微改變</li>\n</ul>\n</li>\n</ul>\n<p>企業創新的價值 = 創新時的利潤 - 無創新時的利潤  </p>\n<ul>\n<li>替代效應 (Replacement Effect)<ul>\n<li>替代效應表明對於給定的市場結構，<strong>壟斷企業的創新動機相對較小</strong>，我們發在競爭市場中的創新價值，實際上要比壟斷市場中的創新價值更大</li>\n</ul>\n</li>\n<li>效率效應 (Efficiency Effect)<ul>\n<li>效率效應是指<strong>存在進入威脅時</strong>，壟斷企業相比潛在進入企業，有更大的創新動力來阻撓競爭者進入市場</li>\n</ul>\n</li>\n<li>替代效應表明壟斷企業創新性不夠，因為新利潤會取代原有的利潤；效率效應表明壟斷企業有更大的創新性，因為它致力於保持自己的壟斷地位</li>\n<li>威脅大的時候，效率效應&gt;替代效應，反之</li>\n</ul>\n<p>研發失敗，或被他人搶先  </p>\n<ul>\n<li>成功機率愈低，納許均衡偏向不研發</li>\n<li>成功機率中等，納許均衡為其中一家研發</li>\n<li>成功機率高，納許均衡偏向研發<ul>\n<li>後果可能是，損失此次創新帶來的部分利潤</li>\n</ul>\n</li>\n<li>風險中立 (Risk Neutral)  <ul>\n<li>只關心預期利潤 (Expected Profit)</li>\n</ul>\n</li>\n</ul>\n<p>不同成功率與研發之間的關係    </p>\n<ol>\n<li>一個成功率低，又有著高固定成本的項目，企業可能根本不會選擇開展</li>\n<li>一個成功率中等的項目則會由率先選擇研發的企業進行，且該企業會試圖阻擾其他企業進入市場，當兩家企業在一個成功率中等的領域中處於競爭局勢時，我們可能看到兩家企業都將遭受損失</li>\n</ol>\n<p>沉睡專利 (Sleeping Patent)   </p>\n<ul>\n<li>企業申請與主要產品相近的創新成果的專利，但並不商業化的專利</li>\n<li>先發制人，阻止潛在競爭者研發出與自身產品相似的競爭產品，減少競爭並保證現有產品的利潤</li>\n<li>阻礙技術進步</li>\n</ul>\n<h2 id=\"合理設計產品\"><a href=\"#合理設計產品\" class=\"headerlink\" title=\"合理設計產品\"></a>合理設計產品</h2><p>伯特蘭德悖論 (Bertrand Paradox)的假設      </p>\n<ol>\n<li>同樣產品</li>\n<li>同樣地點</li>\n<li>一次定價機會(只博弈一次)</li>\n<li>市場完全透明</li>\n<li>無限價格彈性 (Infinite Price Elasticity)：無論價格差多少，價格低的小販總會贏得消費者</li>\n<li>不存在產能限制</li>\n</ol>\n<p>兩家銷售相同產品的企業 最終會處於完全競爭的勢態，並且獲益為零</p>\n<h3 id=\"去除假設\"><a href=\"#去除假設\" class=\"headerlink\" title=\"去除假設\"></a>去除假設</h3><p>事實上的競爭不會如此激烈<br>一次定價、完全透明、不存在產能限制 → 不可能  </p>\n<p>不同產品  </p>\n<ul>\n<li>垂直產品差異化 (Vertical Product Differentiation)<ul>\n<li>相同價格下 所有消費者都會選擇產品A，而不選產品B</li>\n<li>品質、技術、耐用度、價值</li>\n</ul>\n</li>\n<li>水平產品差異化 (Horizontal Product Differentiation)<ul>\n<li>相同價格下 有些消費者會選擇產品A，有些則會選擇產品B</li>\n<li>品牌、品味、地點、時間</li>\n</ul>\n</li>\n<li>多數產品同時有兩種差異化</li>\n</ul>\n<p>霍特林‧伯特蘭德模型 (Hotelling Bertrand Model)<br>海灘上小販A、B賣冰淇淋的水平差異化思考  </p>\n<ol>\n<li>兩個賣家間的距離則是產品的差異化程度</li>\n<li>一個特定消費者的位置可解釋為消費者對產品的偏好</li>\n<li>走路引發的不適感是損失效用</li>\n</ol>\n<h3 id=\"基本競爭戰略\"><a href=\"#基本競爭戰略\" class=\"headerlink\" title=\"基本競爭戰略\"></a>基本競爭戰略</h3><ol>\n<li>成本領先 (Cost Leadership)<ol>\n<li>忽略那些無法讓你賺錢的消費者群體或利潤空間很小的消費者群體</li>\n<li>需要避免邊際消費者,使管理領域的成本最小化</li>\n<li>減少研發、客服、銷售人員以及廣告等方面的開支</li>\n<li>可使用侵略性定價</li>\n</ol>\n</li>\n<li>產品差異化 (Product Differentiation)<ol>\n<li>向消費者提供產業中的獨特產品或服務</li>\n<li>擁有高價值的品牌</li>\n<li>提供頂尖技術或優質的客戶服務</li>\n<li>擁有廣泛分佈 或有效的經銷商網路</li>\n</ol>\n</li>\n<li>集中化戰略 (Focus)<ol>\n<li>結合前兩個策略，並集中在一個特定的消費者群體、產品線或地理市場</li>\n<li>更有效地針對目標群體提供服務,提供最佳的服務</li>\n<li>利基市場可以達到低成本</li>\n<li>根據這個細分市場採用低成本戰略或差異化戰略</li>\n</ol>\n</li>\n</ol>\n<p>進退兩難（stuck in middle）</p>\n<ol>\n<li>三種戰略都失敗了（成本、產異化、集中化）<ol>\n<li>缺少決心和理念進行低成本競爭</li>\n<li>沒有準備做差異化競爭的準備</li>\n<li>缺少常莊差異化或低成本化的專注度，沒有瞄準一個細分市場</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"高階競爭策略\"><a href=\"#高階競爭策略\" class=\"headerlink\" title=\"高階競爭策略\"></a>高階競爭策略</h1><h2 id=\"維護顧客群\"><a href=\"#維護顧客群\" class=\"headerlink\" title=\"維護顧客群\"></a>維護顧客群</h2><p>轉換成本  </p>\n<ul>\n<li><p>有些市場不能從初期消費者中獲利 <img data-src=\"\" alt=\"\">，需要高轉換成本</p>\n</li>\n<li><p>直接轉換成本</p>\n<ul>\n<li>新廠商的風險<ul>\n<li>尋找時間</li>\n<li>可能較差</li>\n</ul>\n</li>\n<li>違約金</li>\n</ul>\n</li>\n<li><p>關係轉換成本(Relationship-Related Switching Costs)</p>\n<ul>\n<li>合作關係所累積的經驗<ul>\n<li>客製化產品</li>\n</ul>\n</li>\n<li>會員優惠</li>\n<li>心理因素<ul>\n<li>與舊廠商關係良好</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>產品轉換成本(Product-Related Switching Costs)</p>\n<ul>\n<li>花時間習慣</li>\n<li>互補品的轉換成本(PC → Mac充電器)</li>\n</ul>\n</li>\n<li><p>消費者轉換條件：增加的效用 + 新廠商優惠 &gt; 轉換成本</p>\n</li>\n<li><p>廠商願意提供的優惠 &lt; 新消費者的利潤 - 轉換成本  </p>\n</li>\n</ul>\n<p>廠商提高轉換成本  </p>\n<ul>\n<li>會員優惠<ul>\n<li>VIP</li>\n<li>集點<ul>\n<li>有效期限</li>\n<li>提供的獎勵對廠商成本低，但對消費者是昂貴的</li>\n</ul>\n</li>\n<li>澇油水: 非自身出錢，如公司經費，但可拿到優惠</li>\n</ul>\n</li>\n<li>長期合約</li>\n<li>提供互補品</li>\n<li>提高服務品質</li>\n<li>特定格式(.doc, sony的硬體, apple的itunes)，特定介面(OS)</li>\n</ul>\n<p>消費者減少轉換成本  </p>\n<ul>\n<li>開放標準產品(USB, 3.5mm耳機)</li>\n<li>同時和多個廠商購買</li>\n<li>用預期會產生的轉換成本來與廠商協商價格(下策)</li>\n</ul>\n<p>新廠商的策略  </p>\n<ul>\n<li>減少消費者轉換成本<ul>\n<li>協助轉換</li>\n<li>優惠</li>\n</ul>\n</li>\n<li>增加產品效用</li>\n</ul>\n<h2 id=\"定價\"><a href=\"#定價\" class=\"headerlink\" title=\"定價\"></a>定價</h2><p>價格歧視: 對不同消費者提供不同價格，以達到最大效用</p>\n<p>一級價格歧視(完全價格歧視)    </p>\n<ul>\n<li>對每個消費者提供不同價格</li>\n<li>需要知道每個消費者願意支付的最高價格<ul>\n<li>一對一交涉</li>\n<li>網路拍賣</li>\n<li>如果網路商城可依照用戶喜好來提供價格？</li>\n</ul>\n</li>\n<li>對消費者不公平 </li>\n</ul>\n<p>二級價格歧視     </p>\n<ul>\n<li>公司提供不同購買選擇，消費者自己選擇<ul>\n<li>不必確認所有消費者資訊</li>\n</ul>\n</li>\n<li>非線性定價<ul>\n<li>數量折扣: 買愈多、折扣愈多</li>\n<li>手機: 很多種資費標準</li>\n</ul>\n</li>\n<li>版本化<ul>\n<li>調整產品功能</li>\n<li>飛機：頭等、經濟</li>\n<li>簡易版軟體<ul>\n<li>成本反而較高，因為需要修改程式</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>捆綁銷售<ul>\n<li>吸引只喜歡A或只喜歡B的消費者<ul>\n<li>降低消費者異質性</li>\n</ul>\n</li>\n<li>可吸引更多有價值的消費者(願意付較多錢)</li>\n<li>速食店單點只比套餐便宜一些</li>\n<li>免運費: 對不同距離消費者的歧視</li>\n</ul>\n</li>\n</ul>\n<p>三級價格歧視    </p>\n<ul>\n<li>對不同群體消費者收不同費用       <ul>\n<li>身份、地點、時間、工作、年齡</li>\n</ul>\n</li>\n<li>機場的食物</li>\n<li>學生票</li>\n<li>旺季旅遊</li>\n<li>跨期定價  <ul>\n<li>跟據產品推出的時間收不同費用(遊戲、新書、新手機)<ul>\n<li>不適合耐用品(消費者會有降價的預期心理)</li>\n<li>讓先買的消費者覺得不公平</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>直接價格歧視包括一級和三級價格歧視</p>\n<h2 id=\"競爭規則\"><a href=\"#競爭規則\" class=\"headerlink\" title=\"競爭規則\"></a>競爭規則</h2><h3 id=\"競爭政策的安全地帶\"><a href=\"#競爭政策的安全地帶\" class=\"headerlink\" title=\"競爭政策的安全地帶\"></a>競爭政策的安全地帶</h3><p>完全競爭  </p>\n<ul>\n<li>企業就無差別產品展開競爭且基本上每個人的定價都等於邊際成本。消費者可以享受全部的消費者剩餘，即可以創造出的全部剩餘的最大值<br>卡特爾組織  </li>\n<li>當存在壟斷企業或卡特爾組織時，這意味著要麼單一企業主導各自的市場，要麼幾家企業合力，表現得像一個單一的壟斷企業，會索取高於邊際成本的價格，造成無謂損失<ul>\n<li>壟斷企業或者卡特爾會獲得壟斷利潤，消費者剩餘被大幅蠶食，因為有消費者願意支付高於邊際成本的價格，卻不願意支付壟斷價格</li>\n</ul>\n</li>\n</ul>\n<p>競爭迫使企業生產更有效率，迫使企業用盡全力，通過差異化、創新、不斷提高效率，來盡力提高產品質量，卡特爾則相反    </p>\n<ol>\n<li>卡特爾化允許企業犧牲消費者來賺取高額利潤</li>\n<li>減少創新、降低產品質量、減少產品差異化</li>\n<li>競爭大幅減少，使企業降低風險</li>\n</ol>\n<p>反托拉斯(Anti-Trust)政策能保護消費者和企業不受卡特爾化的消極影響</p>\n<h3 id=\"競爭政策中的規定\"><a href=\"#競爭政策中的規定\" class=\"headerlink\" title=\"競爭政策中的規定\"></a>競爭政策中的規定</h3><ol>\n<li>禁止卡特爾<ol>\n<li>限制或禁止競爭者之間或供應商和消費者之間，簽訂限制競爭的協議或契約</li>\n</ol>\n</li>\n<li>禁止濫用市場支配地位<ol>\n<li>防止企業變得過於強大，或者防止它們濫用自己的強大地位，損害消費者和其他競爭者的利益</li>\n</ol>\n</li>\n<li>控制企業合併</li>\n</ol>\n<h4 id=\"禁止卡特爾\"><a href=\"#禁止卡特爾\" class=\"headerlink\" title=\"禁止卡特爾\"></a>禁止卡特爾</h4><ul>\n<li>要有確切證據</li>\n<li>識別企業串謀行為<ol>\n<li>企業A和企業B同時提高或降低價格</li>\n<li>企業劃分商品銷售區域</li>\n</ol>\n</li>\n</ul>\n<p>溝通、合作越好，就越容易形成卡特爾。對卡特爾有利的因素       </p>\n<ol>\n<li>生產同質產品，公司會就此瞭解彼此的動態，使卡特爾更易維持</li>\n<li>如果能監控價格和銷量，即存在技術方面的可預測性，市場季節性、瞭解成本構成等，要建立卡特爾就會更加容易</li>\n<li>企業曾有實行過卡特爾的經驗</li>\n</ol>\n<h4 id=\"禁止濫用市場支配地位\"><a href=\"#禁止濫用市場支配地位\" class=\"headerlink\" title=\"禁止濫用市場支配地位\"></a>禁止濫用市場支配地位</h4><ul>\n<li>怎樣評定一個公司是否正濫用權力？<ol>\n<li>定義相關市場<ol>\n<li>產品市場: 哪些產品和 (或) 服務是相似的？哪些產品之間存在競爭？</li>\n<li>地域市場: 為了買一件商品消費者願意走多遠？換句話說 哪些地理區域是相關的？</li>\n<li>消費者市場: 哪些消費者或消費者群體，有興趣購買某產品</li>\n<li>假定壟斷者測試</li>\n</ol>\n</li>\n<li>接著評定該公司，是否真的在該市場佔據主導地位</li>\n<li>看這個公司的行為，是否損害了競爭對手 (的利益) 或將其排除在了該特定市場以外</li>\n</ol>\n</li>\n</ul>\n<p>假定壟斷者測試(SSNIP)<br>一個假定壟斷者即HM，能否通過一個幅度不大但有意義的非臨時性提價來增加利潤。如果答案是不能獲益，那實際上假定壟斷者的利潤減少，即提高價格會導致利潤減少，這就意味著我們需要將最接近的替代品納入該市場，接著重複進行這一測試<strong>，如果一個假定壟斷者確實能通過提高價格增加利潤，我們就正確地界定了相關市場</strong>。基本上這個測試會反覆進行，直到你正確地定義了市場為止。<br><strong>市場上活躍的公司數量，並且假定它們都被一家公司所取代，被一個壟斷者取代，如果該壟斷者能通過提高價格增加利潤，那麼我們所看到的就是市場的正確定義。</strong></p>\n<p>阻止公司擴張或是增加利潤的兩個力量  </p>\n<ol>\n<li>需求方替代品: 如果你提高價格，人們就會買別的產品</li>\n<li>供給方替代品: 如果你開始提價，其他企業或競爭者將會進入市場</li>\n</ol>\n<p>衡量市場集中度   </p>\n<ol>\n<li>企業數量的倒數</li>\n<li>前N家最大企業所佔市場份額的總和</li>\n<li>赫芬達爾—赫希曼指數(HHI)<ol>\n<li>取某一行業中所有公司的市場份額，求得每一個份額的平方值，最後再將所有平方值相加，計算得出的結果都將介於零到一萬之間，零基本意味著市場上小公司的數量無限，而一萬則是只有一個壟斷者時的HHI指數，兼併及競爭管理機構常常將這一指數作為參考</li>\n<li>HHI的值的意義  <ol>\n<li>&lt;1000: 可接受</li>\n<li>1000~1800: 兼併可能會被允許，但或許會被要求附上一些條件</li>\n<li><blockquote>\n<p>1800: 兼併時會在許多細節上被深入調查</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<p>市場圈定  </p>\n<ul>\n<li>處於市場支配地位時，使其他公司難以進入市場並改變現狀的行為就稱作市場圈定</li>\n<li>任何<strong>鞏固現有市場結構的行為</strong>，都可以被視為是一種市場圈定</li>\n</ul>\n<ol>\n<li>獨佔交易: 企業通過擬定採購合約 來阻止其他人，向競爭對手銷售或購買產品<ol>\n<li>以加油站為例，同品牌的加油站只向相同的供應商購買汽油</li>\n</ol>\n</li>\n<li>搭售: 當企業售賣一件具有市場影響力的產品時，要求消費者購買第二件沒有市場影響力的產品<ol>\n<li>在美國買蘋果手機，必須與AT&amp;T簽約入網</li>\n</ol>\n</li>\n<li>捆綁銷售: 其中只有一件擁有市場勢力，但你給捆綁購買這些產品的消費者提供折扣(搭售沒有折扣)<ol>\n<li>一首熱門歌曲收入在一個專輯，想買必須買這個專輯</li>\n</ol>\n</li>\n<li>掠奪性定價: 即先設定一個會讓你在短期內遭受損失的價格，但是從長遠來看，可以把競爭對手趕出市場並獲得壟斷利潤</li>\n<li>拒絕交易: 對下游競爭性行業的壟斷。拒絕向競爭對手提供關鍵投入或接口，或者出售投入的價格，會使競爭對手無法營利<ol>\n<li>微軟捆綁播放器，但對對手開放接口少，對手無法開發更好的播放器</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>成為壟斷企業並不違法，真正違法的是濫用壟斷地位</p>\n</blockquote>\n<h2 id=\"提高收益\"><a href=\"#提高收益\" class=\"headerlink\" title=\"提高收益\"></a>提高收益</h2><p>網路商品定義   </p>\n<ol>\n<li>消費外部性為正: 如果有其他人加入我的網路，我就能得到額外效用</li>\n<li>臨界規模: 當網路小於一定規模時，就無法持續</li>\n<li>存在兼容性以及標準問題: 存在轉換成本，並且消費者常常會被鎖定在特定的網路中<ol>\n<li>這一特性並非為網路市場所獨有，但在網路市場常見</li>\n</ol>\n</li>\n<li>集中化市場結構: 通常只有一個贏家</li>\n<li>顯著的規模經濟: 使用的人愈多，平均成本愈低</li>\n</ol>\n<p>大規模的優勢  </p>\n<ol>\n<li>使企業的繼續擴大更容易</li>\n<li>成本將不斷降低，盈利會增加</li>\n<li>梅特卡夫定律 (Metcalfe’s Law)<ol>\n<li><strong>直接</strong>的網路效應: <strong>潛在使用次數</strong>和<strong>使用人數的指數</strong>呈正相關</li>\n</ol>\n</li>\n</ol>\n<p>擴散  </p>\n<ol>\n<li>一項新技術一經推出，並不會立刻被整個市場採用</li>\n<li>新用戶的加入會是一個相當緩慢的過程</li>\n<li>事實上，擴散會以S型進行: 起初擴散很慢，中期擴散很快，之後又逐漸放緩<ol>\n<li>達到某個臨界數量(效用)時，許多人會開始使用(中期)</li>\n</ol>\n</li>\n</ol>\n<p>效用函數  </p>\n<ol>\n<li>獨立價值 a、使用人數 n、網路效應的強度 α  </li>\n<li>U = a + n^α<ol>\n<li>n 和 α 影響最大</li>\n</ol>\n</li>\n<li>加上不同使用者的效用<ol>\n<li>先驅: 認為 a 很大</li>\n<li>中期採用者: 和一般假設相同(大多數的人是中期採用)</li>\n<li>晚期採用者: 認為 a 小</li>\n</ol>\n</li>\n</ol>\n<p>間接的網路效應  </p>\n<ul>\n<li><strong>兼容產品</strong>: 即效用互相依賴於其他產品的用戶數量<ul>\n<li>遊戲機和遊戲</li>\n<li>信用卡和採用信用卡的店家</li>\n<li>互補產品越多意味著用戶越多，而用戶越多也意味著互補產品越多</li>\n<li>消費者所看到的是整個互補品組合</li>\n</ul>\n</li>\n</ul>\n<p>網路行業中的市場結構   </p>\n<ol>\n<li>網路效應很強且消費者異質性小，很有可能會出現壟斷</li>\n<li>網路效應略弱但消費者異質性大的市場，一個公司佔據支配地位，但其他利基公司也可以生存</li>\n<li>弱網路效應和高消費者異質性，沒有單一企業可以佔據支配地位</li>\n</ol>\n<h3 id=\"橫向企業邊界\"><a href=\"#橫向企業邊界\" class=\"headerlink\" title=\"橫向企業邊界\"></a>橫向企業邊界</h3><p>橫向企業邊界: 企業能以多大的規模進行生產經營</p>\n<p>規模經濟: 生產一種產品的平均成本, 會隨著<strong>產量</strong>的增加而降低  </p>\n<ol>\n<li>固定成本: 生產過程中有些投入必須達到最低要求(機器): 提高產量最終能將固定成本分攤給更多份產品</li>\n<li>庫存: 指的是一個公司會有一定量的存貨: 大公司庫存量對銷量的比例可以更小，因為大公司的需求較為穩定</li>\n</ol>\n<p>學習型經濟: 指生產某個產品的平均成本隨著<strong>累積產量</strong>的增加而降低  </p>\n<ul>\n<li>昨天的產量,會決定今天的生產效率    </li>\n</ul>\n<p>範圍經濟: 由同一主體生產和提供<strong>不同的產品和服務</strong>，能夠節約成本   </p>\n<ol>\n<li>品牌保護傘: 因為當你推出一項新產品，基本上是將品牌下所有產品的聲譽作為賭注。新產品必須符合現有品牌口碑的優質產品，否則將損害新產品和原有產品的價值和聲譽</li>\n<li>聯合採購: 如果你購買的產品數量較高，單價就會降低</li>\n</ol>\n<p>可能阻礙規模經濟和範圍經濟的因素(規模不經濟、範圍不經濟)   </p>\n<ol>\n<li>勞動力成本<ol>\n<li>較大的公司最後往往要支付更高的工資</li>\n</ol>\n</li>\n<li>更多管理、溝通的浪費</li>\n</ol>\n<p>供應商與採購商的關係<br>2. 外購<br>    1. 製造規模經濟，減少成本<br>    2. 固定成本轉換成可變成本<br>    3. 分散風險<br>    4. 增加競爭(自己設立的工廠沒有競爭壓力)<br>3. 自製<br>    1. 避免交易成本：尋找廠商、合約<br>    2. 可以隨意調整產品<br>    2. 避免被敲竹槓</p>\n<h2 id=\"適用於網路市場的策略\"><a href=\"#適用於網路市場的策略\" class=\"headerlink\" title=\"適用於網路市場的策略\"></a>適用於網路市場的策略</h2><p>網路市場中的競爭  </p>\n<ol>\n<li>你需要確保達到臨界規模(Critical Mass)<ol>\n<li>達到臨界規模會發生滾雪球效應(中期使用者快速增加)</li>\n<li>贏得早期採用者以推廣</li>\n</ol>\n</li>\n</ol>\n<p>決定臨界規模的因素   </p>\n<ol>\n<li>足夠大的用戶基數</li>\n<li>足夠強的網路效應</li>\n<li>足夠低的價格使市場擴散得以自我維持<ol>\n<li>自我維持: 沒有改變產品的情況下，網路中就會湧入更多的使用者，因為效用越來越高</li>\n</ol>\n</li>\n</ol>\n<p>加速到達臨界規模   </p>\n<ol>\n<li>提高對網路效應的預期<ol>\n<li>利用信譽（自身信譽、或者與他人聯合借用合作夥伴信譽）<ol>\n<li>擁有已經成功的技術</li>\n</ol>\n</li>\n<li>宣傳(廣告)</li>\n</ol>\n</li>\n<li>打破現有技術在市場中的鎖定效應<ol start=\"2\">\n<li>提前宣佈: 消費者可能願意等到這個新產品上市，再做購買決定<ol>\n<li>高科技市場常見的做法</li>\n<li>太晚上市的話會減低消費者信心(暗黑3是例外…)<ol start=\"3\">\n<li>霧件：已經宣佈但從未實現的商品…</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>減低消費者被失敗技術鎖定的風險<ol start=\"4\">\n<li>提前簽訂合約，讓潛在顧客知道，有許多其他用戶已經決定採用新技術了，預期效用增加</li>\n<li>提供早期採用者適當的折扣</li>\n<li>讓消費者租賃，萬一不成功可以退貨</li>\n<li>授權新技術給其他廠商。作為取得勝利或避免標準之爭的方法。可確保新技術提供商的數量充足<ol>\n<li>新技術授權的優勢對發起者來說同樣重要<ol>\n<li>新技術的發起者能規定技術細節</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"網路市場中的策略\"><a href=\"#網路市場中的策略\" class=\"headerlink\" title=\"網路市場中的策略\"></a>網路市場中的策略</h3><p>兼容性   </p>\n<ol>\n<li><p>完全兼容: 不同品牌按同一標準運作</p>\n<ol>\n<li>電信業者  </li>\n</ol>\n</li>\n<li><p>向後兼容: 如果新型號能兼容舊型號，反之卻不行</p>\n<ol>\n<li>DVD、CD</li>\n</ol>\n</li>\n<li><p>單向兼容: 一種標準或技術能使用另一個，而後者不能使用前者</p>\n</li>\n<li><p>部分兼容: 如果產品可交互操作，他們就是部分兼容</p>\n<ol>\n<li>性能可能降低 或 必須負擔一定費用</li>\n</ol>\n</li>\n<li><p>法定標準。通過法律或組織制定的標準，以避免消費者的不確定和困惑</p>\n</li>\n<li><p>事實標準，由一個公司所指定的標準，或是經由市場勢力處於主導地位的標準，也就是標準被廣泛使用，而不是獲得標準制定組織或政府認可。市場可能選擇的技術，優先於官方、標準制定組織和立法者</p>\n</li>\n</ol>\n<p>標準選擇可能出現納許均衡：</p>\n<ol>\n<li>各選各的標準(可能相同，可能不同)<ol>\n<li>不相上下 (Tweedledum and Tweedledee): 傾向多個標準競爭</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTgwJUE3JUU1JTg4JUFCJUU2JTg4JTk4\">性別戰<i class=\"fa fa-external-link-alt\"></i></span> （Battle of sexes）: 傾向用共同標準，先採取行動者有優勢</li>\n</ol>\n</li>\n<li>一方兼容策略(惱人小弟策略），A傾向於有一個共同標準，可以理解為小弟總想跟隨大哥，但是公司B也就是我們說的「大哥」，希望存在兩個標準</li>\n</ol>\n<p>產生共同標準  </p>\n<ul>\n<li>低價授權</li>\n<li>混合標準(能同時使用多種標準)</li>\n<li>標準的開發轉移到第三方</li>\n</ul>\n<h3 id=\"目標市場\"><a href=\"#目標市場\" class=\"headerlink\" title=\"目標市場\"></a>目標市場</h3><ol>\n<li>爭取到有影響力的採用者<ol>\n<li>透過自己的聲望或社會影響力來帶動別的用戶，他們的影響力也能提高產品的知名度，有影響力的採用者自己也有可能構成臨界規模</li>\n</ol>\n</li>\n<li>就是對盜版商睜一隻眼閉一隻眼。網路規模可以來自合法消費者，也能來自盜版商。無視盜版可能比死守知識產權更能盈利，如：學生使用盜版軟件<ol>\n<li>為何不降價？</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"定價策略\"><a href=\"#定價策略\" class=\"headerlink\" title=\"定價策略\"></a>定價策略</h3><p>通常網路產品有進入市場的沉沒成本，固定成本高，邊際成本低，使定價有很大的靈活性，因此，成本導向定價當然也就沒多大意義<br>價值導向定價: 設定的價格，反映了商品對於消費者的價值，而不是生產的成本</p>\n<ol>\n<li>網路商品定價應有利於商品擴散，希望早期建立足夠大的用戶基數</li>\n<li>強網路效應，意味著消費者會有更大的支付意願</li>\n<li>價格歧視策略。對支付意願低的消費者提供<strong>免費版本</strong>，以增加用戶基數。意味著對專業用戶可以收更高的費用</li>\n</ol>\n<ul>\n<li>滲透定價<ul>\n<li>意味著在早期階段，通過收取低價來建立用戶基數，當用戶基數的上升使得消費者認定的價值提高，才開始提高價格</li>\n<li>價格則隨著時間推移而上漲</li>\n</ul>\n</li>\n<li>撇脂定價<ul>\n<li>價格隨著時間推移而下降</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"借助合作夥伴實現增長\"><a href=\"#借助合作夥伴實現增長\" class=\"headerlink\" title=\"借助合作夥伴實現增長\"></a>借助合作夥伴實現增長</h2><p>併購的趨勢<br>1.許多公司會在同一時間內進行兼併<br>2.併購的數量和交易額增長</p>\n<p>兼併（merger）   </p>\n<ul>\n<li>對等合併: 兩家規模相當的公司，決定進行聯營並共享產權，它們合併後成為一個新的法律實體<ul>\n<li>兼併雙方的股票通常都會撤市，取而代之的是新公司的股票</li>\n</ul>\n</li>\n<li>真正的對等兼併其實並不常見，但通常名義上還是宣稱對等，為什麼？因為這能打消員工的一些擔憂，使他們不用擔心。如：在一家公司接管另一家後，自己的職位及工作岌岌可危，諸如此類。但在現實中，常常有一方略強於另一方，因此對一些事情有決定權，比如：誰來就任新公司的首席執行官，新公司開展什麼項目。</li>\n</ul>\n<p>收購(acquisition)<br>指的是公司從一開始就不對等，所以這裡就有一個收購方和一個目標公司，收購方將吞併目標公司，也就是說，它是這場收購中更強大的一方，而目標公司則是較弱的一方</p>\n<p>兼併方和收購方的目標可分為  </p>\n<ol>\n<li>橫向兼併: 兼併競爭者<ol>\n<li>如果從市場中少了一家公司，競爭就會被削弱，壯大自己就能降低成為併購目標的風險</li>\n<li>提高談判能力</li>\n<li>生產有關的優勢：能夠推行更先進的生產技術、可以實現規模經濟和範圍經濟、推行新技術、通過兼併獲得小公司的新技術</li>\n<li>市場有關的優勢：可以獲得其他公司的新產品、進入新的產品市場、比建立一個品牌更便宜地擁有一個品牌、獲得渠道、降低交易成本等</li>\n</ol>\n</li>\n<li>縱向兼併: 兼併供應商或買家<ol>\n<li>降低交易成本</li>\n<li>獲得對上下游資源的控制</li>\n<li>提高進入壁壘</li>\n</ol>\n</li>\n<li>混合兼併: 兼併和目前事業無關的公司<ol>\n<li>得不到市場優勢，也得不到生產和競爭方面的優勢</li>\n<li>可以分散風險</li>\n</ol>\n</li>\n</ol>\n<p>公司被收購獲得的好處  </p>\n<ol>\n<li>對公司來說,這也許是一個解決財務問題的方法</li>\n<li>使你處於更佳的競爭地位</li>\n<li>也許還是重組公司的一個契機</li>\n<li>增加投資</li>\n<li>沒有繼承人的情況下，賣掉公司也許是確保公司存活，並擁有傑出的管理層最簡單的方法</li>\n<li>經常有些意見相左的大股東，通過賣掉公司來解決分歧，通常比不斷嘗試協調股東之間的不同利益等容易的多</li>\n</ol>\n<p>併購過程  </p>\n<ol>\n<li>找到與我們戰略目標一致的目標公司<ol>\n<li>考慮的是收購方與目標公司之間的相關程度和相符程度，包括：戰略＼產品組合(加強或互補)＼管理風格＼核心市場＼核心能力(優勢)是否互補匹配</li>\n</ol>\n</li>\n<li>盡職調查，確定潛在協同效應的步驟。將從財務和法律兩方面進行分析，並對潛在目標公司進行戰略分析，是否真的能夠幫助我們實現戰略目標？</li>\n<li>交易開始。一旦敲定了價格(通常會高於市場價值)，要進行明確融資策略，如現金實現、股票互換、貸款、追加公司資本</li>\n<li>兼併後整合(最麻煩的步驟)</li>\n</ol>\n<p>併購的協同效應  </p>\n<ol>\n<li>規模經濟</li>\n<li>市場勢力的增加</li>\n<li>分散風險</li>\n</ol>\n<p>雙方之間的協同效應並不會從天而降，還需要經過深思熟慮的整合行為</p>\n<p>企業合併控制: 監管大型企業兼併的過程，旨在阻止那些會極大削弱競爭，並最終會使公司佔據支配地位的交易  </p>\n<ul>\n<li>評估<ol>\n<li>界定產品市場</li>\n<li>計算出幾家參與併購公司的市場份額</li>\n<li>判斷是否會出現壟斷行為</li>\n</ol>\n</li>\n</ul>\n<p>兼併後的蜜月期——兼併後整合  </p>\n<ol>\n<li>儘可能地整合併購企業，或許能完全實現預期的兼併協同效應，整合程度越高，就越有可能完全實現這一協同效應</li>\n<li>併購綜合症: 被收購的企業，其管理層的更替率可能相當高，因為他們被要求改變辦事方式，被要求交出之前的權力，他們可能因此感到極為失望並離職，發生這種事也有可能影響普通員工，他們可能會以怠慢工作，或冷淡對待工作來表現負面情緒</li>\n</ol>\n<p>兼併後整合模式  </p>\n<ol>\n<li>控股公司——如果被收購企業的自治需求不高，也不急於進行戰略整合<ol>\n<li>並不存在一個整合計畫。實際整合的部分，只包括了財務轉移、風險分擔以及綜合管理能力等方面。其他基本保持獨立</li>\n</ol>\n</li>\n<li>保留型模式——如果被併購企業的自治需求高，但對戰略整合的需求不高<ol>\n<li>在這種情況下實行整合或者是過度整合，都有可能不利於兼併的成功，應適當放寬對被收購企業的管理，即不對其進行太大的整改——只透過投資而非直接管理來創造價值</li>\n</ol>\n</li>\n<li>吸收型模式——當目標企業的自治需求低，且急於進行戰略整合<ol>\n<li>把企業拉向彼此，問題不在於是否整合，而是如何整合？以及何時整合？也就是要找到整合的最佳時機，儘可能減少僱員特別是核心員工上的麻煩</li>\n</ol>\n</li>\n<li>共生關係——如果企業自治需求高的同時 對戰略整合的需求也高（最為複雜的模式）<ol>\n<li>先讓兩家企業共存，然後逐漸整合。可以說是一種合作夥伴式的整合過程</li>\n</ol>\n</li>\n</ol>\n<p>追求協同效應過程中常見失敗因素  </p>\n<ol>\n<li>兼併的結果就是競爭可能會越發激烈，而不是減弱</li>\n<li>管理層人員本應做出調整，卻堅持固有想法時</li>\n<li>固有價值被破壞，員工失去士氣</li>\n<li>核心人員可能會離職</li>\n<li>收購方以及被收購方各自都有非常明確的使命，新企業也要找到自己的使命，如果沒有一位能指明方向的領導人，便可能會產生問題</li>\n</ol>\n<p>真正成功的兼併少之又少，原因有多    </p>\n<ol>\n<li>對於成功有不同的評判標準，如股票沒有沒跑贏大盤</li>\n<li>兼併過程中每一步都可能出錯</li>\n<li>併購可能出於管理層的私人利益<ol>\n<li>管理一個更大的企業會給他們帶來社會地位、獲得更高收入等</li>\n<li>兼併帶來的股票上漲，給目標公司前股東帶來了收益</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"有機增長\"><a href=\"#有機增長\" class=\"headerlink\" title=\"有機增長\"></a>有機增長</h2><p>小公司的限制  </p>\n<ol>\n<li>獲得廉價資本方面受限</li>\n<li>研發能力也會受到限制</li>\n<li>很難找到專利技術的替代品</li>\n<li>更難維持能滿足顧客需求的一定規模的銷售組織</li>\n<li>沒有大公司那樣的廣告影響力</li>\n<li>沒有掌控供應商的能力</li>\n<li>無法通過多個市場經營分散風險</li>\n<li>無法承受進入新市場的高額成本</li>\n<li>無法應用更多元化的管理能力和技術能力，即：管理經濟、規模經濟、範圍經濟</li>\n</ol>\n<p>有機增長  </p>\n<ul>\n<li>公司依靠創新、新產品和服務、客戶增長等核心業務拓展而帶來的增長<ul>\n<li>企業早期階段，<strong>建立新市場、開發新產品</strong>的時候，有機增長是最常見、最普遍的增長方式</li>\n<li>有機(內部)增長的過程通常也比無機增長(依頼外力的成長，如收購)要慢  </li>\n</ul>\n</li>\n<li>增長方式<ol>\n<li>獲得新顧客，即擴大消費族群</li>\n<li>增加現有產品和服務的銷量</li>\n<li>推出新產品和服務</li>\n<li>進入新的區域市場，實行多樣化經營</li>\n</ol>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>產品\\市場</th>\n<th>存在</th>\n<th>新的</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>存在</td>\n<td>保護/建造</td>\n<td>生產/開發</td>\n</tr>\n<tr>\n<td>新的</td>\n<td>市場開發</td>\n<td>多樣化</td>\n</tr>\n</tbody></table>\n<ul>\n<li>保護/建造: 穩固、保護市場地位</li>\n<li>生產/開發: 針對市場推出新產品，引入新的競爭力</li>\n<li>市場開發: 尋找新的市場、新的定位，如果核心模塊是產品相關的，這是一個好策略</li>\n<li>多樣化: 超出預期，新開發的產品，新的市場都不是熟悉的，風險最高 <ul>\n<li>基於品牌忠誠度的水平多樣化</li>\n<li>基於產品分類的生產過程或者技術多樣化</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>發展的外部限制  <ol>\n<li>缺少資源（產品和市場因素）：資金、勞動力、特定自然資源、技術、專利、商機<ol>\n<li>這些是固定因素，無法改變</li>\n</ol>\n</li>\n<li>領導者需要深刻的洞察力、想像力、管理技巧等</li>\n</ol>\n</li>\n<li>發展的內部限制  <ol>\n<li>管理能力不足</li>\n<li>管理不經濟(需要更多人管理)</li>\n<li>結構不適（strutural misfit)：有些結構難以改變<ol>\n<li>需要結構成長以避免(簡單、功能型、多部門)</li>\n</ol>\n</li>\n<li>不確定性和風險</li>\n</ol>\n</li>\n</ul>\n<p>管理限制（managerial limits, penrose, 1995)  </p>\n<ol>\n<li>一段時間內的計畫總量，限制了你在下個時期可以吸收的新員工的數量</li>\n<li>公司需要很多計畫，才能實現增長</li>\n</ol>\n<p>典型的組織結構發展: 因為銷售增長，為了解決協調和控制問題而調整結構<br>簡單結構（一個管理者和一些員工） → 功能型結構(分部門) → 多部門結構（按產品或地區設立事業部）</p>\n<h3 id=\"國際化策略\"><a href=\"#國際化策略\" class=\"headerlink\" title=\"國際化策略\"></a>國際化策略</h3><p>兩種壓力，四種維度    </p>\n<ul>\n<li>成本降低壓力</li>\n<li>適應本地市場壓力</li>\n</ul>\n<ol>\n<li>全球化戰略（global strategy）<ol>\n<li>面臨高效率的壓力，全球一體化的要求很高，為了降低成本，更注重效率而不是滿足當地需求，如：微軟、保潔</li>\n</ol>\n</li>\n<li>多國本地化策略（multidomestic strategy)<ol>\n<li>適應本地市場壓力高，對適應當地市場的要求很高，但降低成本的壓力則相當小；如：MTV</li>\n</ol>\n</li>\n<li>跨國戰略（transnational strategy)<ol>\n<li>兩種壓力都大，統一品牌，適當本地化，適應當地市場，以及全球一體化的要求都很高，最難實施。如：麥當勞、肯德基等</li>\n</ol>\n</li>\n<li>國際化戰略（International strategy）<ol>\n<li>降低成本的壓力和適應當地的壓力都較小，又可以稱為出口戰略，如：特產、衣服、家具等</li>\n</ol>\n</li>\n</ol>\n",
            "tags": [
                "經濟學",
                "策略",
                "競爭",
                "博弈論"
            ]
        },
        {
            "id": "http://gitqwerty777.github.io/header-file-tips/",
            "url": "http://gitqwerty777.github.io/header-file-tips/",
            "title": "標頭檔(header)與include",
            "date_published": "2015-07-21T04:37:47.000Z",
            "content_html": "<p>本文整理自 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL2ZvcnVtL2FydGljbGVzLzEwNjI3Lw==\">headers and includes: why and how<i class=\"fa fa-external-link-alt\"></i></span></p>\n<a id=\"more\"></a>\n<h2 id=\"Why-we-need-header-files\"><a href=\"#Why-we-need-header-files\" class=\"headerlink\" title=\"Why we need header files\"></a>Why we need header files</h2><ul>\n<li>speeds up compile time<ul>\n<li>if everything is in a single file, then everything must be fully recompiled every time you make any little change</li>\n</ul>\n</li>\n<li>keeps your code more organized<ul>\n<li>easier to find the code you are looking for</li>\n</ul>\n</li>\n<li>allows you to separate interface from implementation<ul>\n<li>make the interface visible to other .cpp files, while keeping the implementation in its own .cpp file</li>\n</ul>\n</li>\n</ul>\n<p>Compile Process  </p>\n<ol>\n<li>compiler generates intermediate files(object file) for each compiled source file<ol>\n<li>compiler will “replace” the #include line with the actual contents of the file you’re including when it compiles the file</li>\n<li>files with header extensions might be ignored by the compiler if you try to compile them</li>\n</ol>\n</li>\n<li>then links all the object files together, which generates the final binary</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// in myclass.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> bar;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// in myclass.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"myclass.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">MyClass::foo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//in main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"myclass.h\"</span>  <span class=\"comment\">// defines MyClass</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  MyClass a; <span class=\"comment\">// no longer produces an error, because MyClass is defined</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Header files should use a .h__ extension (.h / .hpp / .hxx). Which of those you use doesn’t matter</li>\n<li>C++ Source files should use a .c__ extention (.cpp / .cxx / .cc). Which of those you use doesn’t matter</li>\n<li>C Source files should use .c (.c only)</li>\n</ul>\n<blockquote>\n<p>header files are #included and not compiled, whereas source files are compiled and not #included</p>\n</blockquote>\n<p>The one exception is that it is sometimes (although very rarely) useful to include a source file. This scenario has to do with instantiating templates and is outside the scope of this article</p>\n<h2 id=\"Include-guards\"><a href=\"#Include-guards\" class=\"headerlink\" title=\"Include guards\"></a>Include guards</h2><p>include multiple times of the same code would cause error  </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// myclass.h</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DoSomething</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"myclass.h\"</span>   <span class=\"comment\">// define MyClass</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"myclass.h\"</span>   <span class=\"comment\">// Compiler error - MyClass already defined</span></span></span><br></pre></td></tr></table></figure>\n\n<p>There’s an Implicit Example </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// x.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span> &#123;</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// a.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"x.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span> X x; &#125;;</span><br><span class=\"line\"><span class=\"comment\">// b.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"x.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> &#123;</span> X x; &#125;;</span><br><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span>  <span class=\"comment\">// also includes \"x.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span>  <span class=\"comment\">// includes x.h again!  ERROR</span></span></span><br></pre></td></tr></table></figure>\n\n<p>Because of this scenario, many people are told not to put #include in header files. However this is bad advice and you should not listen to it, But remember  </p>\n<ol>\n<li>Only #include things you need to include</li>\n<li>Guard against incidental multiple includes with include guards<ol>\n<li>skipping over the entire header if it was already included</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//x.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __X_H_INCLUDED__   <span class=\"comment\">// if x.h hasn't been included yet...</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __X_H_INCLUDED__   <span class=\"comment\">//   #define this so the compiler knows it has been included</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span> &#123;</span> &#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"The-“right-way”-to-include\"><a href=\"#The-“right-way”-to-include\" class=\"headerlink\" title=\"The “right way” to include\"></a>The “right way” to include</h2><p>aware of following dependencies   </p>\n<ol>\n<li>stuff that can be forward declared</li>\n<li>stuff that needs to be #included</li>\n</ol>\n<p>Dedepency that should be used  </p>\n<ul>\n<li>do nothing if<ul>\n<li>A makes no references at all to B</li>\n<li>The only reference to B is in a friend declaration</li>\n</ul>\n</li>\n<li>forward declare B if<ul>\n<li>A <strong>contains</strong> a B <strong>pointer or reference</strong><ul>\n<li>B* myb, B&amp; myb</li>\n</ul>\n</li>\n<li>function has B object/pointer/reference as <strong>parementer or return type</strong><ul>\n<li>B MyFunction(B myb)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>include “b.h” if<ul>\n<li>B is a <strong>parent class</strong> of A</li>\n<li>A <strong>contains</strong> a B object<ul>\n<li>B myb</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">myclass.h</span><br><span class=\"line\"><span class=\"comment\">//=================================</span></span><br><span class=\"line\"><span class=\"comment\">// include guard</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __MYCLASS_H_INCLUDED__</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __MYCLASS_H_INCLUDED__</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//=================================</span></span><br><span class=\"line\"><span class=\"comment\">// forward declared dependencies</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bar</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//=================================</span></span><br><span class=\"line\"><span class=\"comment\">// included dependencies</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"parent.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//=================================</span></span><br><span class=\"line\"><span class=\"comment\">// the actual class</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> :</span> <span class=\"keyword\">public</span> Parent  <span class=\"comment\">// Parent object, so #include \"parent.h\"</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; avector;    <span class=\"comment\">// vector object, so #include &lt;vector&gt;</span></span><br><span class=\"line\">  Foo* foo;                    <span class=\"comment\">// Foo pointer, so forward declare Foo</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Func</span><span class=\"params\">(Bar&amp; bar)</span></span>;         <span class=\"comment\">// Bar reference, so forward declare Bar</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyFriend</span>;</span>       <span class=\"comment\">// friend declaration is not a dependency</span></span><br><span class=\"line\">                               <span class=\"comment\">//   don't do anything about MyFriend</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">// __MYCLASS_H_INCLUDED__ </span></span></span><br><span class=\"line\">```\t</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### Why that is the <span class=\"string\">\"right way\"</span> to include</span><br><span class=\"line\"></span><br><span class=\"line\">- general idea is that it makes \"myclass.h\" fully self-contained and doesn't require any other area of the program (other than MyClass's implementation/source file) to know how MyClass works internally</span><br><span class=\"line\">\t- If some other <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">needs</span> <span class=\"title\">to</span> <span class=\"title\">use</span> <span class=\"title\">MyClass</span>, <span class=\"title\">it</span> <span class=\"title\">can</span> <span class=\"title\">just</span> #<span class=\"title\">include</span> \"<span class=\"title\">myclass</span>.<span class=\"title\">h</span>\" <span class=\"title\">and</span> <span class=\"title\">be</span> <span class=\"title\">done</span> <span class=\"title\">with</span> <span class=\"title\">it</span>!</span></span><br><span class=\"line\">- Alternative method: #include all of MyClass's dependencies before #including \"myclass.h\" </span><br><span class=\"line\"></span><br><span class=\"line\">``` cpp </span><br><span class=\"line\"><span class=\"comment\">//  I want to use MyClass</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"myclass.h\"</span>   <span class=\"comment\">// will always work, no matter what MyClass looks like.</span></span></span><br><span class=\"line\">                       <span class=\"comment\">// You're done</span></span><br><span class=\"line\">               <span class=\"comment\">//  (provided myclass.h follows my outline above and does</span></span><br><span class=\"line\">               <span class=\"comment\">//   not make unnecessary #includes)</span></span><br></pre></td></tr></table></figure>\n\n<p>why alternative method is bad：you should fill out all depency header and maintain it’s order</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  I want to use MyClass</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"myclass.h\"</span></span></span><br><span class=\"line\">   <span class=\"comment\">// ERROR 'Parent' undefined</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"parent.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"myclass.h\"</span></span></span><br><span class=\"line\">   <span class=\"comment\">// ERROR 'std::vector' undefined </span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"parent.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"myclass.h\"</span></span></span><br><span class=\"line\">   <span class=\"comment\">// ERROR 'Support' undefined </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"parent.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"support.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"myclass.h\"</span></span></span><br><span class=\"line\">   <span class=\"comment\">// ERROR 'Support' undefined</span></span><br><span class=\"line\">   <span class=\"comment\">// \"parent.h\" uses Support, and therefore you must #include \"support.h\" before \"parent.h\"</span></span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">It is all about encapsulation. Files that want to use MyClass don't need to be aware of what MyClass uses in order for it to work, and don't need to #include any MyClass dependencies. It's all very OO friendly, very easy to use, and very easy to maintain</span><br><span class=\"line\"></span><br><span class=\"line\">### Circular Dependencies</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">A circular dependency is when <span class=\"title\">two</span> <span class=\"params\">(<span class=\"keyword\">or</span> more)</span> classes depend on each other  </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\">```cpp</span><br><span class=\"line\"><span class=\"comment\">// a.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span> B* b; &#125;;</span><br><span class=\"line\"><span class=\"comment\">// b.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> &#123;</span> A* a &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>That’s what circular inclusion does</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span> </span></span><br><span class=\"line\"></span><br><span class=\"line\">The compiler will <span class=\"keyword\">do</span> the following:</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// start compiling a.h</span></span><br><span class=\"line\">   <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// start compiling b.h</span></span><br><span class=\"line\">      <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"comment\">// compilation of a.h skipped because it's guarded</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// resume compiling b.h</span></span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> &#123;</span> A* a &#125;;        <span class=\"comment\">// &lt;--- ERROR, A is undeclared</span></span><br></pre></td></tr></table></figure>\n\n<p>Even though you’re #including “a.h”, the compiler is not seeing A class until B class gets compiled.<br>Solution: forward declare when you’re only using a pointer or reference</p>\n<p>Situation below is conceptually impossible(not logical). The solution is to have one or both classes contain a pointer or reference to the other, rather than a full object</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.h (guarded)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  B b;   <span class=\"comment\">// B is an object, can't be forward declared</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// b.h (guarded)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  A a;   <span class=\"comment\">// A is an object, can't be forward declared</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Function-inlining\"><a href=\"#Function-inlining\" class=\"headerlink\" title=\"Function inlining\"></a>Function inlining</h2><p>Inline Function body needs to exist in every cpp file which calls them, otherwise you get linker errors</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Func</span><span class=\"params\">(<span class=\"keyword\">const</span> A&amp; a)</span>   <span class=\"comment\">// parameter, so forward declare is okay</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    a.DoSomething();      <span class=\"comment\">// but now that we've dereferenced it, it</span></span><br><span class=\"line\">                          <span class=\"comment\">//  becomes an #include dependency</span></span><br><span class=\"line\">               <span class=\"comment\">// = we now have a potential circular inclusion</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>The key is that while inline function need to exist in the header, they <strong>do not need to exist in the class definition itself</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// b.h  (assume its guarded)</span></span><br><span class=\"line\"><span class=\"comment\">//------------------</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>;</span>  <span class=\"comment\">// forward declared dependency</span></span><br><span class=\"line\"><span class=\"comment\">//------------------</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Func</span><span class=\"params\">(<span class=\"keyword\">const</span> A&amp; a)</span></span>;  <span class=\"comment\">// okay, A is forward declared</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//------------------</span></span><br><span class=\"line\"><span class=\"comment\">//now B is already defined</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span>        <span class=\"comment\">// can use A with include dependency without error</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">B::Func</span><span class=\"params\">(<span class=\"keyword\">const</span> A&amp; a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  a.DoSomething();    <span class=\"comment\">// okay!  a.h has been included</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>even if a.h includes b.h, the additional #includes don’t come up until AFTER class B is fully defined, and they are therefore harmless.</p>\n<p>But putting function bodies at the end of my header is ugly. Is there a way to avoid that?</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// b.h</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// blah blah</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> &#123;</span> <span class=\"comment\">/* blah blah */</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b_inline.h\"</span>  <span class=\"comment\">// or I sometimes use \"b.hpp\" </span></span></span><br><span class=\"line\">```\t</span><br><span class=\"line\"></span><br><span class=\"line\">``` cpp</span><br><span class=\"line\"><span class=\"comment\">// b_inline.h (or b.hpp -- whatever)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span>  <span class=\"comment\">// not necessary, but harmless</span></span></span><br><span class=\"line\">                <span class=\"comment\">//  you can do this to make this \"feel\" like a source</span></span><br><span class=\"line\">                <span class=\"comment\">//  file, even though it isn't</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">B::Func</span><span class=\"params\">(<span class=\"keyword\">const</span> A&amp; a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  a.DoSomething();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>This seperates the interface from the implementation, while still allowing the implementation to be inlined</p>\n<h2 id=\"Forward-declaring-templates\"><a href=\"#Forward-declaring-templates\" class=\"headerlink\" title=\"Forward declaring templates\"></a>Forward declaring templates</h2><p>Forward declaring is pretty straight-forward when it comes to simple classes, but when dealing with template classes, things aren’t so simple</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span> <span class=\"comment\">// included dependencies</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"comment\">// the class template</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tem</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"> <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">  B b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// class most commonly used with 'int'</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Tem&lt;<span class=\"keyword\">int</span>&gt; A;  <span class=\"comment\">// typedef as 'A' </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// b.h</span></span><br><span class=\"line\"><span class=\"comment\">// forward declared dependencies</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>;</span>  <span class=\"comment\">// error!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// the class</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"> <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">  A* ptr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>Because ‘A’ isn’t really a class, but rather a typedef, the compiler will bark at you<br>we can’t just #include “a.h” here because of a circular dependency problem</p>\n<p>We need to forward typedef A  </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tem</span>;</span>  <span class=\"comment\">// forward declare our template</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Tem&lt;<span class=\"keyword\">int</span>&gt; A;               <span class=\"comment\">// then typedef 'A' (forward typedef A instead of forward declare A)</span></span><br></pre></td></tr></table></figure>\n\n<p>A cleaner solution is to create an <strong>alternative header</strong> which has the forward declarations of your templated classes and their typedefs</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//a.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tem</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"> <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">  B b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"comment\">//a_fwd.h</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tem</span>;</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> Tem&lt;<span class=\"keyword\">int</span>&gt; A;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//b.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a_fwd.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"> <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">  A* ptr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>This allows B to include a header which forward declares A without including the entire class definition</p>\n",
            "tags": [
                "c",
                "cpp"
            ]
        },
        {
            "id": "http://gitqwerty777.github.io/makefile/",
            "url": "http://gitqwerty777.github.io/makefile/",
            "title": "建立Makefile",
            "date_published": "2015-02-22T15:31:44.000Z",
            "content_html": "<p>此篇文章十分清楚易懂，可作為初學之用</p>\n<a id=\"more\"></a>\n\n<h3 id=\"使用make好處\"><a href=\"#使用make好處\" class=\"headerlink\" title=\"使用make好處\"></a>使用make好處</h3><ul>\n<li>方便專案管理</li>\n<li>會透過檔案比對，依照相依性來編譯，不會全都編浪費時間</li>\n<li>可以同時編譯函式庫或是檔案</li>\n</ul>\n<h3 id=\"make常用指令\"><a href=\"#make常用指令\" class=\"headerlink\" title=\"make常用指令\"></a>make常用指令</h3><ul>\n<li><code>make -k</code>: 會讓make在遇到錯誤的時候仍然運行，而不會在第一個問題中斷</li>\n<li><code>make -n</code>: 只印出將會進行的工作，而不會真的執行</li>\n<li><code>make -f makefile_name</code>: make預設執行名為makefile的檔案，此命令可指定makefile檔案名稱和位置</li>\n<li><code>#</code>: 註解  </li>\n</ul>\n<h3 id=\"make指令格式\"><a href=\"#make指令格式\" class=\"headerlink\" title=\"make指令格式\"></a>make指令格式</h3><p>預設的target是”all”, 若makefile中沒有all, 則是第一個target</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">make [option] [target]</span><br><span class=\"line\">make -n all clean <span class=\"comment\"># 多個target</span></span><br><span class=\"line\">make -f makefile2 install</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"撰寫makefile檔案\"><a href=\"#撰寫makefile檔案\" class=\"headerlink\" title=\"撰寫makefile檔案\"></a>撰寫makefile檔案</h3><p>makefile是由一堆「目標」和其「相依性檔案」還有「法則」所組成的    </p>\n<ul>\n<li>[target] 目標 - 產生出來的東西    <ul>\n<li>用了 <code>.PHONY</code> 來指定 clean 為 fake 項目，所以 make 不會去檢查目錄中是否存在了一個名為 clean 的檔案。如此也可以提昇 make 的執行效率<ul>\n<li>常用的偽target<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">.PHONY: all clean install</span><br><span class=\"line\">all: ...</span><br><span class=\"line\">\t...</span><br><span class=\"line\">install: myapp app.doc   <span class=\"comment\">#安裝套件</span></span><br><span class=\"line\">     cp myapp app.doc /usr/<span class=\"built_in\">local</span>/myapp/</span><br><span class=\"line\">clean: <span class=\"comment\">#刪除產生出來的目的檔</span></span><br><span class=\"line\">\trm -rf *.o</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>[dependency] 相依性項目 - 若 dependency 的檔案有改動過，則重新產生 target</li>\n<li>[rule] 法則 - 如何產生目標<ul>\n<li>使用Tab作為開頭</li>\n<li>使用 Shell Script 語法</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[target]: [dependency] [dependency]</span></span><br><span class=\"line\">     [rule]</span><br><span class=\"line\">     [rule]</span><br><span class=\"line\"><span class=\"section\">[target]: [dependency]</span></span><br><span class=\"line\">     [rule]</span><br></pre></td></tr></table></figure>\n\n<p>註1: makefile的命令和shell不同的地方: 每行命令在<strong>分開的shell中獨立執行</strong></p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">wrongClean:</span></span><br><span class=\"line\">\tcd junkdir</span><br><span class=\"line\">\trm -f * <span class=\"comment\"># don't do that! </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">correctClean1:</span></span><br><span class=\"line\">\tcd junkdir &amp;&amp; rm -f *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">correctClean2:</span></span><br><span class=\"line\">\trm -f junkdir/*</span><br></pre></td></tr></table></figure>\n\n<p><del>如果寫錯的話，至少錯誤的makefile被刪除了</del></p>\n<p>註2: 在命令行首加上<code>@</code>，代表執行程式但不顯示在螢幕上。在命令行首加上<code>-</code>，代表執行命令時回傳非零值仍然繼續執行()</p>\n<p>例：要產生all的話，需要兩個檔案myapp和app.doc(主程式和說明檔)，make開始會去找尋如何產生myapp和 app.doc的方法，所以myapp會成為下一個要產生出來的目標。用gcc main.o a.o b.o -o myapp來產生myapp……，以此類推</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">all: myapp app.doc</span></span><br><span class=\"line\"><span class=\"section\">myapp: main.o a.o b.o</span></span><br><span class=\"line\">     gcc main.o a.o b.o -o myapp</span><br><span class=\"line\"><span class=\"section\">main.o: main.c a.h</span></span><br><span class=\"line\">     gcc -c main.c</span><br><span class=\"line\"><span class=\"section\">a.o: a.c a.h</span></span><br><span class=\"line\">     gcc -c a.c</span><br><span class=\"line\"><span class=\"section\">b.o: b.c b.h</span></span><br><span class=\"line\">     gcc -c b.c</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在makefile中, 相依性順序是很重要的</p>\n</blockquote>\n<h2 id=\"Makefile的變數和巨集-macro\"><a href=\"#Makefile的變數和巨集-macro\" class=\"headerlink\" title=\"Makefile的變數和巨集(macro)\"></a>Makefile的變數和巨集(macro)</h2><p>設定變數的方法  </p>\n<ul>\n<li>將export命令放在shell啟動script <code>.bashrc</code>或<code>.zshrc</code>…<ul>\n<li>永遠都有效</li>\n</ul>\n</li>\n<li>在shell中設定變數 <code>export CC=gcc</code><ul>\n<li>終端機開啟期間有效</li>\n</ul>\n</li>\n<li>在執行命令前設定 <code>CC=gcc | make</code><ul>\n<li>針對特定命令的變數</li>\n<li>設定變數需要在實際命令之前</li>\n</ul>\n</li>\n<li><code>make</code>可以直接設定變數<ul>\n<li><code>make CFLAGS=&quot;-g -Wall&quot;</code></li>\n<li><code>CFLAGS=&quot;-g -Wall&quot; make</code></li>\n</ul>\n</li>\n<li>在makefile中設定<ul>\n<li><code>?=</code>：若變數未定義，則替它指定新的值。否則，採用原有的值。  <ul>\n<li><code>FOO ?= bar</code>： 若 FOO 未定義，則 FOO = bar；若 FOO 已定義，則 FOO 的值維持不變。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>指定時，等號兩側不可有空格</p>\n<p>改變副檔名  </p>\n<ul>\n<li>SRC=a.c b.c</li>\n<li>OBJ=$(SRC:.c=.o) # equals to a.o b.o</li>\n</ul>\n<p>有幾個特別的內部巨集，讓makeifle更加簡明  </p>\n<ul>\n<li><code>$?</code> 代表需要重建的相依性項目(檔案有被更新過)，也就是 dependencies 中，比 targets 的修改日期還新檔案。</li>\n<li><code>$@</code> 目前的target</li>\n<li><code>$*</code> 不含副檔名的target</li>\n<li><code>$&lt;</code> 第一個 dependency</li>\n</ul>\n<p>還有兩個有用的特別字元，可以加在要執行的命令之前  </p>\n<ul>\n<li><code>-</code> 即使該行指令出錯，也不會中斷執行</li>\n<li><code>@</code> 不會在terminal顯示該行命令</li>\n</ul>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\">CC = gcc</span><br><span class=\"line\">CFLAGS = -Wall -ansi -g</span><br><span class=\"line\">OBJS = main.o a.o b.o</span><br><span class=\"line\">INSTALL_PATH = /usr/local/myapp/</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">all: myapp app.doc</span></span><br><span class=\"line\"><span class=\"section\">myapp: <span class=\"variable\">$(OBJS)</span></span></span><br><span class=\"line\">     <span class=\"variable\">$(CC)</span> <span class=\"variable\">$(OBJS)</span> -o <span class=\"variable\">$@</span></span><br><span class=\"line\"><span class=\"section\">main.o: main.c a.h</span></span><br><span class=\"line\">     <span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -c -o <span class=\"variable\">$@</span> <span class=\"variable\">$&lt;</span></span><br><span class=\"line\"><span class=\"section\">a.o: a.c a.h</span></span><br><span class=\"line\">     <span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -c -o <span class=\"variable\">$@</span> <span class=\"variable\">$&lt;</span></span><br><span class=\"line\"><span class=\"section\">b.o: b.c b.h</span></span><br><span class=\"line\">     <span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -c -o <span class=\"variable\">$@</span> <span class=\"variable\">$&lt;</span></span><br><span class=\"line\"><span class=\"section\">install: myapp app.doc</span></span><br><span class=\"line\">     cp myapp app.doc <span class=\"variable\">$(INSTALL_PATH)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Makefile-隱性法則-implicit-rule\"><a href=\"#Makefile-隱性法則-implicit-rule\" class=\"headerlink\" title=\"Makefile 隱性法則(implicit rule)\"></a>Makefile 隱性法則(implicit rule)</h2><figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\">CC = gcc</span><br><span class=\"line\">CFLAGS = -Wall -ansi -g</span><br><span class=\"line\">OBJS = main.o a.o b.o</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">all: myapp app.doc</span></span><br><span class=\"line\"><span class=\"section\">myapp: <span class=\"variable\">$(OBJS)</span></span></span><br><span class=\"line\">     <span class=\"variable\">$(CC)</span> <span class=\"variable\">$(OBJS)</span> -o <span class=\"variable\">$@</span></span><br><span class=\"line\"><span class=\"section\">main.o: main.c a.h</span></span><br><span class=\"line\"><span class=\"section\">a.o: a.c a.h</span></span><br><span class=\"line\"><span class=\"section\">b.o: b.c b.h</span></span><br></pre></td></tr></table></figure>\n\n<p>makefile會在main.o自動產生規則 <code>gcc -Wall -ansi -g -c -o main.o main.c</code>  </p>\n<ul>\n<li>若dependency為c：<code>$(CC) $(CFLAGS) $(LDFLAGS) [dependencies]</code></li>\n<li>若dependency為c++：<code>$(CXX) $(CXXFLAGS) $(LDFLAGS) [dependencies]</code></li>\n<li>若dependency為object(建立執行檔)：<code>$(CC) $(LDFLAGS) [dependencies] $(LDLIBS)</code>  </li>\n</ul>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9tYWtlL21hbnVhbC9odG1sX25vZGUvQ2F0YWxvZ3VlLW9mLVJ1bGVzLmh0bWwjQ2F0YWxvZ3VlLW9mLVJ1bGVz\">隱性法則列表<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"Makefile-檔尾法則\"><a href=\"#Makefile-檔尾法則\" class=\"headerlink\" title=\"Makefile 檔尾法則\"></a>Makefile 檔尾法則</h2><p>使用檔尾的延伸檔名作為法則，格式 <code>.[old_suffix].[new_suffix]</code>  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">.c.o:</span></span><br><span class=\"line\">     <span class=\"variable\">$(CC)</span> <span class=\"variable\">$(CFLAGS)</span> -c -o <span class=\"variable\">$@</span> <span class=\"variable\">$&lt;</span></span><br><span class=\"line\"><span class=\"section\">.cpp.o:</span></span><br><span class=\"line\">     g++ -c <span class=\"variable\">$&lt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">INCLUDE_PATH = <span class=\"keyword\">include</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">all: myapp.exe app.doc</span></span><br><span class=\"line\"><span class=\"section\">myapp.exe: <span class=\"variable\">$(OBJS)</span></span></span><br><span class=\"line\">     <span class=\"variable\">$(CC)</span> <span class=\"variable\">$(OBJS)</span> -o <span class=\"variable\">$@</span></span><br><span class=\"line\"><span class=\"section\">.c.o:</span></span><br><span class=\"line\">     <span class=\"variable\">$(CC)</span> -I<span class=\"variable\">$(INCLUDE_PATH)</span> <span class=\"variable\">$(CFLAGS)</span> -c -o <span class=\"variable\">$@</span> <span class=\"variable\">$&lt;</span></span><br></pre></td></tr></table></figure>\n\n<p>檔尾法則只可以用在本目錄</p>\n<p>這目錄下面所有的.c檔變成.o檔，而法則就是去編譯它，而如果你想更懶一點的話還可以完全不寫，直接使用內建的法則，這樣也可以直接把目錄下面的所有檔都編好，為什麼呢？因為你要編出myapp的時候需要使用到$(OBJS)所以，就算你不寫.c.o或是任何的法則，make預設都會自己產生.o檔讓你可以連結出主程式。  </p>\n<p>makefile也有支援萬用字元  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">%.o: %.c</span></span><br><span class=\"line\">     <span class=\"variable\">$(CC)</span> -I<span class=\"variable\">$(INCLUDE_PATH)</span> <span class=\"variable\">$(CFLAGS)</span> -c -o <span class=\"variable\">$@</span> <span class=\"variable\">$&lt;</span></span><br></pre></td></tr></table></figure>\n\n<p>萬用字元法則比較適合用於編譯一個大型的函式庫，而檔尾法則適合編譯一個目錄下面所有的檔案。</p>\n<h2 id=\"專案討論\"><a href=\"#專案討論\" class=\"headerlink\" title=\"專案討論\"></a>專案討論</h2><h3 id=\"Make-Makefile-with-Release-and-Debug-build\"><a href=\"#Make-Makefile-with-Release-and-Debug-build\" class=\"headerlink\" title=\"Make Makefile with Release and Debug build\"></a>Make Makefile with Release and Debug build</h3><p><span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83OTIyMTcvc2ltcGxlLW1ha2VmaWxlLXdpdGgtcmVsZWFzZS1hbmQtZGVidWctYnVpbGRzLWJlc3QtcHJhY3RpY2Vz\">simple-makefile-with-release-and-debug-builds-best-practices<i class=\"fa fa-external-link-alt\"></i></span><br><span class=\"exturl\" data-url=\"aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDc5ODMyL2hvdy1jYW4taS1jb25maWd1cmUtbXktbWFrZWZpbGUtZm9yLWRlYnVnLWFuZC1yZWxlYXNlLWJ1aWxkcw==\">how-can-i-configure-my-makefile-for-debug-and-release-builds<i class=\"fa fa-external-link-alt\"></i></span></p>\n<h2 id=\"參考資料\"><a href=\"#參考資料\" class=\"headerlink\" title=\"參考資料\"></a>參考資料</h2><ul>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2hzaWFuLXN0dWRpby5ibG9nc3BvdC50dy8yMDA4LzA5L21ha2VmaWxlXzA4Lmh0bWw=\">撰寫Makefile教學<i class=\"fa fa-external-link-alt\"></i></span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3RldHJhbGV0Lmx1bmEuY29tLnR3Lz9vcD1WaWV3QXJ0aWNsZSZhcnRpY2xlSWQ9MTg1\">Makefile 語法簡介<i class=\"fa fa-external-link-alt\"></i></span></li>\n</ul>\n",
            "tags": [
                "linux",
                "makefile"
            ]
        }
    ]
}